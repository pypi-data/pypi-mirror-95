#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

#   Copyright 2009-2021 Oli Schacher, Fumail Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This tool is used to analyze/export the current configuration

from optparse import OptionParser
import sys
import os
import configparser
import io
import logging
import inspect
import re


def stderr(msg):
    sys.stderr.write(msg)


def print_config(config):
    for sec in config.sections():
        print("")
        print("[%s]" % sec)
        for op, val in config.items(sec):
            print("%s=%s" % (op, val))


def cloneConfig(config):
    tmpfile = io.StringIO()
    config.write(tmpfile)
    theClone = configparser.RawConfigParser()
    tmpfile.seek(0)
    theClone.read_file(tmpfile)
    return theClone


def config_equals(default, actual):
    """return true if default and actual mean the same thing, eg. """
    if default is None:
        default = ""
    default = default.strip().lower()
    actual = actual.strip().lower()
    # we use '1' because 1 could be a numeric config as well which would be
    # destroyed
    if default in ['yes', '1', 'true', 'on']:
        default = '1'

    if actual in ['yes', '1', 'true', 'on']:
        actual = '1'

    # path names, strip trailing slashes
    if len(default) > 1 and default.endswith('/'):
        default = default[:-1]
    if len(actual) > 1 and actual.endswith('/'):
        actual = actual[:-1]

    if default == actual:
        return True

    return False


def print_overrides(defaultconfig, userconfig, controller):
    for sec in defaultconfig.sections():
        have_printed_section = False
        for opt, defaultval in defaultconfig.items(sec):
            if userconfig.has_option(sec, opt):
                userval = userconfig.get(sec, opt)
                if not config_equals(defaultval, userval):
                    if not have_printed_section:
                        print("")
                        print("[%s]" % sec)
                        have_printed_section = True

                    pdef = defaultval
                    if defaultval is None or defaultval.strip() == '':
                        pdef = 'empty'
                    MAXCHARS = 15
                    if len(pdef) > MAXCHARS:
                        pdef = pdef[:MAXCHARS - 3] + "..."

                    pval = userval
                    # check if confidential
                    meta = get_config_meta(controller, sec, opt)
                    if pval.strip() != '' and meta is not None and 'confidential' in meta and meta['confidential']:
                        pval = "***REDACTED***"

                    print("%s=%s (def: %s)" % (opt, pval, pdef))


def make_config(controller, onlysection=None):
    config = controller.config

    for sec in config.sections():
        if onlysection is not None and sec != onlysection:
            continue

        print("\n[%s]" % sec)
        lines = []

        for opt, val in config.items(sec):
            buff = ""
            meta, order = get_config_meta(controller, sec, opt)
            if meta is not None and 'description' in meta:
                desc = '\n#'.join(meta['description'].split('\n'))
                buff += '\n#%s' % desc

            buff += "\n%s=%s" % (opt, val)
            lines.append((buff, order))

        sortedlines = sorted(lines, key=lambda x: x[1])
        for line in sortedlines:
            print(line[0])


def get_config_meta(controller, section, option):
    """retrieve config metadata from loaded controller/plugin instances"""
    allobjects = []
    # core config
    allobjects.append(controller)
    # plugins
    allobjects.extend(controller.plugins)
    allobjects.extend(controller.prependers)
    allobjects.extend(controller.appenders)

    for obj in allobjects:
        if hasattr(obj, 'requiredvars'):
            reqvars = getattr(obj, 'requiredvars')
            if type(reqvars) == dict:
                if option in reqvars:
                    infodic = reqvars[option]
                    clone = infodic.copy()
                    msection = None
                    if 'section' in clone:
                        msection = clone['section']
                    elif hasattr(obj, 'section'):
                        clone['section'] = getattr(obj, 'section')
                        msection = clone['section']
                    else:
                        sys.stderr.write(
                            "Warning, no section found. obj=%s meta=%s\n" % (obj, clone))
                    if msection != section:
                        continue

                    order = extract_option_order(obj, option)
                    return clone, order
    return None, 0


def extract_option_order(obj, option):
    """Try to extract the order in which options where defined. (Evil source inspection hack.. dicts don't have an order)"""
    sourcelines = inspect.getsourcelines(obj.__class__)[0]
    counter = 0
    for line in sourcelines:
        m = re.match(r'''\s+['"](?P<name>[a-zA-Z_]+)['"]\s?:\s?{''', line)
        if m is not None:
            srcopt = m.groups()[0]
            counter += 1
            if option == srcopt:
                return counter
    return 0

if __name__ == '__main__':
    logging.basicConfig(level=logging.ERROR)
    optionparser = OptionParser()
    optionparser.add_option("-d", dest="defaults", action="store_true", default=False,
                            help="print out  defaults")
    optionparser.add_option("-n", dest="notdefaults", action="store_true", default=False,
                            help="print out values that differ from the default (use this for questions on the mailing lists)")
    optionparser.add_option(
        "-m", dest="make", help="make default config (args: plugin or 'all')")
    optionparser.add_option(
        "-b", dest="basedir", help="try importing the fuglu codebase from this directory instead of the system default")
    optionparser.add_option("-c", dest="configdir", default="/etc/fuglu",
                            help="directory that contains fuglu.conf and optionally the conf.d subdirectory")
    (options, pargs) = optionparser.parse_args()

    if options.basedir:
        if os.path.exists(options.basedir + "/fuglu/core.py"):
            sys.path.insert(0, options.basedir)
        else:
            stderr("%s doesn't contain fuglu source" % options.basedir)
            sys.exit(1)

    confdir = options.configdir
    if confdir.endswith('/'):
        confidir = confdir[:-1]
    dconfdir = confdir + "/conf.d"

    fugluconfigfile = os.path.join(confdir, "fuglu.conf")
    userconfig = configparser.RawConfigParser()
    if not os.path.exists(fugluconfigfile):
        stderr("""Configfile (%s) not found. """ % fugluconfigfile)
        sys.exit(1)
    readconfig = userconfig.read_file(open(fugluconfigfile))
    # load conf.d
    if os.path.isdir(dconfdir):
        filelist = os.listdir(dconfdir)
        configfiles = [
            dconfdir + '/' + c for c in filelist if c.endswith('.conf')]
        readfiles = userconfig.read(configfiles)

    from fuglu.core import MainController
    defaultconfig = configparser.RawConfigParser()

    # copy plugindir, pluginalias and active plugins from current config
    defaultconfig.add_section("main")
    for sec, op in [('main', 'plugindir'), ('main', 'plugins'), ('main', 'prependers'), ('main', 'appenders')]:
        if not defaultconfig.has_section(sec):
            defaultconfig.add_section(sec)
        if userconfig.has_option(sec, op):
            defaultconfig.set(sec, op, userconfig.get(sec, op))

    if userconfig.has_section('PluginAlias'):
        if not defaultconfig.has_section('PluginAlias'):
            defaultconfig.add_section('PluginAlias')

        for op, val in userconfig.items('PluginAlias'):
            defaultconfig.set('PluginAlias', op, val)

    if options.make and options.make.lower() != 'all':
        defaultconfig.set('main', 'plugins', options.make)
        defaultconfig.set('main', 'prependers', '')
        defaultconfig.set('main', 'appenders', '')

    # load default values from plugins
    defcontroller = MainController(defaultconfig)
    defcontroller.propagate_core_defaults()
    defcontroller.load_plugins(propagate_plugin_config=True)

    # load active values
    activeconfig = cloneConfig(userconfig)
    activecontroller = MainController(activeconfig)
    activecontroller.propagate_core_defaults()
    activecontroller.load_plugins(propagate_plugin_config=True)

    if options.defaults:
        print_config(defaultconfig)
    elif options.notdefaults:
        print_overrides(defaultconfig, userconfig, activecontroller)
    elif options.make:
        sec = None
        if options.make.lower() != 'all':
            if len(defcontroller.plugins) == 0:
                stderr("could not load plugin '%s'\n" % options.make)
                sys.exit(1)
            sec = defcontroller.plugins[0].section
        make_config(defcontroller, sec)
    else:
        print_config(activeconfig)
