# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proto/automator.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict
from typing import List
from typing import Optional

import betterproto


@dataclass
class DeviceIdentifier(betterproto.Message):
    """
    A description of a remote device or Netflix RAE. This is used to identify a
    target device, a device on a specific RAE, or just a RAE.
    """

    # The ESN of a remote target device
    esn: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # The IP of a remote target device
    ip: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # The ADB serial of a remote target device
    serial: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # A remote Netflix RAE to address in the form r1234567, as opposed to a web
    # site or host name
    rae: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # The MAC address of the remote device
    mac_address: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    # The ADB serial key of an Android TV device
    adb_serial: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)


@dataclass
class DeviceIdentifierTarget(betterproto.Message):
    """A message with only a target device"""

    # The device or Netflix RAE to address
    target: "DeviceIdentifier" = betterproto.message_field(1)


@dataclass
class EstimatedDuration(betterproto.Message):
    # The estimated duration of the test based on recent executions, in minutes
    duration: Optional[float] = betterproto.message_field(1, wraps=betterproto.TYPE_FLOAT)
    # The estimated duration of the test based on recent executions, in seconds
    duration_sec: Optional[int] = betterproto.message_field(2, wraps=betterproto.TYPE_UINT32)


@dataclass
class TestCase(betterproto.Message):
    """A description of a Netflix Device UI test"""

    # The name key or guid of a test: AUDIO-001-TC1, ACT-004-TC11, etc.
    name: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # A URL to the test, relative or absolute.
    exec: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # Text of a CSV field including all the test tags
    tags: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # The test category.
    category: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # The status of the test. Values could be "applicable", "N/A for Plan",
    # "Maintenance", "exempted"
    status: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    # Estimates of run time based on recent executions
    estimated_time: "EstimatedDuration" = betterproto.message_field(6)


@dataclass
class TestPlan(betterproto.Message):
    """A description of a test plan"""

    # A list of TestCase objects.
    testcases: List["TestCase"] = betterproto.message_field(1)
    # The SDK version of the test plan, such as ninja_6, 5.2, etc.
    sdk_version: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # The branch where the test is stored. This can be used to easily change
    # which branch is addressed by relative URLs in TestCase objects. example:
    # branch="http://mirror.dta.netflix.com/path/to/something/" Do not include
    # the "nrdptest" subdirectory in that url, it is appended by the Automator
    branch: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # The batch ID generated by NTS for the test plan run. This is always
    # generated by NTS. Use batch_name to request an identifier to search for in
    # NTS.
    batch_id: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    error: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    message: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)
    # Optional user provided batch name for grouping in NTS history.
    batch_name: Optional[str] = betterproto.message_field(7, wraps=betterproto.TYPE_STRING)
    # Estimates of run time based on recent executions
    estimated_time: "EstimatedDuration" = betterproto.message_field(8)


@dataclass
class GetTestPlanRequestOptions(betterproto.Message):
    """Options handed to the Netflix Dynamic Test Plan service"""

    # UUID4 string. If there is a known playlist ID to get instead of the
    # standard dynamic test plan from NTS, provide it here
    playlist_id: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)


@dataclass
class GetTestPlanRequest(betterproto.Message):
    """Request a test plan from a device on a remote Netflix RAE."""

    # Which device to get a test plan for, and which RAE it is on. The rae field
    # must be set, as well as one or more of the esn, ip, or serial fields.
    target: "DeviceIdentifier" = betterproto.message_field(1)
    # Optional: Options handed to the Netflix Dynamic Test Plan service, like a
    # specific request ID go in this object.
    options: "GetTestPlanRequestOptions" = betterproto.message_field(2)
    # Optional: Force the type of the run: dial or adb
    type: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)


@dataclass
class GetTestPlanResponse(betterproto.Message):
    """A response to getting a test plan."""

    # Which device generated the test. The rae field will not be set
    # automatically.
    target: "DeviceIdentifier" = betterproto.message_field(1)
    # The test plan retrieved from the Dynamic Test Plan system June 2020: moving
    # to testplanCompressed to stay under 128kb payloads
    testplan: "TestPlan" = betterproto.message_field(2)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    error: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    message: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # June 2020 Instead of moving the TestPlan directly over the wire, we will
    # get it in gzipped in this byte field. The consumer must gzip uncompress it
    # into JSON, which can be loaded in to a TestPlan message.
    testplan_compressed: Optional[bytes] = betterproto.message_field(5, wraps=betterproto.TYPE_BYTES)


@dataclass
class HttpLikeGetTestPlanErrorResponseBody(betterproto.Message):
    """
    If an error happens when getting a test plan from a remote device, it will
    populate the error and/or message fields.
    """

    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    message: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)


@dataclass
class HttpLikeGetTestPlanErrorResponse(betterproto.Message):
    """
    If an error happens when getting a test plan from a remote device, it will
    populate the error and/or message fields.
    """

    # http status code
    status: int = betterproto.uint32_field(1)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    body: "HttpLikeGetTestPlanErrorResponseBody" = betterproto.message_field(2)


@dataclass
class HttpLikeErrorResponseBody(betterproto.Message):
    """
    If an error happens when getting a test plan from a remote device, it will
    populate the error and/or message fields.
    """

    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    message: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    error: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)


@dataclass
class HttpLikeErrorResponse(betterproto.Message):
    # http status code
    status: int = betterproto.uint32_field(1)
    # If an error happens when getting a test plan from a remote device, it will
    # populate the error and/or message fields.
    body: "HttpLikeGetTestPlanErrorResponseBody" = betterproto.message_field(2)


@dataclass
class HttpLikeGetTestPlanResponse(betterproto.Message):
    # http status code
    status: int = betterproto.uint32_field(1)
    # The test plan retrieved from the Dynamic Test Plan service
    body: "TestPlan" = betterproto.message_field(2)


@dataclass
class TestPlanRunRequest(betterproto.Message):
    """A request to run a test plan on a device"""

    # Which device to run tests on, and which RAE it is on. The rae field must be
    # set, as well as one or more of the esn, ip, or serial fields.
    target: "DeviceIdentifier" = betterproto.message_field(1)
    # The test plan to run
    testplan: "TestPlan" = betterproto.message_field(2)
    # Instead of moving the TestPlan directly over the wire, we will put it
    # gzipped in this byte field. The Automator module will gzip uncompress it
    # into JSON.
    testplan_compressed: Optional[bytes] = betterproto.message_field(3, wraps=betterproto.TYPE_BYTES)


@dataclass
class TestPlanRunResponse(betterproto.Message):
    """A response to a test plan run request"""

    # The status of the test plan run:
    status: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # If an error happens when scheduling a test plan run, it will populate the
    # error and/or message fields
    message: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # If an error happens when scheduling a test plan run, it will populate the
    # error and/or message fields
    error: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # The NTS batch ID for the run, generated by NTS. This can be used to request
    # status later, and to request results in NTS History.
    batch_id: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # This topic will get updated with status update JSON objects. When doing
    # custom integrations, a client can subscribe to this topic to get live
    # update as the test plan runs.
    result_topic: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    # The target device that is running the test plan. This will generally be
    # more complete than the DeviceIdentifier in the TestPlanRunRequest.
    target: "DeviceIdentifier" = betterproto.message_field(6)
    # Optional user provided batch name for grouping in NTS history.
    batch_name: Optional[str] = betterproto.message_field(7, wraps=betterproto.TYPE_STRING)


@dataclass
class HttpLikeTestPlanRunResponse(betterproto.Message):
    # http status code
    status: int = betterproto.uint32_field(1)
    body: "TestPlanRunResponse" = betterproto.message_field(2)


@dataclass
class AvafPeripheralDescriptionConfig(betterproto.Message):
    audioinput: str = betterproto.string_field(1)
    device_category_id: int = betterproto.uint32_field(2)
    frc_setting: str = betterproto.string_field(3)
    hdmi_topology: str = betterproto.string_field(4)
    toneref: Dict[str, float] = betterproto.map_field(5, betterproto.TYPE_STRING, betterproto.TYPE_FLOAT)
    calibration_markerset: str = betterproto.string_field(6)


@dataclass
class AvafHardwareConfig(betterproto.Message):
    usb_port: str = betterproto.string_field(1)
    serial: str = betterproto.string_field(2)
    version: str = betterproto.string_field(3)
    target_version: str = betterproto.string_field(4)


@dataclass
class AvafPeripheralDescription(betterproto.Message):
    type: str = betterproto.string_field(1)
    peripheral_id: str = betterproto.string_field(2)
    esn: str = betterproto.string_field(3)
    hw_config: "AvafHardwareConfig" = betterproto.message_field(4)
    config: "AvafPeripheralDescriptionConfig" = betterproto.message_field(5)
    active: bool = betterproto.bool_field(6)
    inactive_reason: str = betterproto.string_field(7)


@dataclass
class HttpLikeAvafPeripheralListResponse(betterproto.Message):
    # running, pending, etc.
    status: int = betterproto.uint32_field(1)
    body: List["AvafPeripheralDescription"] = betterproto.message_field(2)


@dataclass
class AvafPeripheralListRequest(betterproto.Message):
    target: "DeviceIdentifier" = betterproto.message_field(1)
    type: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)


@dataclass
class StatusRequest(betterproto.Message):
    """
    Request status from the Automator Both fields are optional. A request with
    no device identifier should get the state of all sessions.
    """

    # Optional. A device target to filter results  by. If set, try to filter
    # results to just this matching device. If it is not matched, all results
    # will be returned.
    target: "DeviceIdentifier" = betterproto.message_field(1)
    # If both target and batch_id are set, request the full run result of this
    # batch on that device. Otherwise ignored.
    batch_id: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)


@dataclass
class StatusSession(betterproto.Message):
    """A session status as part of a status response."""

    # The key 'status' is usually one of these: running, pending, passed, failed,
    # cancelled, invalid
    status: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    # The device this session was run on
    target: "DeviceIdentifier" = betterproto.message_field(2)
    # The last batch name that was run on this device. Either lastBatch or
    # resultTopic will be populated, but not both. lastBatch will be populated if
    # there is no currently running test plan for this device.
    last_batch: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)
    # The last batch name that was run on this device. Either lastBatch or
    # resultTopic will be populated, but not both. resultTopic will be populated
    # if a test plan is currently running on this device.
    result_topic: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)


@dataclass
class TestCaseResult(betterproto.Message):
    """The results of a single test run on a remote device"""

    # test case name or guid as defined by Netflix test metadata
    name: str = betterproto.string_field(1)
    # URL to the javascript file
    url: str = betterproto.string_field(2)
    # state of the test: passed, failed, invalid, cancelled, pending, etc.
    status: str = betterproto.string_field(3)
    # NTS run ID
    run_id: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # NTS marker set ID
    nts_id: Optional[str] = betterproto.message_field(5, wraps=betterproto.TYPE_STRING)
    # URL to the ADB logcat captured during the test
    logcat: Optional[str] = betterproto.message_field(6, wraps=betterproto.TYPE_STRING)
    # Text of the step running or last run
    step: Optional[str] = betterproto.message_field(7, wraps=betterproto.TYPE_STRING)
    # Time the test started in ISO format
    started: Optional[str] = betterproto.message_field(8, wraps=betterproto.TYPE_STRING)
    # Time the test ended in ISO format
    ended: Optional[str] = betterproto.message_field(9, wraps=betterproto.TYPE_STRING)
    # URL to the Netflix console log file
    console_log: Optional[str] = betterproto.message_field(10, wraps=betterproto.TYPE_STRING)
    # URL for a zip file of all logs and data files related to this test. This
    # URL expires shortly after being uploaded.
    results_url: Optional[str] = betterproto.message_field(11, wraps=betterproto.TYPE_STRING)
    # If the test was skipped by the Automator, the reason will be sent in this
    # field.
    reason: Optional[str] = betterproto.message_field(12, wraps=betterproto.TYPE_STRING)


@dataclass
class PilotStatusSessionList(betterproto.Message):
    """A response to a status request"""

    # The list of sessions the Automator knows of. If the request was for a
    # specific device and batch, this will not be set. If the Automator has just
    # started up, it will likely be empty. It is not re-populated from storage.
    sessions: List["StatusSession"] = betterproto.message_field(1)
    # Results of a specific batch, if requested. If the request to status was
    # sent with a device and batch name, the results and batch_id fields will be
    # populated.
    results: List["TestCaseResult"] = betterproto.message_field(2)
    # The batch name, if requested. If the StatusRequest was sent with a device
    # and batch name, the results and batch_id fields will be populated.
    batch_id: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)


@dataclass
class HttpLikeListTargetsErrorResponse(betterproto.Message):
    # http status code
    status: int = betterproto.uint32_field(1)
    error: str = betterproto.string_field(2)


@dataclass
class HttpLikeListTargetsResponse(betterproto.Message):
    # http status code
    status: int = betterproto.uint32_field(1)
    body: List["DeviceIdentifier"] = betterproto.message_field(2)


@dataclass
class CancelBody(betterproto.Message):
    """The body of a cancel response"""

    status: str = betterproto.string_field(1)
    # A response from the Automator about the cancel request This includes
    # phrases that can be detected that will tell you whether the device was
    # actually running tests or not, if the device was not found, etc.
    message: str = betterproto.string_field(2)


@dataclass
class HttpLikeCancelResponse(betterproto.Message):
    """A response from a cancel request"""

    status: str = betterproto.string_field(1)
    body: "CancelBody" = betterproto.message_field(2)


@dataclass
class StatusResultsUrl(betterproto.Message):
    """Results URL description block"""

    download_url: Optional[str] = betterproto.message_field(1, wraps=betterproto.TYPE_STRING)
    bucket: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    path: Optional[str] = betterproto.message_field(3, wraps=betterproto.TYPE_STRING)


@dataclass
class StatusBody(betterproto.Message):
    """
    An abbreviated status of an Automator test session. During a test plan run:
    This can be used to report progress through a test plan. There is enough
    information to form update strings such as: Currently running test 8 of 12
    total tests, named FOO, currently on "Step 4. play movie for 30 seconds" Or
    to update a UI progress bar. It would be ideal to download error and data
    URLs as they are reported in these blocks, as their lifetime is not long.
    results_url will not be set. After a test plan run: If the session is not
    currently running (such as the final update after a test plan ends) the
    results_url field will be set to a location to download the full JSON
    report of the test plan. It would be ideal to download error and data URLs
    as they are reported in these blocks, as their lifetime is not long. The
    final result broadcast after a test run will not set the data field. If
    collecting batch results for a device after a run completes, only the
    target, batch_id, and results_url field will be set.
    """

    # Is the batch currently running?
    running: Optional[bool] = betterproto.message_field(1, wraps=betterproto.TYPE_BOOL)
    # Batch ID on NTS history page
    batch_id: Optional[str] = betterproto.message_field(2, wraps=betterproto.TYPE_STRING)
    # Which device ran this batch
    target: "DeviceIdentifier" = betterproto.message_field(3)
    # The type of launcher used to control the device: dial, adb, etc.
    type: Optional[str] = betterproto.message_field(4, wraps=betterproto.TYPE_STRING)
    # The total number of tests in the test plan
    test_total: Optional[int] = betterproto.message_field(5, wraps=betterproto.TYPE_UINT32)
    # The current test index, if set
    test_index: Optional[int] = betterproto.message_field(6, wraps=betterproto.TYPE_UINT32)
    # The TestCaseResult object of the current running test This is not set if
    # running is False
    data: "TestCaseResult" = betterproto.message_field(7)
    # The URL of the full JSON result payload This is not set if running is True
    # It would be ideal to download this soon after it is reported, as these URLs
    # expire shortly after reported here. These are not stored across reboots of
    # the Automator, so restarting to the Automator module or RAE will erase this
    # history from API access. The results are not lost, but must then be
    # retrieved from the NTS web interface.
    results_url: Optional[str] = betterproto.message_field(8, wraps=betterproto.TYPE_STRING)
    # The list of sessions the Automator knows of. If the request was for a
    # specific device and batch, this will not be set. If the Automator has just
    # started up, it will likely be empty. It is not re-populated from storage.
    sessions: List["StatusSession"] = betterproto.message_field(9)
    # If reading the status report from a loaded URL, you will get this block
    # filled, which is the extended test case result for every test run. This is
    # not generally provided. It is usually only populated by the full test case
    # batch result, provided as a separate download.
    results: List["TestCaseResult"] = betterproto.message_field(10)
    # Optional user provided batch name for grouping in NTS history.
    batch_name: Optional[str] = betterproto.message_field(11, wraps=betterproto.TYPE_STRING)


@dataclass
class HttpLikeStatusResponse(betterproto.Message):
    """
    Response for status calls for the results of a specific device-batch pair
    """

    # http status code
    status: str = betterproto.string_field(1)
    body: "StatusBody" = betterproto.message_field(2)
