# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['clima', 'clima.fire']

package_data = \
{'': ['*']}

install_requires = \
['bleach>=3.1.5',
 'cryptography>=3.2',
 'python-dotenv>=0.15.0,<0.16.0',
 'six',
 'tabulate>=0.8.7']

setup_kwargs = {
    'name': 'clima',
    'version': '0.7.9',
    'description': 'Simple boilerplate for cli scripts',
    'long_description': '<img src="https://raw.githubusercontent.com/d3rp/clima/master/clima.png" align="left" /> Create a command line interface with minimal setup.\n\n\n[![PyPI](https://img.shields.io/pypi/v/clima)](https://pypi.org/project/clima/)\n[![Python versions](https://img.shields.io/pypi/pyversions/clima)]()\n[![PyPI license](https://img.shields.io/pypi/l/clima)]() \n[![Build status](https://travis-ci.com/d3rp/clima.svg?branch=master)](https://travis-ci.com/d3rp/clima)\n[![Dependencies](https://img.shields.io/librariesio/github/d3rp/clima)]() \n\n # clima - command line interface with a schema \n\n##### Table of contents\n\n  * [Briefly](#briefly)\n     * [Features](#features)\n     * [Cli definition](#cli-definition)\n     * [Configuration object in a spiffy](#configuration-object-in-a-spiffy)\n  * [Installing](#installing)\n  * [Usage](#usage)\n  * [Examples and platforms](#examples-and-platforms)\n     * [Testing the examples](#testing-the-examples)\n  * [Version printing](#version-printing)\n  * [Autocompletion](#autocompletion)\n     * [..in IDEs (wip)](#in-ides-wip)\n     * [..in bash](#in-bash)\n  * [Post init hook](#post-init-hook)\n     * [Cli.post_init()](#clipost_init)\n     * [Schema.post_init()](#schemapost_init)\n  * [Configuration options](#configuration-options)\n     * [Configuration file and environment variables](#configuration-file-and-environment-variables)\n     * [Type casting with configuration definition](#type-casting-with-configuration-definition)\n     * [Configuration file in the home directory](#configuration-file-in-the-home-directory)\n     * [.env file](#env-file)\n     * [Password unwrapping/decryption with pass](#password-unwrappingdecryption-with-pass)\n  * [Additional features via Fire](#additional-features-via-fire)\n  * [Truncated error printing](#truncated-error-printing)\n  * [Ways to run the script for the uninitiated](#ways-to-run-the-script-for-the-uninitiated)\n     * [Linking executable script to ~/.local/bin](#linking-executable-script-to-localbin)\n     * [Packaging a module (pip ready)](#packaging-a-module-pip-ready)\n  * [Building/Installing from source](#buildinginstalling-from-source)\n  * [Long description and background](#long-description-and-background)\n     * [Why another cli framework?](#why-another-cli-framework)\n  * [Dependencies](#dependencies)\n   \n## Briefly\n\n### Features\n\nClima handles loading and parsing command\nline arguments with some off-the-shelf features including:\n\n- a global configuration object\n    - quick definition of defaults\n    - defining defaults doubles as description for help on the command line\n    - type handling with annotations\n- definitions with configuration files\n- env variables\n    - loading .env files\n- secrets stored with [pass](https://www.passwordstore.org/)\n- post_init hook\n\n### Cli definition\n\nCreating a cli:\n\n1. Import all necessary parts from the package clima\n1. (optional) Define configuration i.e. Schema\n1. Define the command line commands i.e. Cli-class:\n\n![example ascii](https://raw.githubusercontent.com/d3rp/clima/master/example.svg)\n\nExample: to setup a configuration and a command line interface ready to go.\n\n    from clima import c\n    \n    @c\n    class Cli:\n        def say_hi(self):\n            print(\'oh hi - whatever this is..\')\n            \n            \nThe command line usage form could be as simple as:\n  \n     my_tool say_hi\n  \n### Configuration object in a spiffy\n\n    from clima import c\n    \n    # Defining the settings (configuration object)\n    class S(Schema):\n        place = \'world\'\n        \n    @c\n    class Cli:\n        def say_hi(self):\n            # using configuration object \'c\'\n            print(f\'oh hi - {c.place}\')\n            \n            \nThe command line usage form could be as simple as:\n  \n     my_tool say_hi\n     my_tool say_hi --place \'other world\'\n \nSee the `examples` folder and other sections for more examples. For example the folder includes [something that resembles\nthe example above](examples/readme_example.py).\n  \n\n## Installing\n\n    pip install --user clima\n\n[toc](#table-of-contents)\n\n   \n\n## Usage\n\nSee the example file in [`examples/script_example.py`](examples/script_example.py). Here\'s a run down of the individual\nparts in such a script (adapted from another example at [module example](examples/module_example)).\n\nFirst import the required components:\n\n    from clima import c, Schema\n    \nIn your code define the `Schema` subclass:\n\n    class Configuration(Schema):\n        a: str = \'A\'  # a description\n        x: int = 1  # x description\n\nHere "Configuration" is an arbitrary name, no magic there. The inherited `Schema` class\ndefines the attributes (i.e. `a` and `x` in this example). \n\nNote the specific formatting of the `Schema` subclass:\n\n        # attribute[: type] = default value  [# Description for the --help]\n        a: str = \'A\'  # a description\n       \n`a` is the attribute which can be called in the code later with `c.a`. In this example, it has a type of \'str\' and a default\nvalue of \'A\'. The comment after is not redundant in the sense that it is parsed for the command line help. The values in square brackets `[]` are\noptional.\n\nAll of these parts will be parsed for the \'--help\' for the subcommands of the cli, for example:\n\n    ./script.py foo -h\n    \nWill now produce:\n\n     Usage:       script.py foo [ARGS]\n     \n     Description: Args:\n         --a (str): a description (Default is \'A\')\n         --x (int): x description (Default is 1)    \n\nThe example in the readme can be found at `examples/readme_example.py`.\n\nThe subcommands - or commands of the script - should be defined somewhat as follows:\n\n    @c\n    class Cli:\n        def subcommand_foo(self):\n            """This will be shown in --help for subcommand-foo"""\n            print(\'foo\')\n            print(c.a)\n            print(c.x)\n\n        def subcommand_bar(self):\n            """This will be shown in --help for subcommand-bar"""\n            print(\'bar\')\n\nThe methods are parsed as subcommands and their respective doc strings will show in the \nsubcommands\' help printout. Note the double usage of the `c` - first as a decorated and later as the parsed configuration\ninside the method:\n\n    ...\n        ...\n        print(c.a)\n        print(c.x)\n        \n[toc](#table-of-contents)\n\n## Examples and platforms\n\nTried and used on linux, macos and windows. However, python packaging and dependency management is sometimes hairy and\nyour mileage may vary.\n\nMore examples in the [examples directory](examples) with printouts of the defined subcommands and helps.\n\n\n### Testing the examples\n\nThe [examples](examples) can be tried out by cloning the repo and running from repo directory root (on linux and the like):\n\n    git clone https://github.com/d3rp/clima.git \n    cd clima\n    PYTHONPATH=$PWD python ./examples/readme_example.py foo -h\n\nRunning the examples that wrap a module:\n\n    PYTHONPATH=$PWD python ./examples/module_example/__main__.py -h\n    PYTHONPATH=$PWD python ./examples/module_example/__main__.py subcommand-foo -h\n    PYTHONPATH=$PWD python ./examples/module_example/__main__.py subcommand-bar\n    ...\n\nOutput should resemble this (fire v0.1.3 prints out Args, fire v0.2.1 doesn\'t (though looks much nicer))\n\n```\n$ tester subcommand-foo -- -h\n\nType:        method\nString form: <bound method Cli.subcommand_foo of <__main__.Cli object at 0x000002995AD74BE0>>\nFile:        C:\\Users\\foobar\\code\\py\\clima\\tester\\__main__.py\nLine:        18\nDocstring:   This will be shown in --help for subcommand-foo\nArgs:\n    --a (str): a description (Default is \'A\')\n    --x (int): x description (Default is 1)\n\nUsage:       __main__.py subcommand-foo [--X ...]\n```\n\nAll of the example scripts can be run by installing [poetry](https://python-poetry.org) and running the `run_examples.bash`\nscript:\n\n    pip install --user poetry\n    ./run_examples.bash\n   \n[toc](#table-of-contents)\n\n## Version printing\n\nVersion printing works via the `version` subcommand. This is intended for scripts that are packaged as command line tools\nwith poetry. Thus with bumping the version with poetry, clima will handle parsing the current version of your tool so\nit can be queried with:\n\n    my_tool version\n   \nThe actual version is parsed into the `c` so overwrite it with `post_init` or something if you want control over it.\n\n## Autocompletion\n \n### ..in IDEs (wip)\n\nAlso, to enable autocompletion in IDEs, this hack suffices:\n\n    c: Configuration = c\n\nPut it in the "global space" e.g. just after defining the template. See the [`examples/script_example.py`](examples/script_example.py) for a specific example.\n\nWhen all is complete, the imported `c` variable should have all the bits and pieces for the configuration. It can be\nused inside the Cli class as well as imported around the codebase thus encapsulating all the configurations into one\ncontainer with quick access with attributes `c.a`, `c.x`, etc...\n\n### ..in bash\n\nRun your script with `-- --completion` arguments:\n\n    my_tool -- --completion\n  \nThis should print an autocompletion definition to include in your bash completions.\n\nTBD: zsh etc. completions\n\n## Post init hook\n\nThere\'s two ways to define a post_init hook depending if it is done in the `Schema` subclass or the `Cli` definition.\n\n### Cli.post_init()\n\nIn some occasions it\'s useful to deduce specific defaults from the given parameters e.g. in a cross platform build allowing\nonly minimal cli arguments. For those cases there\'s an `post_init` hook\nWhen defining the post_init() in the Cli class, i.e.\n\n    @c\n    class Cli:\n    \n        @staticmethod\n        def post_init(s):\n            if s.platform = \'win\':\n                self.bin_path = \'c:/Users/foo/bar\'\n            else:\n                s.bin_path = \'/Users/mac/sth\'\n            \n        def subcommand(self):\n            pass\n               \nThe method will have access to the cli args, but can not introduce new variables to the schema.\n\nThis is arguably the more useful of the two variations of post_inits.\n\nNote: The signature of the `post_init()` differs depending on which of the stages it is defined in. For the time being\nit is a `@staticmethod`\n\n### Schema.post_init()\n\nThis alternative is for to use post_init-like features positioning the steps so that command line arguments can still\noverride things.\n\n    class SoAdvanced(Schema):\n    \n        platform: str = \'win\'  # a description\n        bin_path: pathlib.Path = \'\'  # x description\n        \n        def post_init(self, *args):\n            if self.platform = \'win\':\n                self.win_specific_field = \'All your files are locked by us..\'\n            \n                \nNote: This post_init() does not have access to the cli arguments, but the `Schema`\'s post_init can introduce new\nattributes/properties/fields/arguments to the configuration, which the Cli-class post-init can\'t.\nSchema post init hook is run after schema initialization, but BEFORE the cli initialization. \n\n\n[toc](#table-of-contents)\n\n## Configuration options\n\nIt\'s tedious to have to write a long list of parameters on the command line, when most of the use cases\nfollow a similar pattern. To facilitate the use of configurations, there\'s several options to choose from.\n\nThe `c` decorator/configuration chains multiple configuration options together in order of priority\n(lower number overrides higher number):\n\n1. command line arguments\n1. Environment variables\n1. .env file\n1. configuration file definitions\n1. decrypted passwords from `~/.password-store` if gnugpg is installed\n1. defaults in the subclass inheriting `Schema`\n\n### Configuration file and environment variables\n\n\nThe configuration file should be named with either the postfix `.conf` or `.cfg` e.g. `foo.conf` and have an ini type formatting with\na \'Clima\' section:\n\n    # foo.conf\n    [Clima]\n    x = 2\n\nThe keys are the same as what you define in the schema. You can define all, some or none of the attributes.\nSame applies for the env variables.\n    \n    # linux example\n    X=2 tester subcommand-foo\n    \nA configuration file defined this way can be located in the current working directory or - if your `Schema` defines a\n `cwd` field - there. Clima\nwill try to use the first configuration file it finds, so that might produce some caveats.\n\n    class Conf(Schema):\n        cwd = \'\'\n\n    # Running ./script.py --cwd <folder> would automatically load the first *.conf file in <folder>\n\n### Type casting with configuration definition\n \nThe `Schema` definition can have type annotations, which are used to cast the given arguments. For example\n\n    class C(Schema):\n        p: Path = \'\'  # Path to something\n\nResults in `c.p`\'s type cast as `Path`.   \n\n### Configuration file in the home directory\n\nYou can also define the config file in the configuration class (one inheriting `Schema`) by defining the\nmagic field `CFG`.\n\nFor example, lets say the command `my_tool` (packaged etc) has a user configuration file at `~/.my_tool.conf`. This\ncan now be handled with just adding `CFG = Path.home() / \'.my_tool.conf` to the Schema:\n\n    from pathlib import Path\n    \n    class S(Schema):\n        bing = \'bang\'\n        CFG = Path.home() / \'.my_tool.conf\'\n    \nThen, for example, the configuration file would be written as:\n\n    #~/.my_tool.conf\n    [Clima]\n    bing = diudiu\n\nRunning the command `my_tool` would produce the value in the configuration file, though the arguments can still be overriden. \n\n    my_tool run \n    # diudiu\n    \n    my_tool run --bing bam\n    # bam\n    \n### .env file\n \n This is handled by [dotenv](https://github.com/theskumar/python-dotenv). In short, all the defaults defined in the\n `Schema` subclass can be overridden either by:\n \n    <field> = <value>\n\nor\n\n    export <field> = <value>\n    \n### Password unwrapping/decryption with pass\n \n Note: Currently this works only for gpg-keys without password. It\'s not ideal, but it\'s better than plain text `.env`\n files ;)\n \n Note 2: Leading and trailing whitespace (including `\\n` linefeeds) are stripped, when decrypted.\n \n [pass](https://passwordstore.org) can be used to store passwords as gpg encrypted files under the home directory. Clima\n uses the default path of ~/.password-store and the files found within. It will then match the arguments with the \n stored passwords, for example:\n \n     tree -A ~/.password-store                                                                                                                                                                                                                                                                            \ue0b2 ✔ | 41s | anaconda3 \ue73c\n     /Users/me/.password-store\n     ├── work\n     │   ├── ci\n     │   │   ├── sign_id.gpg\n     │   │   ├── sign_pw.gpg\n     ... ... ...\n \n And an according `Schema` definition:\n \n     class Conf(Schema):\n         sign_id: str = \'\'  # signing id for the CI\n         sign_pw: str = \'\'  # signing pw for the CI\n \n Would accept those arguments as cli arguments, or if omitted, would traverse through the `.password-store` and decrypt the\n found `sign_id.gpg` and `sign_pw.gpg` placing the values found in the configuration object `c`.\n     \n [toc](#table-of-contents)      \n \n## Additional features via Fire\n\nSee the [Python Fire\'s Flags](https://github.com/google/python-fire/blob/master/docs/using-cli.md#python-fires-flags)\ndocumentation for nice additional features such as:\n\n    # e.g. tester.py is our cli program\n    tester.py subcommand-foo -- --trace\n    tester.py -- --interactive\n    tester.py -- --completion\n    \n\n## Truncated error printing\n\nEven though I\'ve used python for a few years professionally, I\'m still not satisfied with its error printing. Clima\ntruncates the error lists and tries to provide a more readable version of the "first" point of failure. The whole\ntraceback is written into a logfile `exception_traceback.log` so it can be examined when the truncated output is not\nenough.\n\nNote: When running the examples, the `exception_traceback.log` file will be written inside the `examples` directory\n\n\n## Ways to run the script for the uninitiated\n\nHere\'s a section to suggest ideas how to wrap scripts using clima.\n\n### Linking executable script to ~/.local/bin\n\nLet\'s say those lines were written in a file named `script.py`. Command line usage in a terminal would then be e.g.:\n\n    python script.py foo\n    python script.py foo --a 42\n\nAdding this line in `script.py`\n\n    #!/usr/bin/env python\n    \nand changing its execution permissions (mac, linux):\n\n    chmod +x script.py\n   \nAllows for a shorter means of execution:\n\n    ./script.py foo\n\nNow this could be linked as an adhoc command for example:\n\n    ln -s $PWD/script.py ~/.local/bin/my_command\n\n### Packaging a module (pip ready)\n\nFor a pip-installable package, one could [package this as a runnable command](https://github.com/d3rp/my_tool) -\npublish in the public or one\'s private pypi etc - and then approach the convenience factor shown at first.\n\n    pip install my_tool\n    my_command foo -h\n\nTo publish with poetry is quite straight forward. First create an account in pypi.org and then:\n\n    cd <project directory>\n    poetry build\n    poetry publish\n \nYou can use `version` to bump up versions:\n    \n    poetry version patch\n\n## Building/Installing from source\n\nThis repo is based on [poetry](https://poetry.eustace.io).\n\n    git clone https://github.com/d3rp/clima.git \n    cd clima\n    poetry install --no-dev\n\nThe `--no-dev` is for to install the running environment without development tooling.\n\n[toc](#table-of-contents)\n\n## Long description and background\n\nThe subcommands are written as a class encapsulating the "business logic".\nYou can define a simple schema of the configuration that maps to the command line arguments.\n\nIn other words, you can use this to wrap your scripts as command line commands without resorting to bash or\nmaintaining argument parsing in python. This removes the need of duplicating comments in order `--help` to remember what the arguments were and what they did. Sprinkling some decorator magic offers a typical use experience of a cli program (e.g. argument parsing and validation, --help, subcommands, ...).\n\nThe implementation is focused on a premise that for a simple script there\'s usually a script wide global configuration which would be used through out the user code i.e. a context for the program that is refered to in different parts of the code. That configuration is populated with given arguments falling back on defaults in the code and some further complimentary options. Those are then made accessible via a global `c` variable that can be tossed around the code base with very little additional effort. With a small adjustment this can made to autocomplete in IDEs (as attributes). This helps when the schema of the configuration grows larger as the autocomplete kicks in after typing `c.` offering those fields in your "schema" as attributes.\n \n### Why another cli framework?\n\nClima is not intended to cater all needs of a feature complete cli framework like the ones enlisted below.\nThis is a package to help with boilerplate to get quick, but reusable tools for your workflow.\n\nOther options for full featured cli experience:\n\n* [docopt](https://docopt.org)\n* [fire](https://github.com/google/python-fire)\n* [cleo](https://github.com/sdispater/cleo)\n* [click](https://click.palletsprojects.com)\n* [typer](https://github.com/tiangolo/typer)\n\n\n## Dependencies\n\n* [dotenv](https://github.com/theskumar/python-dotenv)\n* gnugpg - this is pass through though. If it\'s not installed, the feature is not in use.\n\n* fire - [python-fire](https://github.com/google/python-fire) from google does the cli wrapping / forked and included \ninto the repo - I wanted to have the version 0.1.x formatting and help output with few hacks of my own\n\n\n[toc](#table-of-contents)\n',
    'author': 'Joni Turunen',
    'author_email': 'rojun.itu@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/d3rp/clima.git',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6',
}


setup(**setup_kwargs)
