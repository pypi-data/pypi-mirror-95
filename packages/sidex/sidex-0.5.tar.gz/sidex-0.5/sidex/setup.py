#!/usr/bin/env python
# -*- coding: utf-8 -*-
''' SIDEX miscellaneous functions.

This module provides miscellaneous functions to setup the SIDEX server.
The behaviours of the `get`, `put`, and `delete` methods are defined.

Use the `setup` function to launch a customized SIDEX server.
'''
from flask import Flask, Response
from flask import request, url_for, render_template
import os, re, logging, requests

werkzeug = logging.getLogger('werkzeug')
werkzeug.setLevel('ERROR')

app = Flask(__name__)


@app.context_processor
def override_url_for():
  ''' A helper function to construct a url with `subdir` option.

  This does nothing when the `subdir` option is not defined.
  The url is modified in case that the `subdir` is given. The modified
  `url_for` function accepts the following arguments.

  Args:
    endpoint (str):
        The relative path to the requested resource.
    *args:
        Variable length argument list.
    **options:
        Arbitrary option arguments.

  Returns:
    str: A constructed url to the requeste resource.
  '''
  def url_for_subdir(endpoint, *args, **options):
    subdir = '/{}'.format(app.subdir) if app.subdir else ''
    return subdir+url_for(endpoint, *args, **options)
  return dict(url_for=url_for_subdir)


def eprint(message, exc_info=None):
  ''' Print an error message in the log file.

  Args:
    message (str):
        The body of the error message.
    exc_info (Exception,optional):
        The Exception instance to print traceback information.
  '''
  remote = request.remote_addr
  app.logger.error(remote+':{}'.format(message), exc_info=exc_info)


def iprint(message):
  ''' Print an info message in the log file.

  Args:
    message (str):
        The body of the information message.
  '''
  remote = request.remote_addr
  app.logger.info(remote+':{}'.format(message))


def dprint(message):
  ''' Print a debug message in the log file.

  Args:
    message (str):
        The body of the debug message.
  '''
  remote = request.remote_addr
  app.logger.debug(remote+':{}'.format(message))


def invalid_path(path):
  ''' Check whether the <path> looks invalid.

  Args:
    path (str):
        The path to the file to be checked.

  Returns:
    bool:
        `true` when the <path> contains any invalid sequences.
  '''
  return '../' in path


def default_delete_function(req, local_path, **options):
  ''' Define the default behavior of the `delete` method.

  This function removes the file located at <local_path>.

  Args:
    req (flask.request):
        The request instance given by Flask.
    local_path (str):
        The absolute path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  filename = os.path.basename(local_path)
  os.unlink(local_path)
  return Response('"{}" successfully deleted.\n'.format(filename))


def delete(req, target, **options):
  ''' Provide the `delete` method.

  This function is called when the `delete` method is selected.
  The <app.delete_function> is called internally. When the customized
  `delete_function` is specified, the behavior of the `delete` method
  is overridden.

  This method is disabled by default. To enable the `delete` method,
  the application should be setup with `delete_token`. The token is
  reffered to as <app.delete_token>.

  The request must contain the `token` field. When the `token` is not
  available, this always returns an error message.
  In case that the `token` does not equal to <app.delete_token>,
  an error message will be returned.

  Args:
    req (flask.request):
        A request instance generated by Flask.
    target (str):
        The path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  local_path = '{}/{}'.format(app.workdir,target)
  filename = os.path.basename(local_path)
  dirname = os.path.dirname(local_path)
  emsg = lambda s: 'cannot delete "{}": {{}}.\n'.format(target).format(s)
  ## check if a valid token is given.
  if app.delete_token is None:
    eprint('disabled function "delete" called.')
    return Response(emsg('function disabled'), status=400)
  token = req.form.get('token')
  dprint('token = "{}"'.format(token))
  if app.delete_token is not None and token != app.delete_token:
    return Response(emsg('invalid token'), status=400)
  ## assert path seems valid.
  if invalid_path(target):
    eprint('invalid path: {}'.format(target))
    return Response(emsg('invalid path'), status=400)
  ## delete a file.
  try:
    return app.delete_function(req,local_path, **options)
  except FileNotFoundError as e:
    eprint(str(e))
    return Response(emsg('file not found'), status=404)
  except Exception as e:
    eprint(str(e))
    errmsg = emsg('unexpected error: {}'.format(e.__class__.__name__))
    return Response(errmsg, status=500)


def default_put_function(req, local_path, **options):
  ''' Define the default behavior of the `put` method.

  This function create a file stored in <req> at <local_path>.
  This fails when the local directory does not exist. Note that
  any existing file cannot be overwritten.

  Args:
    req (flask.request):
        The request instance given by Flask.
    local_path (str):
        The absolute path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  filename = os.path.basename(local_path)
  dirname = os.path.dirname(local_path)
  req.files['payload'].save(local_path)
  return Response('successfully uploaded to "{}".\n'.format(filename))


def put(req, target, **options):
  ''' Provide the `put` method.

  This function is called when the `put` method is selected.
  The <app.put_function> is called internally. When the customized
  `put_function` is specified, the behavior of the `put` method
  is overridden.

  This method is disabled by default. To enable the `put` method,
  the application should be setup with `put_token`. The token is
  reffered to as <app.put_token>.

  The request must contain the `token` field. When the `token` is not
  available, this always returns an error message.
  In case that the `token` does not equal to <app.put_token>,
  an error message will be returned.

  Args:
    req (flask.request):
        A request instance generated by Flask.
    target (str):
        The path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  local_path = '{}/{}'.format(app.workdir,target)
  filename = os.path.basename(local_path)
  emsg = lambda s: 'cannot create "{}": {{}}.\n'.format(target).format(s)
  ## check if a valid token is given.
  if app.put_token is None:
    eprint('disabled function "put" called.')
    return Response(emsg('function disabled'), status=400)
  token = req.form.get('token')
  dprint('token = "{}"'.format(token))
  if app.put_token is not None and token != app.put_token:
    return Response(emsg('invalid token'), status=400)
  ## assert path seems valid.
  if invalid_path(target):
    eprint('invalid path: {}'.format(target))
    return Response(emsg('invalid path'), status=400)
  ## overwrite is not allowed.
  if os.path.exists(local_path):
    eprint('file "{}" already exists.'.format(local_path))
    return Response(emsg('cannot overwrite files'), status=400)
  ## create a file.
  if 'payload' not in req.files:
    return Response(emsg('"payload" is required'), status=400)
  try:
    return app.put_function(req,local_path, **options)
  except FileNotFoundError as e:
    eprint(str(e))
    return Response(emsg('file not found'), status=404)
  except Exception as e:
    eprint(str(e))
    errmsg = emsg('unexpected error: {}'.format(e.__class__.__name__))
    return Response(errmsg, status=500)


def default_get_function(req, local_path, **options):
  ''' Define the default behavior of the `get` method.

  Returns the file content located at <local_path>.

  Args:
    req (flask.request):
        The request instance given by Flask.
    local_path (str):
        The absolute path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  with open(local_path, 'rb') as f:
    return Response(f.read(), mimetype='application/octet-stream')


def get(req, target, **options):
  ''' Provide the `get` method.

  This function is called when the `get` method is selected.
  The <app.get_function> is called internally. When the customized
  `get_function` is specified, the behavior of the `get` method
  is overridden.

  This method can be protected by setting `get_token`. The token is
  reffered to as <app.get_token>. When <app.get_token> is defined,
  the request must contain the `token` field.
  In case that the `token` does not equal to <app.get_token>,
  an error message will be returned.

  Args:
    req (flask.request):
        A request instance generated by Flask.
    target (str):
        The path to the requested resource.
    **options:
        Arbitrary option arguments.
        Currently no option is passed to this function.

  Returns:
    flask.Response:
        A response message.
  '''
  local_path = '{}/{}'.format(app.workdir,target)
  filename = os.path.basename(local_path)
  emsg = lambda s: 'cannot access "{}": {{}}.\n'.format(target).format(s)
  ## check if a valid token is given.
  if app.get_token is not None:
    dprint('"get" function requres a token.')
    token = req.form.get('token')
    dprint('token = "{}"'.format(token))
    if token != app.get_token:
      return Response(emsg('invalid token'), status=400)
  ## assert path seems valid.
  if invalid_path(target):
    eprint('invalid path: {}'.format(target))
    return Response(emsg('invalid path'), status=500)
  ## access to file.
  #if os.path.exists(local_path):
  try:
    return app.get_function(req, local_path, **options)
  except FileNotFoundError as e:
    eprint(str(e))
    return Response(emsg('file not found'), status=404)
  except IsADirectoryError as e:
    eprint(str(e))
    return Response(emsg('directory requested'), status=400)
  except Exception as e:
    eprint(str(e))
    errmsg = emsg('unexpected error: {}'.format(e.__class__.__name__))
    return Response(errmsg, status=500)


@app.route('/<path:target>', methods=['GET', 'POST'])
def access_point(target):
  ''' The access point of the SIDEX server.

  This function handles the request to the SIDEX server.
  Only the <POST> resuest is available. An instruction message
  will be returned in case of the <GET> request.

  The `method` field is mandatory. The value should be one of `get`,
  `put` and `delete`. The corresponding function will be called.

  The `token` field is required in the `put` and `delete` methods.

  Args:
    target (str):
        The path to the requested resource.

  Returns:
    flask.Response:
        The response instance from the requested method.
  '''
  local_path = '{}/{}'.format(app.workdir,target)
  emsg = lambda s: 'cannot access "{}": {{}}.\n'.format(target).format(s)
  if request.method == 'GET':
    errmsg = '''GET is not available in the SIDEX server.

Use POST to access the SIDEX server.
The `method` field is required. Choose from `get`, `put` or `delete`.
The `put` and `delete` methods also requires the `token` field.
'''
    return Response(errmsg, status=501)
  else:
    method = request.form.get('method','none').lower()
    if method == 'get':
      return get(request, target)
    elif method == 'put':
      return put(request, target)
    elif method == 'delete':
      return delete(request, target)
    else:
      return Response('invalid method: {}.\n'.format(method), status=400)


def setup(
    workdir, subdir=None,
    get_function=default_get_function,
    put_function=default_put_function,
    delete_function=default_delete_function,
    get_token=None, put_token=None, delete_token=None,
    log_handler=None, log_level='INFO'):
  ''' Setup a customized SIDEX server.

  Args:
    workdir (str):
        The relative path to the working directory.
    subdir (str,optional):
        The name of the subdirectory.
    get_function (function,optional):
        The function instance called in the `get` method.
        The following arguments are required:
            - req (flask.request): The flask request instance.
            - local_path (str): The local path to the resource.
    put_function (function,optional):
        The function instance called in the `put` method.
        The following arguments are required:
            - req (flask.request): The flask request instance.
            - local_path (str): The local path to the resource.
    delete_function (function,optional):
        The function instance called in the `delete` method.
        The following arguments are required:
            - req (flask.request): The flask request instance.
            - local_path (str): The local path to the resource.
    get_token (str,optional):
        The secret token for the `get` method.
    put_token (str,optional):
        The secret token for the `put` method.
    delete_token (str,optional):
        The secret token for the `delete` method.
    log_handler (logger.Logger,optional):
        The user-defined log handler to override the default handler.
    log_level (str,optional):
        The log_level. `INFO` is given by default.
  '''
  if get_token is not None: assert len(get_token) > 0
  if put_token is not None: assert len(put_token) > 0
  if delete_token is not None: assert len(delete_token) > 0
  app.workdir = workdir
  app.get_function = get_function
  app.put_function = put_function
  app.delete_function = delete_function
  app.get_token = get_token
  app.put_token = put_token
  app.delete_token = delete_token
  app.subdir = subdir
  app.logger.setLevel(log_level)
  if log_handler is not None:
    werkzeug.handlers = []
    app.logger.handlers = [log_handler,]
  return app
