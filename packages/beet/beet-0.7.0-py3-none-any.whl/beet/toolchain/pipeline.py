__all__ = [
    "GenericPipeline",
    "Task",
    "GenericPlugin",
    "GenericPluginSpec",
    "PluginError",
    "PluginImportError",
]


from dataclasses import dataclass, field
from typing import (
    Any,
    Generic,
    Iterable,
    Iterator,
    List,
    Optional,
    Protocol,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
)

from .utils import import_from_string

T = TypeVar("T")


class GenericPlugin(Protocol[T]):
    """Protocol for detecting plugins."""

    def __call__(self, ctx: T) -> Any:
        ...


GenericPluginSpec = Union[GenericPlugin[T], str]


class PluginError(Exception):
    """Raised when a plugin raises an exception."""


class PluginImportError(PluginError):
    """Raised when a plugin couldn't be imported."""


@dataclass
class Task(Generic[T]):
    """A unit of work generated by the pipeline."""

    plugin: GenericPlugin[T]
    iterator: Optional[Iterator[Any]] = None
    exception_fallthrough: Tuple[Type[Exception], ...] = ()

    def advance(self, ctx: T) -> Optional["Task[T]"]:
        """Make progress on the task and return it unless no more work is necessary."""
        try:
            if self.iterator is None:
                result = self.plugin(ctx)
                self.iterator = iter(
                    cast(Iterable[Any], result) if isinstance(result, Iterable) else []
                )
            for _ in self.iterator:
                return self
        except (PluginError,) + self.exception_fallthrough:
            raise
        except Exception as exc:
            raise PluginError(self.plugin) from exc.with_traceback(
                getattr(exc.__traceback__, "tb_next", exc.__traceback__)
            )
        return None


@dataclass
class GenericPipeline(Generic[T]):
    """The plugin execution engine."""

    ctx: T
    default_symbol: str = "beet_default"
    exception_fallthrough: Tuple[Type[Exception], ...] = ()

    plugins: Set[GenericPlugin[T]] = field(default_factory=set)
    tasks: List[Task[T]] = field(default_factory=list)

    def require(self, spec: GenericPluginSpec[T]):
        """Execute the specified plugin."""
        plugin = self.resolve(spec)
        if plugin in self.plugins:
            return

        self.plugins.add(plugin)

        task = Task(plugin, exception_fallthrough=self.exception_fallthrough)

        if remaining_work := task.advance(self.ctx):
            self.tasks.append(remaining_work)

    def resolve(self, spec: GenericPluginSpec[T]) -> GenericPlugin[T]:
        """Return the imported plugin if the argument is a dotted path."""
        try:
            return (
                import_from_string(spec, default_member=self.default_symbol)
                if isinstance(spec, str)
                else spec
            )
        except (PluginError,) + self.exception_fallthrough:
            raise
        except Exception as exc:
            raise PluginImportError(spec) from exc

    def run(self, specs: Iterable[GenericPluginSpec[T]] = ()):
        """Run the specified plugins."""
        for spec in specs:
            self.require(spec)

        while self.tasks:
            if remaining_work := self.tasks.pop().advance(self.ctx):
                self.tasks.append(remaining_work)
