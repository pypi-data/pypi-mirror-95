Metadata-Version: 2.1
Name: YDbf
Version: 0.4
Summary: Pythonic reader and writer for DBF/XBase files
Home-page: https://github.com/y10h/ydbf
Author: Yury Yurevich
Author-email: python@y10h.com
License: GNU GPL2
Description: YDbf
        ====
        
        YDbf - reading and writing DBF/XBase files in a pythonic way.
        The library written in pure Python and have no external
        dependencies.
        
        YDbf is compatible with Python 2.7+ and 3.5+.
        
        What YDbf is good for:
        
         - export data to a DBF file
         - import data from a DBF file
         - read data from a DBF file as a stream
        
        Where YDbf is not a good fit:
        
         - random access to records in a DBF file
         - memo fields
        
        Read DBF
        --------
        
        The entrypoint of YDbf is `open` function:
        
            dbf = ydbf.open('simple.dbf')
        
        You can use file name, or already opened in binary mode file:
        
            fh = open('simple.dbf', 'rb')
            dbf = ydbf.open(fh)
            
            for record in dbf:
                ...
        
        You may also use `with` statement:
        
            with ydbf.open('simple.dbf') as dbf:
                for record in dbf:
                    ...
        
        Each record is a dict, which keys are names of fields.
        
        Write DBF
        ---------
        
        YDbf opens file for reading by default, but you may set option `mode` to
        open for writing:
        
            dbf = ydbf.open('simple.dbf', 'w', fields)
        
        or open file yourself:
        
            fh = open('simple.dbf', 'wb')
            dbf = ydbf.open(fh, 'w', fields)
        
        `fields` is a structure description of DBF file, it is a required option for
        write mode. The structure is as sequence of field descriptions,
        where each fields described by tuple (NAME, TYPE, SIZE, DECIMAL). NAME
        is a name of field, TYPE -- DBF type of field ('N' for number, 'C' for char,
        'D' for date, 'L' for logical), DECIMAL is a precision (useful for 'N' type only).
        For example:
        
            fields = [
                ('ID',      'N',  4, 0),
                ('VALUE',   'C', 40, 0),
                ('UPDATE',  'D', 8, 0),
                ('VISIBLE', 'L', 1, 0),
            ]
        
        YDbf uses unicode for 'C' fields by default, so you may want to define
        encoding which be used forthe  DBF file. UTF-8 is not supported,
        you may use only 8-bit encodings.
        
            dbf = ydbf.open('simple.dbf', 'w', fields, encoding='cp1251')
            dbf.write(data)
        
        YDbf gets `data` as an iterator where each item is a dict, which
        keys are names of fields. For example,
        
            data = [
                {'ID': 1, 'VALUE': 'ydbf', 'VISIBLE': True,
                 'UPDATE': datetime.date(2009, 7, 14)},
                {'ID': 2, 'VALUE': 'ydbf-dev', 'VISIBLE': False,
                 'UPDATE': datetime.date(2009, 5, 15)},
                {'ID': 3, 'VALUE': 'pytils', 'VISIBLE': True,
                 'UPDATE': datetime.date(2009, 5, 11)},
            ]
        
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Topic :: Database
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Description-Content-Type: text/markdown
