# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from typing import Iterable, Tuple


from typing import Union
import scenario.bindings.gazebo



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _core
else:
    import _core

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_SwigPyIterator

    def value(self):
        return _core.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _core.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _core.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _core.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _core.SwigPyIterator_equal(self, x)

    def copy(self):
        return _core.SwigPyIterator_copy(self)

    def next(self):
        return _core.SwigPyIterator_next(self)

    def __next__(self):
        return _core.SwigPyIterator___next__(self)

    def previous(self):
        return _core.SwigPyIterator_previous(self)

    def advance(self, n):
        return _core.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _core.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _core.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _core.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _core.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _core.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _core.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _core:
_core.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _core.SHARED_PTR_DISOWN
class VectorI(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorI_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorI___nonzero__(self)

    def __bool__(self):
        return _core.VectorI___bool__(self)

    def __len__(self):
        return _core.VectorI___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorI___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorI___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorI___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorI___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorI___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorI___setitem__(self, *args)

    def pop(self):
        return _core.VectorI_pop(self)

    def append(self, x):
        return _core.VectorI_append(self, x)

    def empty(self):
        return _core.VectorI_empty(self)

    def size(self):
        return _core.VectorI_size(self)

    def swap(self, v):
        return _core.VectorI_swap(self, v)

    def begin(self):
        return _core.VectorI_begin(self)

    def end(self):
        return _core.VectorI_end(self)

    def rbegin(self):
        return _core.VectorI_rbegin(self)

    def rend(self):
        return _core.VectorI_rend(self)

    def clear(self):
        return _core.VectorI_clear(self)

    def get_allocator(self):
        return _core.VectorI_get_allocator(self)

    def pop_back(self):
        return _core.VectorI_pop_back(self)

    def erase(self, *args):
        return _core.VectorI_erase(self, *args)

    def __init__(self, *args):
        _core.VectorI_swiginit(self, _core.new_VectorI(*args))

    def push_back(self, x):
        return _core.VectorI_push_back(self, x)

    def front(self):
        return _core.VectorI_front(self)

    def back(self):
        return _core.VectorI_back(self)

    def assign(self, n, x):
        return _core.VectorI_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorI_resize(self, *args)

    def insert(self, *args):
        return _core.VectorI_insert(self, *args)

    def reserve(self, n):
        return _core.VectorI_reserve(self, n)

    def capacity(self):
        return _core.VectorI_capacity(self)
    __swig_destroy__ = _core.delete_VectorI

# Register VectorI in _core:
_core.VectorI_swigregister(VectorI)

class VectorU(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorU_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorU___nonzero__(self)

    def __bool__(self):
        return _core.VectorU___bool__(self)

    def __len__(self):
        return _core.VectorU___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorU___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorU___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorU___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorU___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorU___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorU___setitem__(self, *args)

    def pop(self):
        return _core.VectorU_pop(self)

    def append(self, x):
        return _core.VectorU_append(self, x)

    def empty(self):
        return _core.VectorU_empty(self)

    def size(self):
        return _core.VectorU_size(self)

    def swap(self, v):
        return _core.VectorU_swap(self, v)

    def begin(self):
        return _core.VectorU_begin(self)

    def end(self):
        return _core.VectorU_end(self)

    def rbegin(self):
        return _core.VectorU_rbegin(self)

    def rend(self):
        return _core.VectorU_rend(self)

    def clear(self):
        return _core.VectorU_clear(self)

    def get_allocator(self):
        return _core.VectorU_get_allocator(self)

    def pop_back(self):
        return _core.VectorU_pop_back(self)

    def erase(self, *args):
        return _core.VectorU_erase(self, *args)

    def __init__(self, *args):
        _core.VectorU_swiginit(self, _core.new_VectorU(*args))

    def push_back(self, x):
        return _core.VectorU_push_back(self, x)

    def front(self):
        return _core.VectorU_front(self)

    def back(self):
        return _core.VectorU_back(self)

    def assign(self, n, x):
        return _core.VectorU_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorU_resize(self, *args)

    def insert(self, *args):
        return _core.VectorU_insert(self, *args)

    def reserve(self, n):
        return _core.VectorU_reserve(self, n)

    def capacity(self):
        return _core.VectorU_capacity(self)
    __swig_destroy__ = _core.delete_VectorU

# Register VectorU in _core:
_core.VectorU_swigregister(VectorU)

class VectorF(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorF_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorF___nonzero__(self)

    def __bool__(self):
        return _core.VectorF___bool__(self)

    def __len__(self):
        return _core.VectorF___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorF___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorF___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorF___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorF___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorF___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorF___setitem__(self, *args)

    def pop(self):
        return _core.VectorF_pop(self)

    def append(self, x):
        return _core.VectorF_append(self, x)

    def empty(self):
        return _core.VectorF_empty(self)

    def size(self):
        return _core.VectorF_size(self)

    def swap(self, v):
        return _core.VectorF_swap(self, v)

    def begin(self):
        return _core.VectorF_begin(self)

    def end(self):
        return _core.VectorF_end(self)

    def rbegin(self):
        return _core.VectorF_rbegin(self)

    def rend(self):
        return _core.VectorF_rend(self)

    def clear(self):
        return _core.VectorF_clear(self)

    def get_allocator(self):
        return _core.VectorF_get_allocator(self)

    def pop_back(self):
        return _core.VectorF_pop_back(self)

    def erase(self, *args):
        return _core.VectorF_erase(self, *args)

    def __init__(self, *args):
        _core.VectorF_swiginit(self, _core.new_VectorF(*args))

    def push_back(self, x):
        return _core.VectorF_push_back(self, x)

    def front(self):
        return _core.VectorF_front(self)

    def back(self):
        return _core.VectorF_back(self)

    def assign(self, n, x):
        return _core.VectorF_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorF_resize(self, *args)

    def insert(self, *args):
        return _core.VectorF_insert(self, *args)

    def reserve(self, n):
        return _core.VectorF_reserve(self, n)

    def capacity(self):
        return _core.VectorF_capacity(self)
    __swig_destroy__ = _core.delete_VectorF

# Register VectorF in _core:
_core.VectorF_swigregister(VectorF)

class VectorD(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorD_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorD___nonzero__(self)

    def __bool__(self):
        return _core.VectorD___bool__(self)

    def __len__(self):
        return _core.VectorD___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorD___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorD___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorD___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorD___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorD___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorD___setitem__(self, *args)

    def pop(self):
        return _core.VectorD_pop(self)

    def append(self, x):
        return _core.VectorD_append(self, x)

    def empty(self):
        return _core.VectorD_empty(self)

    def size(self):
        return _core.VectorD_size(self)

    def swap(self, v):
        return _core.VectorD_swap(self, v)

    def begin(self):
        return _core.VectorD_begin(self)

    def end(self):
        return _core.VectorD_end(self)

    def rbegin(self):
        return _core.VectorD_rbegin(self)

    def rend(self):
        return _core.VectorD_rend(self)

    def clear(self):
        return _core.VectorD_clear(self)

    def get_allocator(self):
        return _core.VectorD_get_allocator(self)

    def pop_back(self):
        return _core.VectorD_pop_back(self)

    def erase(self, *args):
        return _core.VectorD_erase(self, *args)

    def __init__(self, *args):
        _core.VectorD_swiginit(self, _core.new_VectorD(*args))

    def push_back(self, x):
        return _core.VectorD_push_back(self, x)

    def front(self):
        return _core.VectorD_front(self)

    def back(self):
        return _core.VectorD_back(self)

    def assign(self, n, x):
        return _core.VectorD_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorD_resize(self, *args)

    def insert(self, *args):
        return _core.VectorD_insert(self, *args)

    def reserve(self, n):
        return _core.VectorD_reserve(self, n)

    def capacity(self):
        return _core.VectorD_capacity(self)
    __swig_destroy__ = _core.delete_VectorD

# Register VectorD in _core:
_core.VectorD_swigregister(VectorD)

class VectorS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorS_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorS___nonzero__(self)

    def __bool__(self):
        return _core.VectorS___bool__(self)

    def __len__(self):
        return _core.VectorS___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorS___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorS___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorS___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorS___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorS___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorS___setitem__(self, *args)

    def pop(self):
        return _core.VectorS_pop(self)

    def append(self, x):
        return _core.VectorS_append(self, x)

    def empty(self):
        return _core.VectorS_empty(self)

    def size(self):
        return _core.VectorS_size(self)

    def swap(self, v):
        return _core.VectorS_swap(self, v)

    def begin(self):
        return _core.VectorS_begin(self)

    def end(self):
        return _core.VectorS_end(self)

    def rbegin(self):
        return _core.VectorS_rbegin(self)

    def rend(self):
        return _core.VectorS_rend(self)

    def clear(self):
        return _core.VectorS_clear(self)

    def get_allocator(self):
        return _core.VectorS_get_allocator(self)

    def pop_back(self):
        return _core.VectorS_pop_back(self)

    def erase(self, *args):
        return _core.VectorS_erase(self, *args)

    def __init__(self, *args):
        _core.VectorS_swiginit(self, _core.new_VectorS(*args))

    def push_back(self, x):
        return _core.VectorS_push_back(self, x)

    def front(self):
        return _core.VectorS_front(self)

    def back(self):
        return _core.VectorS_back(self)

    def assign(self, n, x):
        return _core.VectorS_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorS_resize(self, *args)

    def insert(self, *args):
        return _core.VectorS_insert(self, *args)

    def reserve(self, n):
        return _core.VectorS_reserve(self, n)

    def capacity(self):
        return _core.VectorS_capacity(self)
    __swig_destroy__ = _core.delete_VectorS

# Register VectorS in _core:
_core.VectorS_swigregister(VectorS)

class Array3d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.Array3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.Array3d___nonzero__(self)

    def __bool__(self):
        return _core.Array3d___bool__(self)

    def __len__(self):
        return _core.Array3d___len__(self)

    def __getslice__(self, i, j):
        return _core.Array3d___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.Array3d___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.Array3d___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.Array3d___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.Array3d___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.Array3d___setitem__(self, *args)

    def __init__(self, *args):
        _core.Array3d_swiginit(self, _core.new_Array3d(*args))

    def empty(self):
        return _core.Array3d_empty(self)

    def size(self):
        return _core.Array3d_size(self)

    def swap(self, v):
        return _core.Array3d_swap(self, v)

    def begin(self):
        return _core.Array3d_begin(self)

    def end(self):
        return _core.Array3d_end(self)

    def rbegin(self):
        return _core.Array3d_rbegin(self)

    def rend(self):
        return _core.Array3d_rend(self)

    def front(self):
        return _core.Array3d_front(self)

    def back(self):
        return _core.Array3d_back(self)

    def fill(self, u):
        return _core.Array3d_fill(self, u)
    __swig_destroy__ = _core.delete_Array3d

# Register Array3d in _core:
_core.Array3d_swigregister(Array3d)

class Array4d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.Array4d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.Array4d___nonzero__(self)

    def __bool__(self):
        return _core.Array4d___bool__(self)

    def __len__(self):
        return _core.Array4d___len__(self)

    def __getslice__(self, i, j):
        return _core.Array4d___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.Array4d___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.Array4d___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.Array4d___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.Array4d___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.Array4d___setitem__(self, *args)

    def __init__(self, *args):
        _core.Array4d_swiginit(self, _core.new_Array4d(*args))

    def empty(self):
        return _core.Array4d_empty(self)

    def size(self):
        return _core.Array4d_size(self)

    def swap(self, v):
        return _core.Array4d_swap(self, v)

    def begin(self):
        return _core.Array4d_begin(self)

    def end(self):
        return _core.Array4d_end(self)

    def rbegin(self):
        return _core.Array4d_rbegin(self)

    def rend(self):
        return _core.Array4d_rend(self)

    def front(self):
        return _core.Array4d_front(self)

    def back(self):
        return _core.Array4d_back(self)

    def fill(self, u):
        return _core.Array4d_fill(self, u)
    __swig_destroy__ = _core.delete_Array4d

# Register Array4d in _core:
_core.Array4d_swigregister(Array4d)

class Array6d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.Array6d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.Array6d___nonzero__(self)

    def __bool__(self):
        return _core.Array6d___bool__(self)

    def __len__(self):
        return _core.Array6d___len__(self)

    def __getslice__(self, i, j):
        return _core.Array6d___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.Array6d___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.Array6d___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.Array6d___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.Array6d___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.Array6d___setitem__(self, *args)

    def __init__(self, *args):
        _core.Array6d_swiginit(self, _core.new_Array6d(*args))

    def empty(self):
        return _core.Array6d_empty(self)

    def size(self):
        return _core.Array6d_size(self)

    def swap(self, v):
        return _core.Array6d_swap(self, v)

    def begin(self):
        return _core.Array6d_begin(self)

    def end(self):
        return _core.Array6d_end(self)

    def rbegin(self):
        return _core.Array6d_rbegin(self)

    def rend(self):
        return _core.Array6d_rend(self)

    def front(self):
        return _core.Array6d_front(self)

    def back(self):
        return _core.Array6d_back(self)

    def fill(self, u):
        return _core.Array6d_fill(self, u)
    __swig_destroy__ = _core.delete_Array6d

# Register Array6d in _core:
_core.Array6d_swigregister(Array6d)

class PosePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _core.PosePair_swiginit(self, _core.new_PosePair(*args))
    first = property(_core.PosePair_first_get, _core.PosePair_first_set)
    second = property(_core.PosePair_second_get, _core.PosePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _core.delete_PosePair

# Register PosePair in _core:
_core.PosePair_swigregister(PosePair)

class VectorOfLinks(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorOfLinks_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorOfLinks___nonzero__(self)

    def __bool__(self):
        return _core.VectorOfLinks___bool__(self)

    def __len__(self):
        return _core.VectorOfLinks___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorOfLinks___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorOfLinks___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorOfLinks___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorOfLinks___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorOfLinks___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorOfLinks___setitem__(self, *args)

    def pop(self):
        return _core.VectorOfLinks_pop(self)

    def append(self, x):
        return _core.VectorOfLinks_append(self, x)

    def empty(self):
        return _core.VectorOfLinks_empty(self)

    def size(self):
        return _core.VectorOfLinks_size(self)

    def swap(self, v):
        return _core.VectorOfLinks_swap(self, v)

    def begin(self):
        return _core.VectorOfLinks_begin(self)

    def end(self):
        return _core.VectorOfLinks_end(self)

    def rbegin(self):
        return _core.VectorOfLinks_rbegin(self)

    def rend(self):
        return _core.VectorOfLinks_rend(self)

    def clear(self):
        return _core.VectorOfLinks_clear(self)

    def get_allocator(self):
        return _core.VectorOfLinks_get_allocator(self)

    def pop_back(self):
        return _core.VectorOfLinks_pop_back(self)

    def erase(self, *args):
        return _core.VectorOfLinks_erase(self, *args)

    def __init__(self, *args):
        _core.VectorOfLinks_swiginit(self, _core.new_VectorOfLinks(*args))

    def push_back(self, x):
        return _core.VectorOfLinks_push_back(self, x)

    def front(self):
        return _core.VectorOfLinks_front(self)

    def back(self):
        return _core.VectorOfLinks_back(self)

    def assign(self, n, x):
        return _core.VectorOfLinks_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorOfLinks_resize(self, *args)

    def insert(self, *args):
        return _core.VectorOfLinks_insert(self, *args)

    def reserve(self, n):
        return _core.VectorOfLinks_reserve(self, n)

    def capacity(self):
        return _core.VectorOfLinks_capacity(self)
    __swig_destroy__ = _core.delete_VectorOfLinks

# Register VectorOfLinks in _core:
_core.VectorOfLinks_swigregister(VectorOfLinks)

class VectorOfJoints(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorOfJoints_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorOfJoints___nonzero__(self)

    def __bool__(self):
        return _core.VectorOfJoints___bool__(self)

    def __len__(self):
        return _core.VectorOfJoints___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorOfJoints___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorOfJoints___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorOfJoints___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorOfJoints___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorOfJoints___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorOfJoints___setitem__(self, *args)

    def pop(self):
        return _core.VectorOfJoints_pop(self)

    def append(self, x):
        return _core.VectorOfJoints_append(self, x)

    def empty(self):
        return _core.VectorOfJoints_empty(self)

    def size(self):
        return _core.VectorOfJoints_size(self)

    def swap(self, v):
        return _core.VectorOfJoints_swap(self, v)

    def begin(self):
        return _core.VectorOfJoints_begin(self)

    def end(self):
        return _core.VectorOfJoints_end(self)

    def rbegin(self):
        return _core.VectorOfJoints_rbegin(self)

    def rend(self):
        return _core.VectorOfJoints_rend(self)

    def clear(self):
        return _core.VectorOfJoints_clear(self)

    def get_allocator(self):
        return _core.VectorOfJoints_get_allocator(self)

    def pop_back(self):
        return _core.VectorOfJoints_pop_back(self)

    def erase(self, *args):
        return _core.VectorOfJoints_erase(self, *args)

    def __init__(self, *args):
        _core.VectorOfJoints_swiginit(self, _core.new_VectorOfJoints(*args))

    def push_back(self, x):
        return _core.VectorOfJoints_push_back(self, x)

    def front(self):
        return _core.VectorOfJoints_front(self)

    def back(self):
        return _core.VectorOfJoints_back(self)

    def assign(self, n, x):
        return _core.VectorOfJoints_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorOfJoints_resize(self, *args)

    def insert(self, *args):
        return _core.VectorOfJoints_insert(self, *args)

    def reserve(self, n):
        return _core.VectorOfJoints_reserve(self, n)

    def capacity(self):
        return _core.VectorOfJoints_capacity(self)
    __swig_destroy__ = _core.delete_VectorOfJoints

# Register VectorOfJoints in _core:
_core.VectorOfJoints_swigregister(VectorOfJoints)

class VectorOfContacts(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorOfContacts_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorOfContacts___nonzero__(self)

    def __bool__(self):
        return _core.VectorOfContacts___bool__(self)

    def __len__(self):
        return _core.VectorOfContacts___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorOfContacts___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorOfContacts___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorOfContacts___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorOfContacts___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorOfContacts___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorOfContacts___setitem__(self, *args)

    def pop(self):
        return _core.VectorOfContacts_pop(self)

    def append(self, x):
        return _core.VectorOfContacts_append(self, x)

    def empty(self):
        return _core.VectorOfContacts_empty(self)

    def size(self):
        return _core.VectorOfContacts_size(self)

    def swap(self, v):
        return _core.VectorOfContacts_swap(self, v)

    def begin(self):
        return _core.VectorOfContacts_begin(self)

    def end(self):
        return _core.VectorOfContacts_end(self)

    def rbegin(self):
        return _core.VectorOfContacts_rbegin(self)

    def rend(self):
        return _core.VectorOfContacts_rend(self)

    def clear(self):
        return _core.VectorOfContacts_clear(self)

    def get_allocator(self):
        return _core.VectorOfContacts_get_allocator(self)

    def pop_back(self):
        return _core.VectorOfContacts_pop_back(self)

    def erase(self, *args):
        return _core.VectorOfContacts_erase(self, *args)

    def __init__(self, *args):
        _core.VectorOfContacts_swiginit(self, _core.new_VectorOfContacts(*args))

    def push_back(self, x):
        return _core.VectorOfContacts_push_back(self, x)

    def front(self):
        return _core.VectorOfContacts_front(self)

    def back(self):
        return _core.VectorOfContacts_back(self)

    def assign(self, n, x):
        return _core.VectorOfContacts_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorOfContacts_resize(self, *args)

    def insert(self, *args):
        return _core.VectorOfContacts_insert(self, *args)

    def reserve(self, n):
        return _core.VectorOfContacts_reserve(self, n)

    def capacity(self):
        return _core.VectorOfContacts_capacity(self)
    __swig_destroy__ = _core.delete_VectorOfContacts

# Register VectorOfContacts in _core:
_core.VectorOfContacts_swigregister(VectorOfContacts)

class VectorOfContactPoints(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _core.VectorOfContactPoints_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _core.VectorOfContactPoints___nonzero__(self)

    def __bool__(self):
        return _core.VectorOfContactPoints___bool__(self)

    def __len__(self):
        return _core.VectorOfContactPoints___len__(self)

    def __getslice__(self, i, j):
        return _core.VectorOfContactPoints___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _core.VectorOfContactPoints___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _core.VectorOfContactPoints___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _core.VectorOfContactPoints___delitem__(self, *args)

    def __getitem__(self, *args):
        return _core.VectorOfContactPoints___getitem__(self, *args)

    def __setitem__(self, *args):
        return _core.VectorOfContactPoints___setitem__(self, *args)

    def pop(self):
        return _core.VectorOfContactPoints_pop(self)

    def append(self, x):
        return _core.VectorOfContactPoints_append(self, x)

    def empty(self):
        return _core.VectorOfContactPoints_empty(self)

    def size(self):
        return _core.VectorOfContactPoints_size(self)

    def swap(self, v):
        return _core.VectorOfContactPoints_swap(self, v)

    def begin(self):
        return _core.VectorOfContactPoints_begin(self)

    def end(self):
        return _core.VectorOfContactPoints_end(self)

    def rbegin(self):
        return _core.VectorOfContactPoints_rbegin(self)

    def rend(self):
        return _core.VectorOfContactPoints_rend(self)

    def clear(self):
        return _core.VectorOfContactPoints_clear(self)

    def get_allocator(self):
        return _core.VectorOfContactPoints_get_allocator(self)

    def pop_back(self):
        return _core.VectorOfContactPoints_pop_back(self)

    def erase(self, *args):
        return _core.VectorOfContactPoints_erase(self, *args)

    def __init__(self, *args):
        _core.VectorOfContactPoints_swiginit(self, _core.new_VectorOfContactPoints(*args))

    def push_back(self, x):
        return _core.VectorOfContactPoints_push_back(self, x)

    def front(self):
        return _core.VectorOfContactPoints_front(self)

    def back(self):
        return _core.VectorOfContactPoints_back(self)

    def assign(self, n, x):
        return _core.VectorOfContactPoints_assign(self, n, x)

    def resize(self, *args):
        return _core.VectorOfContactPoints_resize(self, *args)

    def insert(self, *args):
        return _core.VectorOfContactPoints_insert(self, *args)

    def reserve(self, n):
        return _core.VectorOfContactPoints_reserve(self, n)

    def capacity(self):
        return _core.VectorOfContactPoints_capacity(self)
    __swig_destroy__ = _core.delete_VectorOfContactPoints

# Register VectorOfContactPoints in _core:
_core.VectorOfContactPoints_swigregister(VectorOfContactPoints)


def get_install_prefix():
    r"""
    Get the install prefix used by the CMake project.

    Notes: It is defined only if the project is installed in
    Developer mode.

    :rtype: string
    :return: A string with the install prefix if the project is
        installed in Developer mode, an empty string otherwise.
    """
    return _core.get_install_prefix()
JointType_invalid = _core.JointType_invalid
JointType_fixed = _core.JointType_fixed
JointType_revolute = _core.JointType_revolute
JointType_prismatic = _core.JointType_prismatic
JointType_ball = _core.JointType_ball
JointControlMode_invalid = _core.JointControlMode_invalid
r""" Marks the joint to have an invalid control mode."""
JointControlMode_idle = _core.JointControlMode_idle
r""" Marks the joint to be IDLE. An IDLE joint is equivalent to a joint controlled in Force with zero references. The joint shows only passive behaviour."""
JointControlMode_force = _core.JointControlMode_force
r""" Marks the joint to be controlled in force. A Force joint receives generalized force references that are actuated by a force actuator. Depending on the active backend, the presence of friction and other loss components could be compensated."""
JointControlMode_velocity = _core.JointControlMode_velocity
r""" Marks the joint to be controlled in velocity. A Velocity joint receives velocity references that are actuated using a PID controller."""
JointControlMode_velocity_follower_dart = _core.JointControlMode_velocity_follower_dart
r""" Marks the joint to follow precisely a velocity trajectory. A VelocityFollowerDart joint receives velocity references that are processed by the physics engine, which computes instantaneously the right force to apply to follow the desired trajectory. It works only with the DART physics engine."""
JointControlMode_position = _core.JointControlMode_position
r""" Marks the joint to be controlled in position. A Position joint receives position references that are actuated using a PID controller."""
JointControlMode_position_interpolated = _core.JointControlMode_position_interpolated
r""" Marks the joint to be controlled in position with trajectory smoothing. A PositionInterpolated joint receives position references that are filtered to get a smooth trajectory. The resulting trajectory is then actuated using a position PID controller."""
class Joint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Joint

    def valid(self):
        r"""
        Check if the joint is valid.

        :rtype: boolean
        :return: True if the joint is valid, false otherwise.
        """
        return _core.Joint_valid(self)

    def dofs(self):
        r"""
        Get the number of degrees of freedom of the joint.

        :rtype: int
        :return: The number of DOFs of the joint.
        """
        return _core.Joint_dofs(self)

    def name(self, scoped=False):
        r"""
        Get the name of the joint.

        :type scoped: boolean
        :param scoped: If true, the scoped name of the joint is returned.
        :rtype: string
        :return: The name of the joint.
        """
        return _core.Joint_name(self, scoped)

    def type(self):
        r"""
        Get the type of the joint.

        :rtype: int
        :return: The type of the joint.
        """
        return _core.Joint_type(self)

    def control_mode(self):
        r"""
        Get the active joint control mode.

        :rtype: int
        :return: The active joint control mode.
        """
        return _core.Joint_control_mode(self)

    def set_control_mode(self, mode):
        r"""
        Set the joint control mode.

        :type mode: int
        :param mode: The desired control mode.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_control_mode(self, mode)

    def controller_period(self):
        r"""
        Get the period of the controller, if any.

        The controller period is a model quantity. If no controller
        is active, infinity is returned.

        :rtype: float
        :return: The the controller period.
        """
        return _core.Joint_controller_period(self)

    def pid(self):
        r"""
        Get the PID parameters of the joint.

        If no PID parameters have been set, the default parameters are
        returned.

        :rtype: :py:class:`PID`
        :return: The joint PID parameters.
        """
        return _core.Joint_pid(self)

    def set_pid(self, pid):
        r"""
        Set the PID parameters of the joint.

        :type pid: :py:class:`PID`
        :param pid: The desired PID parameters.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_pid(self, pid)

    def history_of_applied_joint_forces_enabled(self):
        r"""
        Check if the history of applied joint forces is enabled.

        :rtype: boolean
        :return: True if the history is enabled, false otherwise.
        """
        return _core.Joint_history_of_applied_joint_forces_enabled(self)

    def enable_history_of_applied_joint_forces(self, enable=True, max_history_size=100):
        r"""
        Enable the history of joint forces.

        :type enable: boolean
        :param enable: True to enable, false to disable.
        :type maxHistorySize: int
        :param maxHistorySize: The size of the history window.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_enable_history_of_applied_joint_forces(self, enable, max_history_size)

    def history_of_applied_joint_forces(self):
        r"""
        Get the history of applied joint forces.

        The vector is populated with #DoFs values at each physics step.

        :rtype: Iterable[float]
        :return: The vector containing the history of joint forces.
        """
        return _core.Joint_history_of_applied_joint_forces(self)

    def coulomb_friction(self):
        r"""
        Get the Coulomb friction of the joint.

        If :math:`K_c` is the Coulomb friction parameter, and :math:`\dot{q}`
        the joint velocity, the corresponding torque is often modelled as:

        :math:`\tau_{static} = sign(\dot{q}) K_c`

        :rtype: float
        :return: The Coulomb friction parameter of the joint.
        """
        return _core.Joint_coulomb_friction(self)

    def viscous_friction(self):
        r"""
        Get the viscous friction of the joint.

        If :math:`K_v` is the viscous friction parameter, and :math:`\dot{q}`
        the joint velocity, the corresponding torque is often modelled as:

        :math:`\tau_{static} = K_v \dot{q}`

        :rtype: float
        :return: The viscous friction parameter of the joint.
        """
        return _core.Joint_viscous_friction(self)

    def position_limit(self, dof=0):
        r"""
        Get the position limits of a joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: :py:class:`Limit`
        :return: The position limits of the joint DOF.
        """
        return _core.Joint_position_limit(self, dof)

    def max_generalized_force(self, dof=0):
        r"""
        Get the maximum generalized force that could be applied to a joint
        DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: float
        :return: The maximum generalized force of the joint DOF.
        """
        return _core.Joint_max_generalized_force(self, dof)

    def set_max_generalized_force(self, max_force, dof=0):
        r"""
        Set the maximum generalized force that can be applied to a joint DOF.

        This limit can be used to clip the force applied by joint
        controllers.

        :type maxForce: float
        :param maxForce: The maximum generalized force.
        :type dof: int
        :param dof: The index of the DOF.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_max_generalized_force(self, max_force, dof)

    def position(self, dof=0):
        r"""
        Get the position of a joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: float
        :return: The position of the joint DOF.
        """
        return _core.Joint_position(self, dof)

    def velocity(self, dof=0):
        r"""
        Get the velocity of a joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: float
        :return: The velocity of the joint DOF.
        """
        return _core.Joint_velocity(self, dof)

    def acceleration(self, dof=0):
        r"""
        Get the acceleration of a joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: float
        :return: The acceleration of the joint DOF.
        """
        return _core.Joint_acceleration(self, dof)

    def generalized_force(self, dof=0):
        r"""
        Get the generalized force of a joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: float
        :return: The generalized force of the joint DOF.
        """
        return _core.Joint_generalized_force(self, dof)

    def set_position_target(self, position, dof=0):
        r"""
        Set the position target of a joint DOF.

        The target is processed by a joint controller, if enabled.

        :type position: float
        :param position: The position target of the joint DOF.
        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_position_target(self, position, dof)

    def set_velocity_target(self, velocity, dof=0):
        r"""
        Set the velocity target of a joint DOF.

        The target is processed by a joint controller, if enabled.

        :type velocity: float
        :param velocity: The velocity target of the joint DOF.
        :type dof: int
        :param dof: The index of the DOF.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_velocity_target(self, velocity, dof)

    def set_acceleration_target(self, acceleration, dof=0):
        r"""
        Set the acceleration target of a joint DOF.

        The target is processed by a joint controller, if enabled.

        :type acceleration: float
        :param acceleration: The acceleration target of the joint DOF.
        :type dof: int
        :param dof: The index of the DOF.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_acceleration_target(self, acceleration, dof)

    def set_generalized_force_target(self, force, dof=0):
        r"""
        Set the generalized force target of a joint DOF.

        The force is applied to the desired DOF. Note that if there's
        friction or other loss components, the real joint force will differ.

        :type force: float
        :param force: The generalized force target of the joint DOF.
        :type dof: int
        :param dof: The index of the DOF.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_generalized_force_target(self, force, dof)

    def position_target(self, dof=0):
        r"""
        Get the active position target of the joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid or if no position
            target was set.
        :rtype: float
        :return: The position target of the joint DOF.
        """
        return _core.Joint_position_target(self, dof)

    def velocity_target(self, dof=0):
        r"""
        Get the active velocity target of the joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid or if no velocity
            target was set.
        :rtype: float
        :return: The velocity target of the joint DOF.
        """
        return _core.Joint_velocity_target(self, dof)

    def acceleration_target(self, dof=0):
        r"""
        Get the active acceleration target of the joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid or if no
            acceleration target was set.
        :rtype: float
        :return: The acceleration target of the joint DOF.
        """
        return _core.Joint_acceleration_target(self, dof)

    def generalized_force_target(self, dof=0):
        r"""
        Get the active generalized force target of the joint DOF.

        :type dof: int
        :param dof: The index of the DOF.
        :raises: std::runtime_error if the DOF is not valid or if no
            generalized force target was set.
        :rtype: float
        :return: The generalized force target of the joint DOF.
        """
        return _core.Joint_generalized_force_target(self, dof)

    def joint_position_limit(self):
        r"""
        Get the position limits of the joint.

        :rtype: :py:class:`JointLimit`
        :return: The position limits of the joint.
        """
        return _core.Joint_joint_position_limit(self)

    def joint_max_generalized_force(self):
        r"""
        Get the maximum generalized force that could be applied to the joint.

        :rtype: Iterable[float]
        :return: The maximum generalized force of the joint.
        """
        return _core.Joint_joint_max_generalized_force(self)

    def set_joint_max_generalized_force(self, max_force):
        r"""
        Set the maximum generalized force that can be applied to the joint.

        This limit can be used to clip the force applied by joint
        controllers.

        :type maxForce: Iterable[float]
        :param maxForce: A vector with the maximum generalized forces of the
            joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_joint_max_generalized_force(self, max_force)

    def joint_position(self):
        r"""
        Get the position of the joint.

        :rtype: Iterable[float]
        :return: The position of the joint.
        """
        return _core.Joint_joint_position(self)

    def joint_velocity(self):
        r"""
        Get the velocity of the joint.

        :rtype: Iterable[float]
        :return: The velocity of the joint.
        """
        return _core.Joint_joint_velocity(self)

    def joint_acceleration(self):
        r"""
        Get the acceleration of the joint.

        :rtype: Iterable[float]
        :return: The acceleration of the joint.
        """
        return _core.Joint_joint_acceleration(self)

    def joint_generalized_force(self):
        r"""
        Get the generalized force of the joint.

        :rtype: Iterable[float]
        :return: The generalized force of the joint.
        """
        return _core.Joint_joint_generalized_force(self)

    def set_joint_position_target(self, position):
        r"""
        Set the position target of the joint.

        The target is processed by a joint controller, if enabled.

        :type position: Iterable[float]
        :param position: A vector with the position targets of the joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_joint_position_target(self, position)

    def set_joint_velocity_target(self, velocity):
        r"""
        Set the velocity target of the joint.

        The target is processed by a joint controller, if enabled.

        :type velocity: Iterable[float]
        :param velocity: A vector with the velocity targets of the joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_joint_velocity_target(self, velocity)

    def set_joint_acceleration_target(self, acceleration):
        r"""
        Set the acceleration target of the joint.

        The target is processed by a joint controller, if enabled.

        :type acceleration: Iterable[float]
        :param acceleration: A vector with the acceleration targets of the
            joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_joint_acceleration_target(self, acceleration)

    def set_joint_generalized_force_target(self, force):
        r"""
        Set the generalized force target of the joint.

        Note that if there's friction or other loss components, the real
        joint force will differ.

        :type force: Iterable[float]
        :param force: A vector with the generalized force targets of the joint
            DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Joint_set_joint_generalized_force_target(self, force)

    def joint_position_target(self):
        r"""
        Get the active position target.

        :rtype: Iterable[float]
        :return: The position target of the joint.
        """
        return _core.Joint_joint_position_target(self)

    def joint_velocity_target(self):
        r"""
        Get the active velocity target.

        :rtype: Iterable[float]
        :return: The velocity target of the joint.
        """
        return _core.Joint_joint_velocity_target(self)

    def joint_acceleration_target(self):
        r"""
        Get the active acceleration target.

        :rtype: Iterable[float]
        :return: The acceleration target of the joint.
        """
        return _core.Joint_joint_acceleration_target(self)

    def joint_generalized_force_target(self):
        r"""
        Get the active generalized force target.

        :rtype: Iterable[float]
        :return: The generalized force target of the joint.
        """
        return _core.Joint_joint_generalized_force_target(self)

    def to_gazebo(self) -> Union["scenario.bindings.gazebo.Joint", "scenario.bindings.core.Joint"]:
        return scenario.bindings.gazebo.ToGazeboJoint(self)


# Register Joint in _core:
_core.Joint_swigregister(Joint)

class PID(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _core.PID_swiginit(self, _core.new_PID(*args))
    p = property(_core.PID_p_get, _core.PID_p_set)
    i = property(_core.PID_i_get, _core.PID_i_set)
    d = property(_core.PID_d_get, _core.PID_d_set)
    cmd_min = property(_core.PID_cmd_min_get, _core.PID_cmd_min_set)
    cmd_max = property(_core.PID_cmd_max_get, _core.PID_cmd_max_set)
    cmd_offset = property(_core.PID_cmd_offset_get, _core.PID_cmd_offset_set)
    i_min = property(_core.PID_i_min_get, _core.PID_i_min_set)
    i_max = property(_core.PID_i_max_get, _core.PID_i_max_set)
    __swig_destroy__ = _core.delete_PID

# Register PID in _core:
_core.PID_swigregister(PID)

class Limit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _core.Limit_swiginit(self, _core.new_Limit(*args))
    min = property(_core.Limit_min_get, _core.Limit_min_set)
    max = property(_core.Limit_max_get, _core.Limit_max_set)
    __swig_destroy__ = _core.delete_Limit

# Register Limit in _core:
_core.Limit_swigregister(Limit)

class JointLimit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _core.JointLimit_swiginit(self, _core.new_JointLimit(*args))
    min = property(_core.JointLimit_min_get, _core.JointLimit_min_set)
    max = property(_core.JointLimit_max_get, _core.JointLimit_max_set)
    __swig_destroy__ = _core.delete_JointLimit

# Register JointLimit in _core:
_core.JointLimit_swigregister(JointLimit)

class Link(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Link

    def valid(self):
        r"""
        Check if the link is valid.

        :rtype: boolean
        :return: True if the link is valid, false otherwise.
        """
        return _core.Link_valid(self)

    def name(self, scoped=False):
        r"""
        Get the name of the link.

        :type scoped: boolean
        :param scoped: If true, the scoped name of the link is returned.
        :rtype: string
        :return: The name of the link.
        """
        return _core.Link_name(self, scoped)

    def mass(self):
        r"""
        Get the mass of the link.

        :rtype: float
        :return: The mass of the link.
        """
        return _core.Link_mass(self)

    def position(self):
        r"""
        Get the position of the link.

        The returned position is the position of the link frame, as it was
        defined in the model file, in world coordinates.

        :rtype: Iterable[float, float, float]
        :return: The cartesian position of the link frame in world coordinates.
        """
        return _core.Link_position(self)

    def orientation(self):
        r"""
        Get the orientation of the link.

        The orientation is returned as a quaternion, which defines the
        rotation between the world frame and the link frame.

        :rtype: Iterable[float, float, float, float]
        :return: The wxyz quaternion defining the orientation if the link wrt the
            world frame.
        """
        return _core.Link_orientation(self)

    def world_linear_velocity(self):
        r"""
        Get the linear mixed velocity of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear mixed velocity of the link.
        """
        return _core.Link_world_linear_velocity(self)

    def world_angular_velocity(self):
        r"""
        Get the angular mixed velocity of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular mixed velocity of the link.
        """
        return _core.Link_world_angular_velocity(self)

    def body_linear_velocity(self):
        r"""
        Get the linear body velocity of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear body velocity of the link.
        """
        return _core.Link_body_linear_velocity(self)

    def body_angular_velocity(self):
        r"""
        Get the angular body velocity of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular body velocity of the link.
        """
        return _core.Link_body_angular_velocity(self)

    def world_linear_acceleration(self):
        r"""
        Get the linear mixed acceleration of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear mixed acceleration of the link.
        """
        return _core.Link_world_linear_acceleration(self)

    def world_angular_acceleration(self):
        r"""
        Get the angular mixed acceleration of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular mixed acceleration of the link.
        """
        return _core.Link_world_angular_acceleration(self)

    def body_linear_acceleration(self):
        r"""
        Get the linear body acceleration of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear body acceleration of the link.
        """
        return _core.Link_body_linear_acceleration(self)

    def body_angular_acceleration(self):
        r"""
        Get the angular body acceleration of the link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular body acceleration of the link.
        """
        return _core.Link_body_angular_acceleration(self)

    def contacts_enabled(self):
        r"""
        Check if the contact detection is enabled.

        :rtype: boolean
        :return: True if the contact detection is enabled, false otherwise.
        """
        return _core.Link_contacts_enabled(self)

    def enable_contact_detection(self, enable):
        r"""
        Enable the contact detection.

        :type enable: boolean
        :param enable: True to enable the contact detection, false to disable.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Link_enable_contact_detection(self, enable)

    def in_contact(self):
        r"""
        Check if the link has active contacts.

        :rtype: boolean
        :return: True if the link has at least one contact, false otherwise.
        """
        return _core.Link_in_contact(self)

    def contacts(self):
        r"""
        Get the active contacts of the link.

        :rtype: Tuple[Contact]
        :return: The vector of active contacts.
        """
        return _core.Link_contacts(self)

    def contact_wrench(self):
        r"""
        Get the total wrench generated by the active contacts.

        All the contact wrenches are composed to an equivalent wrench
        applied to the origin of the link frame and expressed in world
        coordinates.

        :rtype: Iterable[float, float, float, float, float, float]
        :return: The total wrench of the active contacts.
        """
        return _core.Link_contact_wrench(self)

    def to_gazebo(self) -> Union["scenario.bindings.gazebo.Link", "scenario.bindings.core.Link"]:
        return scenario.bindings.gazebo.ToGazeboLink(self)


# Register Link in _core:
_core.Link_swigregister(Link)

class Pose(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _core.Pose_swiginit(self, _core.new_Pose(*args))

    @staticmethod
    def identity():
        return _core.Pose_identity()

    def __eq__(self, other):
        return _core.Pose___eq__(self, other)

    def __ne__(self, other):
        return _core.Pose___ne__(self, other)
    position = property(_core.Pose_position_get, _core.Pose_position_set)
    orientation = property(_core.Pose_orientation_get, _core.Pose_orientation_set)
    __swig_destroy__ = _core.delete_Pose

# Register Pose in _core:
_core.Pose_swigregister(Pose)

def Pose_identity():
    return _core.Pose_identity()

class ContactPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    depth = property(_core.ContactPoint_depth_get, _core.ContactPoint_depth_set)
    force = property(_core.ContactPoint_force_get, _core.ContactPoint_force_set)
    torque = property(_core.ContactPoint_torque_get, _core.ContactPoint_torque_set)
    normal = property(_core.ContactPoint_normal_get, _core.ContactPoint_normal_set)
    position = property(_core.ContactPoint_position_get, _core.ContactPoint_position_set)

    def __init__(self):
        _core.ContactPoint_swiginit(self, _core.new_ContactPoint())
    __swig_destroy__ = _core.delete_ContactPoint

# Register ContactPoint in _core:
_core.ContactPoint_swigregister(ContactPoint)

class Contact(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    body_a = property(_core.Contact_body_a_get, _core.Contact_body_a_set)
    body_b = property(_core.Contact_body_b_get, _core.Contact_body_b_set)
    points = property(_core.Contact_points_get, _core.Contact_points_set)

    def __init__(self):
        _core.Contact_swiginit(self, _core.new_Contact())
    __swig_destroy__ = _core.delete_Contact

# Register Contact in _core:
_core.Contact_swigregister(Contact)

class Model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_Model

    def valid(self):
        r"""
        Check if the model is valid.

        :rtype: boolean
        :return: True if the model is valid, false otherwise.
        """
        return _core.Model_valid(self)

    def dofs(self, *args):
        r"""
        Get the degrees of freedom of the model.

        :type jointNames: Iterable[string]
        :param jointNames: Optionally restrict the count to a subset of
            joints.
        :rtype: int
        :return: The number of degrees of freedom of the model.
        """
        return _core.Model_dofs(self, *args)

    def name(self):
        r"""
        Get the name of the model.

        :rtype: string
        :return: The name of the model.
        """
        return _core.Model_name(self)

    def nr_of_links(self):
        r"""
        Get the number of links of the model.

        :rtype: int
        :return: The number of links.
        """
        return _core.Model_nr_of_links(self)

    def nr_of_joints(self):
        r"""
        Get the number of joints of the model.

        :rtype: int
        :return: The number of joints.
        """
        return _core.Model_nr_of_joints(self)

    def total_mass(self, *args):
        r"""
        Get the total mass of the model.

        :type linkNames: Iterable[string]
        :param linkNames: Optionally restrict the count to a subset of links.
        :rtype: float
        :return: The total mass of the model.
        """
        return _core.Model_total_mass(self, *args)

    def get_link(self, link_name):
        r"""
        Get a link belonging to the model.

        :type linkName: string
        :param linkName: The name of the link.
        :raises: std::runtime_error if the link does not exist.
        :rtype: :py:class:`Link`
        :return: The desired link.
        """
        return _core.Model_get_link(self, link_name)

    def get_joint(self, joint_name):
        r"""
        Get a joint belonging to the model.

        :type jointName: string
        :param jointName: The name of the joint.
        :raises: std::runtime_error if the joint does not exist.
        :rtype: :py:class:`Joint`
        :return: The desired joint.
        """
        return _core.Model_get_joint(self, joint_name)

    def link_names(self, scoped=False):
        r"""
        Get the name of all the model's links.

        :type scoped: boolean
        :param scoped: Scope the link names with the model name
            (e.g. ``mymodel::link1``).
        :rtype: Iterable[string]
        :return: The list of link names.
        """
        return _core.Model_link_names(self, scoped)

    def joint_names(self, scoped=False):
        r"""
        Get the name of all the model's joints.

        :type scoped: boolean
        :param scoped: Scope the joint names with the model name,
            (e.g. ``mymodel::joint1``).
        :rtype: Iterable[string]
        :return: The list of joint names.
        """
        return _core.Model_joint_names(self, scoped)

    def controller_period(self):
        r"""
        Get the controller period of the model.

        If no controller has been enabled, infinite is returned.

        :rtype: float
        :return: The controller period of the model.
        """
        return _core.Model_controller_period(self)

    def set_controller_period(self, period):
        r"""
        Set the controller period of the model.

        This controller period is used by PIDs and custom controller.
        If it is smaller than the physics step, it is treated as 0.

        :type period: float
        :param period: The desired controller period.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_controller_period(self, period)

    def enable_history_of_applied_joint_forces(self, *args):
        r"""
        Enable logging the applied joint forces.

        The output of joint controllers is often a torque. This method allows to
        log the force references that the controller sent to the joints. It is
        useful when the controller runs in its own thread at its own rate and the
        caller wants to extract the forces at a lower frequency.

        :type enable: boolean
        :param enable: True to enable logging, false to disable.
        :type maxHistorySizePerJoint: int
        :param maxHistorySizePerJoint: Size of the logging window of each joint.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_enable_history_of_applied_joint_forces(self, *args)

    def history_of_applied_joint_forces_enabled(self, joint_names):
        r"""
        Check if logging the applied joint force is enabled.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: boolean
        :return: True if the log is enabled, false otherwise.
        """
        return _core.Model_history_of_applied_joint_forces_enabled(self, joint_names)

    def history_of_applied_joint_forces(self, *args):
        r"""
        Get the log of applied joint forces.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Iterable[float]
        :return: The entire window of applied joint forces.

        Notes: Given a serialization, the window has ``DoFs * JointWindowSize``
        elements. The elements are ordered per time steps, i.e. the first
        ``#DoFs`` elements refer to the oldest forces of the windows ordered with
        the active joint serialization.

        If a joint has multiple DoFs, they are serialized contiguously.
        """
        return _core.Model_history_of_applied_joint_forces(self, *args)

    def contacts_enabled(self):
        r"""
        Check if the contact detection is enabled model-wise.

        :rtype: boolean
        :return: True if the contact detection is enabled model-wise, false
            otherwise.
        """
        return _core.Model_contacts_enabled(self)

    def enable_contacts(self, enable=True):
        r"""
        Enable the contact detection model-wise.

        :type enable: boolean
        :param enable: True to enable the contact detection model-wise, false
            to disable.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_enable_contacts(self, enable)

    def links_in_contact(self):
        r"""
        Get the vector of links with active contacts with other bodies.

        :rtype: Iterable[string]
        :return: The vector of links in contact.
        """
        return _core.Model_links_in_contact(self)

    def contacts(self, *args):
        r"""
        Get the active contacts of the model.

        :type linkNames: Iterable[string]
        :param linkNames: Optionally restrict the considered links.
        :rtype: Tuple[Contact]
        :return: A vector of contacts.
        """
        return _core.Model_contacts(self, *args)

    def joint_positions(self, *args):
        r"""
        Get the joint positions.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Iterable[float]
        :return: The serialization of joint positions. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _core.Model_joint_positions(self, *args)

    def joint_velocities(self, *args):
        r"""
        Get the joint velocities.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Iterable[float]
        :return: The serialization of joint velocities. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _core.Model_joint_velocities(self, *args)

    def joint_accelerations(self, *args):
        r"""
        Get the joint accelerations.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Iterable[float]
        :return: The serialization of joint accelerations. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _core.Model_joint_accelerations(self, *args)

    def joint_generalized_forces(self, *args):
        r"""
        Get the joint generalized forces.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Iterable[float]
        :return: The serialization of joint forces. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _core.Model_joint_generalized_forces(self, *args)

    def joint_limits(self, *args):
        r"""
        Get the joint limits of the model.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: :py:class:`JointLimit`
        :return: The joint limits of the model. The vectors of the limit
            object have as many elements as DoFs of the considered joints.
        """
        return _core.Model_joint_limits(self, *args)

    def set_joint_control_mode(self, *args):
        r"""
        Set the control mode of model joints.

        :type mode: int
        :param mode: The desired joint control mode.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_joint_control_mode(self, *args)

    def links(self, *args):
        r"""
        Get the links of the model.

        :type linkNames: Iterable[string]
        :param linkNames: Optional vector of considered links. By default,
            ``Model::linkNames`` is used.
        :rtype: Tuple[Link]
        :return: A vector of pointers to the link objects.
        """
        return _core.Model_links(self, *args)

    def joints(self, *args):
        r"""
        Get the joints of the model.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Tuple[Joint]
        :return: A vector of pointers to the joint objects.
        """
        return _core.Model_joints(self, *args)

    def set_joint_position_targets(self, *args):
        r"""
        Set the position targets of the joints.

        :type positions: Iterable[float]
        :param positions: The vector with the joint position targets. It must
            have as many elements as the considered joint DoFs.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_joint_position_targets(self, *args)

    def set_joint_velocity_targets(self, *args):
        r"""
        Set the velocity targets of the joints.

        :type velocities: Iterable[float]
        :param velocities: The vector with the joint velocity targets. It must
            have as many elements as the considered joint DoFs.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_joint_velocity_targets(self, *args)

    def set_joint_acceleration_targets(self, *args):
        r"""
        Set the acceleration targets of the joints.

        :type accelerations: Iterable[float]
        :param accelerations: The vector with the joint acceleration targets.
            It must have as many elements as the considered joint DoFs.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_joint_acceleration_targets(self, *args)

    def set_joint_generalized_force_targets(self, *args):
        r"""
        Set the generalized force targets of the joints.

        :type forces: Iterable[float]
        :param forces: The vector with the joint generalized force targets. It
            must have as many elements as the considered joint DoFs.
        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_joint_generalized_force_targets(self, *args)

    def joint_position_targets(self, *args):
        r"""
        Get the position targets of the joints.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Iterable[float]
        :return: The position targets of the joints.
        """
        return _core.Model_joint_position_targets(self, *args)

    def joint_velocity_targets(self, *args):
        r"""
        Get the velocity targets of the joints.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Iterable[float]
        :return: The velocity targets of the joints.
        """
        return _core.Model_joint_velocity_targets(self, *args)

    def joint_acceleration_targets(self, *args):
        r"""
        Get the acceleration targets of the joints.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Iterable[float]
        :return: The acceleration targets of the joints.
        """
        return _core.Model_joint_acceleration_targets(self, *args)

    def joint_generalized_force_targets(self, *args):
        r"""
        Get the generalized force targets of the joints.

        :type jointNames: Iterable[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Iterable[float]
        :return: The generalized force targets of the joints.
        """
        return _core.Model_joint_generalized_force_targets(self, *args)

    def base_frame(self):
        r"""
        Get the name of the model's base frame.

        By default, the base frame is typically the root of the kinematic tree of
        the model.

        :rtype: string
        :return: The name of the model's base frame.
        """
        return _core.Model_base_frame(self)

    def base_position(self):
        r"""
        Get the position of the base link.

        :rtype: Iterable[float, float, float]
        :return: The position of the base link in world coordinates.
        """
        return _core.Model_base_position(self)

    def base_orientation(self):
        r"""
        Get the orientation of the base link.

        :rtype: Iterable[float, float, float, float]
        :return: The wxyz quaternion defining the orientation of the base link wrt
            the world frame.
        """
        return _core.Model_base_orientation(self)

    def base_body_linear_velocity(self):
        r"""
        Get the linear body velocity of the base link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear body velocity of the base link.
        """
        return _core.Model_base_body_linear_velocity(self)

    def base_body_angular_velocity(self):
        r"""
        Get the angular body velocity of the base link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular body velocity of the base link.
        """
        return _core.Model_base_body_angular_velocity(self)

    def base_world_linear_velocity(self):
        r"""
        Get the linear mixed velocity of the base link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The linear mixed velocity of the base link.
        """
        return _core.Model_base_world_linear_velocity(self)

    def base_world_angular_velocity(self):
        r"""
        Get the angular mixed velocity of the base link.

        TODO: Add link to the velocity representation documentation page.

        :rtype: Iterable[float, float, float]
        :return: The angular mixed velocity of the base link.
        """
        return _core.Model_base_world_angular_velocity(self)

    def set_base_pose_target(self, position, orientation):
        r"""
        Set the pose target of the base link.

        :type position: Iterable[float, float, float]
        :param position: The position target of the base link in world
            coordinates.
        :type orientation: Iterable[float, float, float, float]
        :param orientation: The wxyz quaternion defining the orientation target of
            the base link wrt the world frame.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_pose_target(self, position, orientation)

    def set_base_position_target(self, position):
        r"""
        Set the position target of the base link.

        :type position: Iterable[float, float, float]
        :param position: The position target of the base link in world
            coordinates.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_position_target(self, position)

    def set_base_orientation_target(self, orientation):
        r"""
        Set the orientation target of the base link.

        :type orientation: Iterable[float, float, float, float]
        :param orientation: The wxyz quaternion defining the orientation target of
            the base link wrt the world frame.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_orientation_target(self, orientation)

    def set_base_world_velocity_target(self, linear, angular):
        r"""
        Set the mixed velocity target of the base link.

        :type linear: Iterable[float, float, float]
        :param linear: The mixed linear velocity target of the base link.
        :type angular: Iterable[float, float, float]
        :param angular: The mixed angular velocity target of the base link.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_world_velocity_target(self, linear, angular)

    def set_base_world_linear_velocity_target(self, linear):
        r"""
        Set the mixed linear velocity target of the base link.

        :type linear: Iterable[float, float, float]
        :param linear: The mixed linear velocity target of the base link.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_world_linear_velocity_target(self, linear)

    def set_base_world_angular_velocity_target(self, angular):
        r"""
        Set the mixed angular velocity target of the base link.

        :type angular: Iterable[float, float, float]
        :param angular: The mixed angular velocity target of the base link.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_world_angular_velocity_target(self, angular)

    def set_base_world_linear_acceleration_target(self, linear):
        r"""
        Set the mixed linear acceleration target of the base link.

        :type linear: Iterable[float, float, float]
        :param linear: The mixed linear acceleration target of the base link.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_world_linear_acceleration_target(self, linear)

    def set_base_world_angular_acceleration_target(self, angular):
        r"""
        Set the mixed angular acceleration target of the base link.

        :type angular: Iterable[float, float, float]
        :param angular: The mixed angular acceleration target of the base link.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _core.Model_set_base_world_angular_acceleration_target(self, angular)

    def base_position_target(self):
        r"""
        Get the position target of the base link.

        :rtype: Iterable[float, float, float]
        :return: The position target of the base link.
        """
        return _core.Model_base_position_target(self)

    def base_orientation_target(self):
        r"""
        Get the orientation target of the base link.

        :rtype: Iterable[float, float, float, float]
        :return: The quaternion defining the orientation target of the base link.
        """
        return _core.Model_base_orientation_target(self)

    def base_world_linear_velocity_target(self):
        r"""
        Get the mixed linear velocity target of the base link.

        :rtype: Iterable[float, float, float]
        :return: The mixed linear velocity target of the base link.
        """
        return _core.Model_base_world_linear_velocity_target(self)

    def base_world_angular_velocity_target(self):
        r"""
        Get the mixed angular velocity target of the base link.

        :rtype: Iterable[float, float, float]
        :return: The mixed angular velocity target of the base link.
        """
        return _core.Model_base_world_angular_velocity_target(self)

    def base_world_linear_acceleration_target(self):
        r"""
        Get the mixed linear acceleration target of the base link.

        :rtype: Iterable[float, float, float]
        :return: The mixed linear acceleration target of the base link.
        """
        return _core.Model_base_world_linear_acceleration_target(self)

    def base_world_angular_acceleration_target(self):
        r"""
        Get the mixed angular acceleration target of the base link.

        :rtype: Iterable[float, float, float]
        :return: The mixed angular acceleration target of the base link.
        """
        return _core.Model_base_world_angular_acceleration_target(self)

    def to_gazebo(self) -> Union["scenario.bindings.gazebo.Model", "scenario.bindings.core.Model"]:
        return scenario.bindings.gazebo.ToGazeboModel(self)


# Register Model in _core:
_core.Model_swigregister(Model)

class World(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _core.delete_World

    def valid(self):
        r"""
        Check if the world is valid.

        :rtype: boolean
        :return: True if the world is valid, false otherwise.
        """
        return _core.World_valid(self)

    def time(self):
        r"""
        Get the simulated time.

        Notes: A physics plugin need to be part of the simulation
        in order to make the time flow.

        :rtype: float
        :return: The simulated time.
        """
        return _core.World_time(self)

    def name(self):
        r"""
        Get the name of the world.

        :rtype: string
        :return: The name of the world.
        """
        return _core.World_name(self)

    def gravity(self):
        r"""
        Get the gravity vector.
        :rtype: Iterable[float, float, float]
        :return: The gravity vector.
        """
        return _core.World_gravity(self)

    def model_names(self):
        r"""
        Get the name of the models that are part of the world.

        :rtype: Iterable[string]
        :return: The list of model names.
        """
        return _core.World_model_names(self)

    def get_model(self, model_name):
        r"""
        Get a model part of the world.

        :type modelName: string
        :param modelName: The name of the model to get.
        :rtype: :py:class:`Model`
        :return: The model if it is part of the world, ``nullptr`` otherwise.
        """
        return _core.World_get_model(self, model_name)

    def to_gazebo(self) -> Union["scenario.bindings.gazebo.World", "scenario.bindings.core.World"]:
        return scenario.bindings.gazebo.ToGazeboWorld(self)


# Register World in _core:
_core.World_swigregister(World)



