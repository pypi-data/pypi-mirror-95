{"version":3,"sources":["webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/components/charts/lineChart.tsx","webpack:///./app/actionCreators/events.tsx","webpack:///./app/components/charts/loadingPanel.tsx","webpack:////workspace/node_modules/lodash/omitBy.js","webpack:///./app/utils/getPeriod.tsx","webpack:///./app/components/breadcrumbs.tsx","webpack:////workspace/node_modules/lodash/negate.js","webpack:///./app/components/loadingMask.tsx","webpack:///./app/views/settings/incidentRules/utils/getEventTypeFilter.tsx"],"names":["propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","includes","EventsRequest","state","reloading","loading","errored","timeseriesData","fetchedWithPrevious","unmounting","fetchData","a","api","confirmedQuery","setState","clear","doEventsRequest","responseJSON","detail","addErrorMessage","t","includePrevious","getData","data","period","hasPreviousPeriod","canIncludePreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","this","prevProps","isEqual","getName","timestamp","map","i","countArray","name","value","reduce","acc","count","seriesName","previousSeriesName","calculateTotalsPerTimestamp","_timestamp","_countArray","response","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","transformTimeseriesData","currentSeriesName","allData","originalData","originalPreviousData","previousData","transformPreviousPeriodData","timeAggregatedData","transformAggregatedTimeseries","children","showLoading","data-test-id","isMultiSeriesStats","results","Object","keys","seriesData","transformed","order","sort","b","item","processData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","previousTimeseriesData","React","PureComponent","defaultProps","undefined","start","end","interval","limit","query","LineChart","series","seriesOptions","dataArray","options","LineSeries","animation","animationThreshold","animationDuration","Component","organization","project","environment","yAxis","field","topEvents","orderby","shouldDoublePeriod","urlQuery","fromEntries","entries","filter","periodObj","getPeriod","requestPromise","slug","fetchTagFacets","orgSlug","urlParams","pick","values","URL_PARAM","queryOption","fetchTotalCount","then","res","LoadingPanel","height","p","baseIteratee","negate","pickBy","module","exports","object","predicate","DEFAULT_STATS_PERIOD","statsPeriod","match","periodNumber","periodLength","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","moment","previousPeriodStart","subtract","Breadcrumbs","crumbs","linkLastItem","to","BreadcrumbList","index","label","preserveGlobalSelection","labelKey","mapKey","Fragment","BreadcrumbLink","BreadcrumbItem","BreadcrumbDividerIcon","size","direction","getBreadcrumbListItemStyles","theme","gray300","overflowEllipsis","textColor","space","subText","IconChevron","TypeError","args","arguments","call","apply","LoadingMask","backgroundSecondary","borderRadius","extractEventTypeFilterFromRule","metricRule","getEventTypeFilter","dataset","eventTypes","DATASOURCE_EVENT_TYPE_FILTERS","convertDatasetEventTypesToSource","Datasource","ERROR","DATASET_EVENT_TYPE_FILTERS","Dataset","ERRORS"],"mappings":"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","file":"AlertRulesDetails~ProjectAlertsCreate~ProjectAlertsEdit.js","sourcesContent":["import React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'app/actionCreators/events';\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {Client} from 'app/api';\nimport LoadingPanel from 'app/components/charts/loadingPanel';\nimport {canIncludePreviousPeriod, isMultiSeriesStats} from 'app/components/charts/utils';\nimport {t} from 'app/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {Series, SeriesDataUnit} from 'app/types/echarts';\n\nexport type TimeSeriesData = {\n  // timeseries data\n  timeseriesData?: Series[];\n  allTimeseriesData?: EventsStatsData;\n  originalTimeseriesData?: EventsStatsData;\n  timeseriesTotals?: {count: number};\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  previousTimeseriesData?: Series | null;\n  timeAggregatedData?: Series | {};\n};\n\ntype LoadingStatus = {\n  loading: boolean;\n  reloading: boolean;\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n};\n\n// Chart format for multiple series.\ntype MultiSeriesResults = Series[];\n\ntype RenderProps = LoadingStatus & TimeSeriesData & {results?: MultiSeriesResults};\n\ntype DefaultProps = {\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  organization: OrganizationSummary;\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesName?: string;\n  previousSeriesName?: string;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\ntype EventsRequestProps = DefaultProps & TimeAggregationProps & EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  reloading: boolean;\n  errored: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  fetchedWithPrevious: boolean;\n};\n\nconst propNamesToIgnore = ['api', 'children', 'organization', 'loading'];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n    }));\n\n    try {\n      api.clear();\n      timeseriesData = await doEventsRequest(api, props);\n    } catch (resp) {\n      if (resp && resp.responseJSON && resp.responseJSON.detail) {\n        addErrorMessage(resp.responseJSON.detail);\n      } else {\n        addErrorMessage(t('Error loading chart data'));\n      }\n      this.setState({\n        errored: true,\n      });\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {previous: EventsStatsData | null; current: EventsStatsData} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: this.props.previousSeriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats | null) {\n    if (!response) {\n      return {};\n    }\n\n    const {data, totals} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(current, this.props.currentSeriesName)\n      : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(current, previous)\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    return {\n      data: transformedData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      const results: MultiSeriesResults = Object.keys(timeseriesData)\n        .map((seriesName: string): [number, Series] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const transformed = this.transformTimeseriesData(\n            seriesData.data,\n            seriesName\n          )[0];\n          return [seriesData.order || 0, transformed];\n        })\n        .sort((a, b) => a[0] - b[0])\n        .map(item => item[1]);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        results,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n\n    const {\n      data: transformedTimeseriesData,\n      allData: allTimeseriesData,\n      originalData: originalTimeseriesData,\n      totals: timeseriesTotals,\n      originalPreviousData: originalPreviousTimeseriesData,\n      previousData: previousTimeseriesData,\n      timeAggregatedData,\n    } = this.processData(timeseriesData);\n\n    return children({\n      loading,\n      reloading,\n      errored,\n      // timeseries data\n      timeseriesData: transformedTimeseriesData,\n      allTimeseriesData,\n      originalTimeseriesData,\n      timeseriesTotals,\n      originalPreviousTimeseriesData,\n      previousTimeseriesData,\n      timeAggregatedData,\n      // sometimes we want to reference props that were given to EventsRequest\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport LineSeries from './series/lineSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type LineChartSeries = Series &\n  Omit<EChartOption.SeriesLine, 'data' | 'name' | 'lineStyle'> & {\n    dataArray?: EChartOption.SeriesLine['data'];\n    lineStyle?: any; // TODO(ts): Fix when echarts type is updated so that EchartOption.LineStyle matches SeriesLine['lineStyle']\n  };\n\ntype Props = Omit<ChartProps, 'series'> & {\n  series: LineChartSeries[];\n  seriesOptions?: EChartOption.SeriesLine;\n};\n\nexport default class LineChart extends React.Component<Props> {\n  render() {\n    const {series, seriesOptions, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, dataArray, ...options}) =>\n          LineSeries({\n            ...seriesOptions,\n            ...options,\n            name: seriesName,\n            data: dataArray || data.map(({value, name}) => [name, value]),\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n          })\n        )}\n      />\n    );\n  }\n}\n","import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {\n  DateString,\n  EventsStats,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {LocationQuery} from 'app/utils/discover/eventView';\nimport {getPeriod} from 'app/utils/getPeriod';\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: Readonly<number[]>;\n  environment?: Readonly<string[]>;\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  topEvents?: number;\n  orderby?: string;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`/organizations/${organization.slug}/events-stats/`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n  environment?: string[];\n  noPagination?: boolean;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport LoadingMask from 'app/components/loadingMask';\n\ntype Props = {\n  height?: string;\n} & React.HTMLProps<HTMLDivElement>;\n\nconst LoadingPanel = styled(({height: _height, ...props}: Props) => (\n  <div {...props}>\n    <LoadingMask />\n  </div>\n))`\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nLoadingPanel.defaultProps = {\n  height: '200px',\n};\n\nexport default LoadingPanel;\n","var baseIteratee = require('./_baseIteratee'),\n    negate = require('./negate'),\n    pickBy = require('./pickBy');\n\n/**\n * The opposite of `_.pickBy`; this method creates an object composed of\n * the own and inherited enumerable string keyed properties of `object` that\n * `predicate` doesn't return truthy for. The predicate is invoked with two\n * arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omitBy(object, _.isNumber);\n * // => { 'b': '2' }\n */\nfunction omitBy(object, predicate) {\n  return pickBy(object, negate(baseIteratee(predicate)));\n}\n\nmodule.exports = omitBy;\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'app/constants';\nimport {getUtcDateString} from 'app/utils/dates';\n\ntype DateObject = {\n  /**\n   * Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n   */\n  period?: string;\n  /**\n   * Starting date object\n   */\n  start?: string | Date | null;\n  /**\n   * Ending date object\n   */\n  end?: string | Date | null;\n};\n\ntype Options = {\n  /**\n   * Doubles the given period (useful for getting previous period data)\n   */\n  shouldDoublePeriod?: boolean;\n};\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\nexport const getPeriod = (\n  {period, start, end}: DateObject,\n  {shouldDoublePeriod}: Options = {}\n) => {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/)!;\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n};\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport GlobalSelectionLink from 'app/components/globalSelectionLink';\nimport Link from 'app/components/links/link';\nimport {IconChevron} from 'app/icons';\nimport overflowEllipsis from 'app/styles/overflowEllipsis';\nimport space from 'app/styles/space';\nimport {Theme} from 'app/utils/theme';\n\nexport type Crumb = {\n  /**\n   * Label of the crumb\n   */\n  label: React.ReactNode;\n\n  /**\n   * Link of the crumb\n   */\n  to?: React.ComponentProps<typeof Link>['to'] | null;\n\n  /**\n   * It will keep the global selection values (projects, environments, time) in the\n   * querystring when navigating (GlobalSelectionLink)\n   */\n  preserveGlobalSelection?: boolean;\n\n  /**\n   * Component will try to come up with unique key, but you can provide your own\n   * (used when mapping over crumbs)\n   */\n  key?: string;\n};\n\ntype Props = React.HTMLAttributes<HTMLDivElement> & {\n  /**\n   * Array of crumbs that will be rendered\n   */\n  crumbs: Crumb[];\n\n  /**\n   * As a general rule of thumb we don't want the last item to be link as it most likely\n   * points to the same page we are currently on. This is by default false, so that\n   * people don't have to check if crumb is last in the array and then manually\n   * assign `to: null/undefined` when passing props to this component.\n   */\n  linkLastItem?: boolean;\n};\n\n/**\n * Page breadcrumbs used for navigation, not to be confused with sentry's event breadcrumbs\n */\nconst Breadcrumbs = ({crumbs, linkLastItem = false, ...props}: Props) => {\n  if (crumbs.length === 0) {\n    return null;\n  }\n\n  if (!linkLastItem) {\n    crumbs[crumbs.length - 1].to = null;\n  }\n\n  return (\n    <BreadcrumbList {...props}>\n      {crumbs.map(({label, to, preserveGlobalSelection, key}, index) => {\n        const labelKey = typeof label === 'string' ? label : '';\n        const mapKey =\n          key ?? typeof to === 'string' ? `${labelKey}${to}` : `${labelKey}${index}`;\n\n        return (\n          <React.Fragment key={mapKey}>\n            {to ? (\n              <BreadcrumbLink to={to} preserveGlobalSelection={preserveGlobalSelection}>\n                {label}\n              </BreadcrumbLink>\n            ) : (\n              <BreadcrumbItem>{label}</BreadcrumbItem>\n            )}\n\n            {index < crumbs.length - 1 && (\n              <BreadcrumbDividerIcon size=\"xs\" direction=\"right\" />\n            )}\n          </React.Fragment>\n        );\n      })}\n    </BreadcrumbList>\n  );\n};\n\nconst getBreadcrumbListItemStyles = (p: {theme: Theme}) => `\n  color: ${p.theme.gray300};\n  ${overflowEllipsis};\n  width: auto;\n\n  &:last-child {\n    color: ${p.theme.textColor};\n  }\n`;\n\nconst BreadcrumbList = styled('div')`\n  display: flex;\n  align-items: center;\n  padding: ${space(1)} 0;\n`;\n\nconst BreadcrumbLink = styled(({preserveGlobalSelection, ...props}) =>\n  preserveGlobalSelection ? <GlobalSelectionLink {...props} /> : <Link {...props} />\n)`\n  ${getBreadcrumbListItemStyles}\n\n  &:hover,\n  &:active {\n    color: ${p => p.theme.subText};\n  }\n`;\n\nconst BreadcrumbItem = styled('span')`\n  ${getBreadcrumbListItemStyles}\n`;\n\nconst BreadcrumbDividerIcon = styled(IconChevron)`\n  color: ${p => p.theme.gray300};\n  margin: 0 ${space(1)};\n  flex-shrink: 0;\n`;\n\nexport default Breadcrumbs;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n","import styled from '@emotion/styled';\n\nconst LoadingMask = styled('div')`\n  background-color: ${p => p.theme.backgroundSecondary};\n  border-radius: ${p => p.theme.borderRadius};\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n`;\n\nexport default LoadingMask;\n","import {convertDatasetEventTypesToSource} from 'app/views/alerts/utils';\n\nimport {DATASET_EVENT_TYPE_FILTERS, DATASOURCE_EVENT_TYPE_FILTERS} from '../constants';\nimport {Dataset, Datasource, EventTypes, IncidentRule} from '../types';\n\nexport function extractEventTypeFilterFromRule(metricRule: IncidentRule) {\n  const {dataset, eventTypes} = metricRule;\n  return getEventTypeFilter(dataset, eventTypes);\n}\n\nexport function getEventTypeFilter(\n  dataset: Dataset,\n  eventTypes: EventTypes[] | undefined\n) {\n  if (eventTypes) {\n    return DATASOURCE_EVENT_TYPE_FILTERS[\n      convertDatasetEventTypesToSource(dataset, eventTypes) ?? Datasource.ERROR\n    ];\n  } else {\n    return DATASET_EVENT_TYPE_FILTERS[dataset ?? Dataset.ERRORS];\n  }\n}\n"],"sourceRoot":""}