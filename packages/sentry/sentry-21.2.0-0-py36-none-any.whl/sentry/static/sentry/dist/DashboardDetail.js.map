{"version":3,"sources":["webpack:///./app/components/charts/errorPanel.tsx","webpack:///./app/components/charts/lineChart.tsx","webpack:///./app/components/charts/chartZoom.tsx","webpack:///./app/components/charts/transitionChart.tsx"],"names":["ErrorPanel","p","height","theme","gray300","fontSizeExtraLarge","LineChart","this","props","series","seriesOptions","map","seriesName","data","dataArray","options","LineSeries","name","value","animation","animationThreshold","animationDuration","React","Component","getDate","date","moment","utc","format","HTML5_FMT","DATETIME_LOCAL_SECONDS","ChartZoom","history","currentPeriod","zooming","saveCurrentPeriod","period","start","end","setPeriod","saveHistory","router","onZoom","startFormatted","endFormatted","push","callIfFunction","updateDateTime","getUtcToLocalDateObject","handleChartReady","chart","dispatchAction","type","key","dataZoomSelectActive","onChartReady","handleZoomRestore","evt","length","onRestore","handleDataZoom","axis","getModel","option","xAxis","rangeStart","rangeEnd","previousPeriod","pop","onDataZoom","handleChartFinished","onFinished","disabled","_utc","_start","_end","children","xAxisIndex","undefined","isGroupedByDate","dataZoom","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","zoom","back","iconStyle","borderWidth","color","opacity","TransitionChart","state","prevReloading","reloading","prevLoading","loading","data-test-id","Fragment","String","nextReloading","nextLoading","defaultProps"],"mappings":"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","file":"DashboardDetail.js","sourcesContent":["import styled from '@emotion/styled';\n\nconst ErrorPanel = styled('div')<{height?: string}>`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height || '200px'};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n  color: ${p => p.theme.gray300};\n  font-size: ${p => p.theme.fontSizeExtraLarge};\n`;\n\nexport default ErrorPanel;\n","import React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport LineSeries from './series/lineSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type LineChartSeries = Series &\n  Omit<EChartOption.SeriesLine, 'data' | 'name' | 'lineStyle'> & {\n    dataArray?: EChartOption.SeriesLine['data'];\n    lineStyle?: any; // TODO(ts): Fix when echarts type is updated so that EchartOption.LineStyle matches SeriesLine['lineStyle']\n  };\n\ntype Props = Omit<ChartProps, 'series'> & {\n  series: LineChartSeries[];\n  seriesOptions?: EChartOption.SeriesLine;\n};\n\nexport default class LineChart extends React.Component<Props> {\n  render() {\n    const {series, seriesOptions, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, dataArray, ...options}) =>\n          LineSeries({\n            ...seriesOptions,\n            ...options,\n            name: seriesName,\n            data: dataArray || data.map(({value, name}) => [name, value]),\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n          })\n        )}\n      />\n    );\n  }\n}\n","import React from 'react';\nimport {WithRouterProps} from 'react-router/lib/withRouter';\nimport {EChartOption} from 'echarts/lib/echarts';\nimport moment from 'moment';\n\nimport {updateDateTime} from 'app/actionCreators/globalSelection';\nimport DataZoomInside from 'app/components/charts/components/dataZoomInside';\nimport ToolBox from 'app/components/charts/components/toolBox';\nimport {DateString} from 'app/types';\nimport {\n  EChartChartReadyHandler,\n  EChartDataZoomHandler,\n  EChartFinishedHandler,\n  EChartRestoreHandler,\n} from 'app/types/echarts';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {getUtcToLocalDateObject} from 'app/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\ntype Period = {\n  period: string;\n  start: DateString;\n  end: DateString;\n};\n\nconst ZoomPropKeys = [\n  'period',\n  'xAxis',\n  'onChartReady',\n  'onDataZoom',\n  'onRestore',\n  'onFinished',\n] as const;\n\nexport type ZoomRenderProps = Pick<Props, typeof ZoomPropKeys[number]> & {\n  utc?: boolean;\n  start?: Date;\n  end?: Date;\n  isGroupedByDate?: boolean;\n  showTimeInTooltip?: boolean;\n  dataZoom?: EChartOption.DataZoom[];\n  toolBox?: EChartOption['toolbox'];\n};\n\ntype Props = {\n  router?: WithRouterProps['router'];\n  children: (props: ZoomRenderProps) => React.ReactNode;\n  disabled?: boolean;\n  xAxis?: EChartOption.XAxis;\n  xAxisIndex?: number | number[];\n  start?: DateString;\n  end?: DateString;\n  period?: string;\n  utc?: boolean | null;\n  onChartReady?: EChartChartReadyHandler;\n  onDataZoom?: EChartDataZoomHandler;\n  onFinished?: EChartFinishedHandler;\n  onRestore?: EChartRestoreHandler;\n  onZoom?: (Period) => void;\n};\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends React.Component<Props> {\n  constructor(props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  history: Period[];\n  currentPeriod?: Period;\n  zooming: (() => void) | null = null;\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory = false) => {\n    const {router, onZoom} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod!);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    callIfFunction(onZoom, {\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      updateDateTime(\n        {\n          period,\n          start: startFormatted\n            ? getUtcToLocalDateObject(startFormatted)\n            : startFormatted,\n          end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n        },\n        router\n      );\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    chart.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: true,\n    });\n\n    callIfFunction(this.props.onChartReady, chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    callIfFunction(this.props.onRestore, evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {xAxis} = model.option;\n    const axis = xAxis[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (axis.rangeStart === null && axis.rangeEnd === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(axis.rangeStart);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(axis.rangeEnd);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    callIfFunction(this.props.onDataZoom, evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = () => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc: _utc,\n      start: _start,\n      end: _end,\n      disabled,\n      children,\n      xAxisIndex,\n\n      router: _router,\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      ...props\n    } = this.props;\n\n    const utc = _utc ?? undefined;\n    const start = _start ? getUtcToLocalDateObject(_start) : undefined;\n    const end = _end ? getUtcToLocalDateObject(_end) : undefined;\n\n    if (disabled) {\n      return children({\n        utc,\n        start,\n        end,\n        ...props,\n      });\n    }\n\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      start,\n      end,\n      dataZoom: DataZoomInside({xAxisIndex}),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onFinished: this.handleChartFinished,\n      onRestore: this.handleZoomRestore,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import React from 'react';\n\nimport LoadingPanel from 'app/components/charts/loadingPanel';\n\nconst defaultProps = {\n  height: '200px',\n};\n\ntype Props = {\n  reloading: boolean;\n  loading: boolean;\n} & typeof defaultProps;\n\ntype State = {\n  prevReloading: boolean;\n  prevLoading: boolean;\n  key: number;\n};\n\nclass TransitionChart extends React.Component<Props, State> {\n  static defaultProps = defaultProps;\n\n  state = {\n    prevReloading: this.props.reloading,\n    prevLoading: this.props.loading,\n    key: 1,\n  };\n\n  static getDerivedStateFromProps(props: Props, state: State) {\n    // Transitions are controlled using variables called:\n    // - loading and,\n    // - reloading (also called pending in other apps)\n    //\n    // This component remounts the chart to ensure the stable transition\n    // from one data set to the next.\n\n    const prevReloading = state.prevReloading;\n    const nextReloading = props.reloading;\n\n    const prevLoading = state.prevLoading;\n    const nextLoading = props.loading;\n\n    // whenever loading changes, we explicitly remount the children by updating\n    // the key prop; regardless of what state reloading is in\n    if (prevLoading !== nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // invariant: prevLoading === nextLoading\n\n    // if loading is true, and hasn't changed from the previous re-render,\n    // do not remount the children.\n    if (nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key,\n      };\n    }\n\n    // invariant: loading is false\n\n    // whenever the chart is transitioning from the reloading (pending) state to a non-loading state,\n    // remount the children\n    if (prevReloading && !nextReloading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // do not remount the children in these remaining cases:\n    // !prevReloading && !nextReloading (re-render with no prop change)\n    // prevReloading && nextReloading (re-render with no prop change)\n    // !prevReloading && nextReloading (from loaded to pending state)\n\n    return {\n      prevReloading: nextReloading,\n      prevLoading: nextLoading,\n      key: state.key,\n    };\n  }\n\n  render() {\n    const {height, loading, reloading} = this.props;\n\n    if (loading && !reloading) {\n      return <LoadingPanel height={height} data-test-id=\"events-request-loading\" />;\n    }\n\n    // We make use of the key prop to explicitly remount the children\n    // https://reactjs.org/docs/lists-and-keys.html#keys\n    return (\n      <React.Fragment key={String(this.state.key)}>{this.props.children}</React.Fragment>\n    );\n  }\n}\n\nexport default TransitionChart;\n"],"sourceRoot":""}