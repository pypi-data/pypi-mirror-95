{"version":3,"sources":["webpack:///./app/utils/discover/charts.tsx","webpack:///./app/components/charts/eventsRequest.tsx","webpack:///./app/components/charts/areaChart.tsx","webpack:///./app/actionCreators/events.tsx","webpack:////workspace/node_modules/lodash/omitBy.js","webpack:////workspace/node_modules/lodash/negate.js","webpack:///./app/components/charts/series/areaSeries.tsx","webpack:///./app/components/charts/eventsChart.tsx"],"names":["tooltipFormatter","value","seriesName","aggregateOutputType","toLocaleString","formatPercentage","getDuration","toString","axisLabelFormatter","abbreviation","formatAbbreviatedNumber","axisDuration","WEEK","label","toFixed","t","DAY","HOUR","MINUTE","SECOND","propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","includes","EventsRequest","state","reloading","loading","errored","timeseriesData","fetchedWithPrevious","unmounting","fetchData","a","api","confirmedQuery","setState","clear","doEventsRequest","responseJSON","detail","addErrorMessage","includePrevious","getData","data","period","hasPreviousPeriod","canIncludePreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","this","prevProps","isEqual","getName","timestamp","map","i","countArray","name","reduce","acc","count","previousSeriesName","calculateTotalsPerTimestamp","_timestamp","_countArray","response","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","transformTimeseriesData","currentSeriesName","allData","originalData","originalPreviousData","previousData","transformPreviousPeriodData","timeAggregatedData","transformAggregatedTimeseries","children","showLoading","data-test-id","isMultiSeriesStats","results","Object","keys","seriesData","transformed","order","sort","b","item","processData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","previousTimeseriesData","React","PureComponent","defaultProps","undefined","start","end","interval","limit","query","AreaChart","series","stacked","colors","otherSeriesProps","AreaSeries","stack","color","lineStyle","opacity","width","areaStyle","animation","animationThreshold","animationDuration","Component","organization","project","environment","yAxis","field","topEvents","orderby","shouldDoublePeriod","urlQuery","fromEntries","entries","filter","periodObj","getPeriod","requestPromise","slug","fetchTagFacets","orgSlug","urlParams","pick","values","URL_PARAM","queryOption","fetchTotalCount","then","res","baseIteratee","negate","pickBy","module","exports","object","predicate","TypeError","args","arguments","call","apply","LineSeries","Chart","seriesSelection","forceUpdate","handleLegendSelectChanged","legendChange","disableableSeries","selected","disableable","nextProps","nextState","releaseSeries","showDaily","BarChart","aggregateMultiPlotType","LineChart","Error","zoomRenderProps","showLegend","legendOptions","chartOptionsProp","chartOptions","seriesTransformer","Array","isArray","push","legend","right","top","theme","charts","getColorPalette","grid","left","bottom","seriesOptions","showSymbol","tooltip","trigger","truncate","valueFormatter","axisLabel","chartLabel","formatter","getChartComponent","onLegendSelectChanged","previousPeriod","EventsChart","utc","router","projects","environments","disablePrevious","disableReleases","emphasizeReleases","currentName","previousName","chartHeader","preserveReleaseQueryParams","releaseQueryExtra","intervalVal","getInterval","chartImplementation","size","visible","isValidElement","previousChart","chartProps","preserveQueryParams","queryExtra","eventData"],"mappings":"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","file":"DiscoverV2Results~Events~PerformanceLanding~ReleasesDetailOverview.js","sourcesContent":["import {t} from 'app/locale';\nimport {aggregateOutputType} from 'app/utils/discover/fields';\nimport {\n  DAY,\n  formatAbbreviatedNumber,\n  formatPercentage,\n  getDuration,\n  HOUR,\n  MINUTE,\n  SECOND,\n  WEEK,\n} from 'app/utils/formatters';\n\n/**\n * Formatter for chart tooltips that handle a variety of discover result values\n */\nexport function tooltipFormatter(value: number, seriesName: string = ''): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 2);\n    case 'duration':\n      return getDuration(value / 1000, 2, true);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Formatter for chart axis labels that handle a variety of discover result values\n * This function is *very similar* to tooltipFormatter but outputs data with less precision.\n */\nexport function axisLabelFormatter(\n  value: number,\n  seriesName: string,\n  abbreviation: boolean = false\n): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return abbreviation ? formatAbbreviatedNumber(value) : value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 0);\n    case 'duration':\n      return axisDuration(value);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Specialized duration formatting for axis labels.\n * In that context we are ok sacrificing accuracy for more\n * consistent sizing.\n *\n * @param value Number of milliseconds to format.\n */\nexport function axisDuration(value: number): string {\n  if (value === 0) {\n    return '0';\n  }\n  if (value >= WEEK) {\n    const label = (value / WEEK).toFixed(0);\n    return t('%swk', label);\n  }\n  if (value >= DAY) {\n    const label = (value / DAY).toFixed(0);\n    return t('%sd', label);\n  }\n  if (value >= HOUR) {\n    const label = (value / HOUR).toFixed(0);\n    return t('%shr', label);\n  }\n  if (value >= MINUTE) {\n    const label = (value / MINUTE).toFixed(0);\n    return t('%smin', label);\n  }\n  if (value >= SECOND) {\n    const label = (value / SECOND).toFixed(0);\n    return t('%ss', label);\n  }\n  const label = (value / SECOND).toFixed(1);\n  return t('%ss', label);\n}\n","import React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\n\nimport {doEventsRequest} from 'app/actionCreators/events';\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {Client} from 'app/api';\nimport LoadingPanel from 'app/components/charts/loadingPanel';\nimport {canIncludePreviousPeriod, isMultiSeriesStats} from 'app/components/charts/utils';\nimport {t} from 'app/locale';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {Series, SeriesDataUnit} from 'app/types/echarts';\n\nexport type TimeSeriesData = {\n  // timeseries data\n  timeseriesData?: Series[];\n  allTimeseriesData?: EventsStatsData;\n  originalTimeseriesData?: EventsStatsData;\n  timeseriesTotals?: {count: number};\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  previousTimeseriesData?: Series | null;\n  timeAggregatedData?: Series | {};\n};\n\ntype LoadingStatus = {\n  loading: boolean;\n  reloading: boolean;\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n};\n\n// Chart format for multiple series.\ntype MultiSeriesResults = Series[];\n\ntype RenderProps = LoadingStatus & TimeSeriesData & {results?: MultiSeriesResults};\n\ntype DefaultProps = {\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  organization: OrganizationSummary;\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesName?: string;\n  previousSeriesName?: string;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\ntype EventsRequestProps = DefaultProps & TimeAggregationProps & EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  reloading: boolean;\n  errored: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  fetchedWithPrevious: boolean;\n};\n\nconst propNamesToIgnore = ['api', 'children', 'organization', 'loading'];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n    }));\n\n    try {\n      api.clear();\n      timeseriesData = await doEventsRequest(api, props);\n    } catch (resp) {\n      if (resp && resp.responseJSON && resp.responseJSON.detail) {\n        addErrorMessage(resp.responseJSON.detail);\n      } else {\n        addErrorMessage(t('Error loading chart data'));\n      }\n      this.setState({\n        errored: true,\n      });\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {previous: EventsStatsData | null; current: EventsStatsData} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: this.props.previousSeriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats | null) {\n    if (!response) {\n      return {};\n    }\n\n    const {data, totals} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(current, this.props.currentSeriesName)\n      : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(current, previous)\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    return {\n      data: transformedData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      const results: MultiSeriesResults = Object.keys(timeseriesData)\n        .map((seriesName: string): [number, Series] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const transformed = this.transformTimeseriesData(\n            seriesData.data,\n            seriesName\n          )[0];\n          return [seriesData.order || 0, transformed];\n        })\n        .sort((a, b) => a[0] - b[0])\n        .map(item => item[1]);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        results,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n\n    const {\n      data: transformedTimeseriesData,\n      allData: allTimeseriesData,\n      originalData: originalTimeseriesData,\n      totals: timeseriesTotals,\n      originalPreviousData: originalPreviousTimeseriesData,\n      previousData: previousTimeseriesData,\n      timeAggregatedData,\n    } = this.processData(timeseriesData);\n\n    return children({\n      loading,\n      reloading,\n      errored,\n      // timeseries data\n      timeseriesData: transformedTimeseriesData,\n      allTimeseriesData,\n      originalTimeseriesData,\n      timeseriesTotals,\n      originalPreviousTimeseriesData,\n      previousTimeseriesData,\n      timeAggregatedData,\n      // sometimes we want to reference props that were given to EventsRequest\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","import React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport AreaSeries from './series/areaSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type AreaChartSeries = Series &\n  Omit<EChartOption.SeriesLine, 'data' | 'name' | 'lineStyle'> & {\n    lineStyle?: any; // TODO(ts): Fix when echarts type is updated so that EchartOption.LineStyle matches SeriesLine['lineStyle']\n  };\n\ntype Props = Omit<ChartProps, 'series'> & {\n  stacked?: boolean;\n  series: AreaChartSeries[];\n};\n\nclass AreaChart extends React.Component<Props> {\n  render() {\n    const {series, stacked, colors, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, ...otherSeriesProps}, i) =>\n          AreaSeries({\n            stack: stacked ? 'area' : undefined,\n            name: seriesName,\n            data: data.map(({name, value}) => [name, value]),\n            color: colors && colors[i],\n            lineStyle: {\n              opacity: 1,\n              width: 0.4,\n            },\n            areaStyle: {\n              color: colors && colors[i],\n              opacity: 1.0,\n            },\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n            ...otherSeriesProps,\n          })\n        )}\n      />\n    );\n  }\n}\n\nexport default AreaChart;\n","import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {\n  DateString,\n  EventsStats,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {LocationQuery} from 'app/utils/discover/eventView';\nimport {getPeriod} from 'app/utils/getPeriod';\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: Readonly<number[]>;\n  environment?: Readonly<string[]>;\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  topEvents?: number;\n  orderby?: string;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`/organizations/${organization.slug}/events-stats/`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n  environment?: string[];\n  noPagination?: boolean;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","var baseIteratee = require('./_baseIteratee'),\n    negate = require('./negate'),\n    pickBy = require('./pickBy');\n\n/**\n * The opposite of `_.pickBy`; this method creates an object composed of\n * the own and inherited enumerable string keyed properties of `object` that\n * `predicate` doesn't return truthy for. The predicate is invoked with two\n * arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omitBy(object, _.isNumber);\n * // => { 'b': '2' }\n */\nfunction omitBy(object, predicate) {\n  return pickBy(object, negate(baseIteratee(predicate)));\n}\n\nmodule.exports = omitBy;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n","import {EChartOption} from 'echarts';\n\nimport LineSeries from 'app/components/charts/series/lineSeries';\n\nexport default function AreaSeries(\n  props: EChartOption.SeriesLine = {}\n): EChartOption.SeriesLine {\n  return LineSeries({\n    ...props,\n  });\n}\n","import React from 'react';\nimport {InjectedRouter} from 'react-router/lib/Router';\nimport {EChartOption} from 'echarts/lib/echarts';\nimport {Query} from 'history';\nimport isEqual from 'lodash/isEqual';\n\nimport {Client} from 'app/api';\nimport AreaChart from 'app/components/charts/areaChart';\nimport BarChart from 'app/components/charts/barChart';\nimport ChartZoom, {ZoomRenderProps} from 'app/components/charts/chartZoom';\nimport ErrorPanel from 'app/components/charts/errorPanel';\nimport LineChart from 'app/components/charts/lineChart';\nimport ReleaseSeries from 'app/components/charts/releaseSeries';\nimport TransitionChart from 'app/components/charts/transitionChart';\nimport TransparentLoadingMask from 'app/components/charts/transparentLoadingMask';\nimport {getInterval} from 'app/components/charts/utils';\nimport {IconWarning} from 'app/icons';\nimport {t} from 'app/locale';\nimport {DateString, OrganizationSummary} from 'app/types';\nimport {Series} from 'app/types/echarts';\nimport {axisLabelFormatter, tooltipFormatter} from 'app/utils/discover/charts';\nimport {aggregateMultiPlotType} from 'app/utils/discover/fields';\nimport theme from 'app/utils/theme';\n\nimport EventsRequest from './eventsRequest';\n\ntype ChartProps = {\n  loading: boolean;\n  reloading: boolean;\n  zoomRenderProps: ZoomRenderProps;\n  timeseriesData: Series[];\n  showLegend?: boolean;\n  legendOptions?: EChartOption.Legend;\n  chartOptions?: EChartOption;\n  currentSeriesName?: string;\n  releaseSeries?: Series[];\n  previousTimeseriesData?: Series | null;\n  previousSeriesName?: string;\n  /**\n   * A callback to allow for post-processing of the series data.\n   * Can be used to rename series or even insert a new series.\n   */\n  seriesTransformer?: (series: Series[]) => Series[];\n  showDaily?: boolean;\n  interval?: string;\n  yAxis: string;\n  stacked: boolean;\n  colors?: string[];\n  /**\n   * By default, only the release series is disableable. This adds\n   * a list of series names that are also disableable.\n   */\n  disableableSeries?: string[];\n};\n\ntype State = {\n  seriesSelection: Record<string, boolean>;\n  forceUpdate: boolean;\n};\n\nclass Chart extends React.Component<ChartProps, State> {\n  state: State = {\n    seriesSelection: {},\n    forceUpdate: false,\n  };\n\n  shouldComponentUpdate(nextProps: ChartProps, nextState: State) {\n    if (nextState.forceUpdate) {\n      return true;\n    }\n\n    if (!isEqual(this.state.seriesSelection, nextState.seriesSelection)) {\n      return true;\n    }\n\n    if (nextProps.reloading || !nextProps.timeseriesData) {\n      return false;\n    }\n\n    if (\n      isEqual(this.props.timeseriesData, nextProps.timeseriesData) &&\n      isEqual(this.props.releaseSeries, nextProps.releaseSeries) &&\n      isEqual(this.props.previousTimeseriesData, nextProps.previousTimeseriesData)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getChartComponent():\n    | React.ComponentType<BarChart['props']>\n    | React.ComponentType<AreaChart['props']>\n    | React.ComponentType<LineChart['props']> {\n    const {showDaily, timeseriesData, yAxis} = this.props;\n    if (showDaily) {\n      return BarChart;\n    }\n    if (timeseriesData.length > 1) {\n      switch (aggregateMultiPlotType(yAxis)) {\n        case 'line':\n          return LineChart;\n        case 'area':\n          return AreaChart;\n        default:\n          throw new Error(`Unknown multi plot type for ${yAxis}`);\n      }\n    }\n    return AreaChart;\n  }\n\n  handleLegendSelectChanged = legendChange => {\n    const {disableableSeries = []} = this.props;\n    const {selected} = legendChange;\n    const seriesSelection = Object.keys(selected).reduce((state, key) => {\n      // we only want them to be able to disable the Releases series,\n      // and not any of the other possible series here\n      const disableable = key === 'Releases' || disableableSeries.includes(key);\n      state[key] = disableable ? selected[key] : true;\n      return state;\n    }, {});\n\n    // we have to force an update here otherwise ECharts will\n    // update its internal state and disable the series\n    this.setState({seriesSelection, forceUpdate: true}, () =>\n      this.setState({forceUpdate: false})\n    );\n  };\n\n  render() {\n    const {\n      loading: _loading,\n      reloading: _reloading,\n      yAxis,\n      releaseSeries,\n      zoomRenderProps,\n      timeseriesData,\n      previousTimeseriesData,\n      showLegend,\n      legendOptions,\n      chartOptions: chartOptionsProp,\n      currentSeriesName,\n      previousSeriesName,\n      seriesTransformer,\n      colors,\n      ...props\n    } = this.props;\n    const {seriesSelection} = this.state;\n\n    const data = [currentSeriesName ?? t('Current'), previousSeriesName ?? t('Previous')];\n    if (Array.isArray(releaseSeries)) {\n      data.push(t('Releases'));\n    }\n\n    const legend = showLegend\n      ? {\n          right: 16,\n          top: 12,\n          data,\n          selected: seriesSelection,\n          ...(legendOptions ?? {}),\n        }\n      : undefined;\n\n    let series = Array.isArray(releaseSeries)\n      ? [...timeseriesData, ...releaseSeries]\n      : timeseriesData;\n\n    if (seriesTransformer) {\n      series = seriesTransformer(series);\n    }\n\n    const chartOptions = {\n      colors: timeseriesData.length\n        ? colors?.slice(0, series.length) ?? [\n            ...theme.charts.getColorPalette(timeseriesData.length - 2),\n          ]\n        : undefined,\n      grid: {\n        left: '24px',\n        right: '24px',\n        top: '32px',\n        bottom: '12px',\n      },\n      seriesOptions: {\n        showSymbol: false,\n      },\n      tooltip: {\n        trigger: 'axis' as const,\n        truncate: 80,\n        valueFormatter: (value: number) => tooltipFormatter(value, yAxis),\n      },\n      yAxis: {\n        axisLabel: {\n          color: theme.chartLabel,\n          formatter: (value: number) => axisLabelFormatter(value, yAxis),\n        },\n      },\n      ...(chartOptionsProp ?? {}),\n    };\n\n    const Component = this.getChartComponent();\n\n    return (\n      <Component\n        {...props}\n        {...zoomRenderProps}\n        {...chartOptions}\n        legend={legend}\n        onLegendSelectChanged={this.handleLegendSelectChanged}\n        series={series}\n        previousPeriod={previousTimeseriesData ? [previousTimeseriesData] : undefined}\n      />\n    );\n  }\n}\n\ntype Props = {\n  api: Client;\n  router: InjectedRouter;\n  organization: OrganizationSummary;\n  /**\n   * Project ids\n   */\n  projects: number[];\n  /**\n   * Environment condition.\n   */\n  environments: string[];\n  /**\n   * The discover query string to find events with.\n   */\n  query: string;\n  /**\n   * The aggregate/metric to plot.\n   */\n  yAxis: string;\n  /**\n   * Relative datetime expression. eg. 14d\n   */\n  period?: string;\n  /**\n   * Absolute start date.\n   */\n  start: DateString;\n  /**\n   * Absolute end date.\n   */\n  end: DateString;\n  /**\n   * Should datetimes be formatted in UTC?\n   */\n  utc?: boolean | null;\n  /**\n   * Don't show the previous period's data. Will automatically disable\n   * when start/end are used.\n   */\n  disablePrevious?: boolean;\n  /**\n   * Don't show the release marklines.\n   */\n  disableReleases?: boolean;\n  /**\n   * A list of release names to visually emphasize. Can only be used when `disableReleases` is false.\n   */\n  emphasizeReleases?: string[];\n  /**\n   * Fetch n top events as dictated by the field and orderby props.\n   */\n  topEvents?: number;\n  /**\n   * The fields that act as grouping conditions when generating a topEvents chart.\n   */\n  field?: string[];\n  /**\n   * The interval resolution for a chart e.g. 1m, 5m, 1d\n   */\n  interval?: string;\n  /**\n   * Order condition when showing topEvents\n   */\n  orderby?: string;\n  /**\n   * Override the interval calculation and show daily results.\n   */\n  showDaily?: boolean;\n  confirmedQuery?: boolean;\n  /**\n   * Override the default color palette.\n   */\n  colors?: string[];\n  /**\n   * Markup for optional chart header\n   */\n  chartHeader?: React.ReactNode;\n  releaseQueryExtra?: Query;\n  preserveReleaseQueryParams?: boolean;\n} & Pick<\n  ChartProps,\n  | 'currentSeriesName'\n  | 'previousSeriesName'\n  | 'seriesTransformer'\n  | 'showLegend'\n  | 'disableableSeries'\n  | 'legendOptions'\n  | 'chartOptions'\n>;\n\ntype ChartDataProps = {\n  zoomRenderProps: ZoomRenderProps;\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  results?: Series[];\n  timeseriesData?: Series[];\n  previousTimeseriesData?: Series | null;\n  releaseSeries?: Series[];\n};\n\nclass EventsChart extends React.Component<Props> {\n  render() {\n    const {\n      api,\n      period,\n      utc,\n      query,\n      router,\n      start,\n      end,\n      projects,\n      environments,\n      showLegend,\n      yAxis,\n      disablePrevious,\n      disableReleases,\n      emphasizeReleases,\n      currentSeriesName: currentName,\n      previousSeriesName: previousName,\n      seriesTransformer,\n      field,\n      interval,\n      showDaily,\n      topEvents,\n      orderby,\n      confirmedQuery,\n      colors,\n      chartHeader,\n      legendOptions,\n      chartOptions,\n      preserveReleaseQueryParams,\n      releaseQueryExtra,\n      disableableSeries,\n      ...props\n    } = this.props;\n    // Include previous only on relative dates (defaults to relative if no start and end)\n    const includePrevious = !disablePrevious && !start && !end;\n\n    const previousSeriesName =\n      previousName ?? (yAxis ? t('previous %s', yAxis) : undefined);\n    const currentSeriesName = currentName ?? yAxis;\n\n    const intervalVal = showDaily ? '1d' : interval || getInterval(this.props, true);\n\n    let chartImplementation = ({\n      zoomRenderProps,\n      releaseSeries,\n      errored,\n      loading,\n      reloading,\n      results,\n      timeseriesData,\n      previousTimeseriesData,\n    }: ChartDataProps) => {\n      if (errored) {\n        return (\n          <ErrorPanel>\n            <IconWarning color=\"gray300\" size=\"lg\" />\n          </ErrorPanel>\n        );\n      }\n      const seriesData = results ? results : timeseriesData;\n\n      return (\n        <TransitionChart loading={loading} reloading={reloading}>\n          <TransparentLoadingMask visible={reloading} />\n\n          {React.isValidElement(chartHeader) && chartHeader}\n\n          <Chart\n            zoomRenderProps={zoomRenderProps}\n            loading={loading}\n            reloading={reloading}\n            showLegend={showLegend}\n            releaseSeries={releaseSeries || []}\n            timeseriesData={seriesData ?? []}\n            previousTimeseriesData={previousTimeseriesData}\n            currentSeriesName={currentSeriesName}\n            previousSeriesName={previousSeriesName}\n            seriesTransformer={seriesTransformer}\n            stacked={typeof topEvents === 'number' && topEvents > 0}\n            yAxis={yAxis}\n            showDaily={showDaily}\n            colors={colors}\n            legendOptions={legendOptions}\n            chartOptions={chartOptions}\n            disableableSeries={disableableSeries}\n          />\n        </TransitionChart>\n      );\n    };\n\n    if (!disableReleases) {\n      const previousChart = chartImplementation;\n      chartImplementation = chartProps => (\n        <ReleaseSeries\n          utc={utc}\n          period={period}\n          start={start}\n          end={end}\n          projects={projects}\n          environments={environments}\n          emphasizeReleases={emphasizeReleases}\n          preserveQueryParams={preserveReleaseQueryParams}\n          queryExtra={releaseQueryExtra}\n        >\n          {({releaseSeries}) => previousChart({...chartProps, releaseSeries})}\n        </ReleaseSeries>\n      );\n    }\n\n    return (\n      <ChartZoom\n        router={router}\n        period={period}\n        start={start}\n        end={end}\n        utc={utc}\n        {...props}\n      >\n        {zoomRenderProps => (\n          <EventsRequest\n            {...props}\n            api={api}\n            period={period}\n            project={projects}\n            environment={environments}\n            start={start}\n            end={end}\n            interval={intervalVal}\n            query={query}\n            includePrevious={includePrevious}\n            currentSeriesName={currentSeriesName}\n            previousSeriesName={previousSeriesName}\n            yAxis={yAxis}\n            field={field}\n            orderby={orderby}\n            topEvents={topEvents}\n            confirmedQuery={confirmedQuery}\n          >\n            {eventData =>\n              chartImplementation({\n                ...eventData,\n                zoomRenderProps,\n              })\n            }\n          </EventsRequest>\n        )}\n      </ChartZoom>\n    );\n  }\n}\n\nexport default EventsChart;\n"],"sourceRoot":""}