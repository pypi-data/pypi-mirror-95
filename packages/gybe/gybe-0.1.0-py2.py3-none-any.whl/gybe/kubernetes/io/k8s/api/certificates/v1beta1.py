# generated by datamodel-codegen:
#   filename:  _definitions.json
#   timestamp: 2021-01-20T05:35:16+00:00

from __future__ import annotations

from typing import Dict, List, Optional

from pydantic import BaseModel, Field

from ..... import Extra, Kind46, Kind47
from ...apimachinery.pkg.apis.meta import v1


class CertificateSigningRequestSpec(BaseModel):
    extra: Optional[Dict[str, Extra]] = Field(
        None,
        description='Extra information about the requesting user. See user.Info interface for details.',
    )
    groups: Optional[List[str]] = Field(
        None,
        description='Group information about the requesting user. See user.Info interface for details.',
    )
    request: str = Field(..., description='Base64-encoded PKCS#10 CSR data')
    signerName: Optional[str] = Field(
        None,
        description='Requested signer for the request. It is a qualified name in the form: `scope-hostname.io/name`. If empty, it will be defaulted:\n 1. If it\'s a kubelet client certificate, it is assigned\n    "kubernetes.io/kube-apiserver-client-kubelet".\n 2. If it\'s a kubelet serving certificate, it is assigned\n    "kubernetes.io/kubelet-serving".\n 3. Otherwise, it is assigned "kubernetes.io/legacy-unknown".\nDistribution of trust for signers happens out of band. You can select on this field using `spec.signerName`.',
    )
    uid: Optional[str] = Field(
        None,
        description='UID information about the requesting user. See user.Info interface for details.',
    )
    usages: Optional[List[str]] = Field(
        None,
        description='allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3\n     https://tools.ietf.org/html/rfc5280#section-4.2.1.12\nValid values are:\n "signing",\n "digital signature",\n "content commitment",\n "key encipherment",\n "key agreement",\n "data encipherment",\n "cert sign",\n "crl sign",\n "encipher only",\n "decipher only",\n "any",\n "server auth",\n "client auth",\n "code signing",\n "email protection",\n "s/mime",\n "ipsec end system",\n "ipsec tunnel",\n "ipsec user",\n "timestamping",\n "ocsp signing",\n "microsoft sgc",\n "netscape sgc"',
    )
    username: Optional[str] = Field(
        None,
        description='Information about the requesting user. See user.Info interface for details.',
    )


class CertificateSigningRequestCondition(BaseModel):
    lastTransitionTime: Optional[v1.Time] = Field(
        None,
        description="lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.",
    )
    lastUpdateTime: Optional[v1.Time] = Field(
        None, description='timestamp for the last update to this condition'
    )
    message: Optional[str] = Field(
        None, description='human readable message with details about the request state'
    )
    reason: Optional[str] = Field(
        None, description='brief reason for the request state'
    )
    status: Optional[str] = Field(
        None,
        description='Status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be "False" or "Unknown". Defaults to "True". If unset, should be treated as "True".',
    )
    type: str = Field(
        ...,
        description='type of the condition. Known conditions include "Approved", "Denied", and "Failed".',
    )


class CertificateSigningRequestStatus(BaseModel):
    certificate: Optional[str] = Field(
        None,
        description='If request was approved, the controller will place the issued certificate here.',
    )
    conditions: Optional[List[CertificateSigningRequestCondition]] = Field(
        None,
        description='Conditions applied to the request, such as approval or denial.',
    )


class CertificateSigningRequest(BaseModel):
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[Kind46] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[CertificateSigningRequestSpec] = Field(
        None,
        description='The certificate request itself and any additional information.',
    )
    status: Optional[CertificateSigningRequestStatus] = Field(
        None, description='Derived information about the request.'
    )


class CertificateSigningRequestList(BaseModel):
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[CertificateSigningRequest]
    kind: Optional[Kind47] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = None
