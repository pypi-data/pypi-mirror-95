"""scrapli_cfg.platform.core.juniper_junos.base_platform"""
# from typing import Optional, Union
#
# from scrapli.driver import AsyncNetworkDriver, NetworkDriver
# from scrapli.response import Response
# from scrapli_cfg.diff import ScrapliCfgDiff
# from scrapli_cfg.exceptions import (
#     AbortConfigError,
#     CleanupError,
#     CommitConfigError,
#     DiffConfigError,
#     GetConfigError,
#     InvalidConfigTarget,
# )
#
#
# class ScrapliCfgJunosBase:
#     def __init__(
#         self,
#         conn: Union[NetworkDriver, AsyncNetworkDriver],
#     ) -> None:
#         self.config_sources = ("running",)
#         self.on_open_configs = []
#
#         self._in_configuration_session = False
#         self.candidate_config = ""
#
#         self._replace = False
#
#         # ignoring type due to the fact that we can have a sync or an async base class which makes
#         # mypy's head explode w/ absolute rage :)
#         super().__init__(conn=conn)  # type: ignore
#
#     def _pre_get_config(self, source: str) -> str:
#         """
#         Handle pre "get_config" operations for parity between sync and async
#
#         Args:
#             source: name of the config source, generally running|startup
#
#         Returns:
#             str: command to use to fetch the target config source
#
#         Raises:
#             InvalidConfigTarget: if the requested config source is not valid
#
#         """
#         if source not in self.config_sources:
#             raise InvalidConfigTarget
#
#         if self._in_configuration_session:
#             return "run show configuration"
#         return "show configuration"
#
#     @staticmethod
#     def _post_get_config(source: str, config_result: Response) -> str:
#         """
#         Handle post "get_config" operations for parity between sync and async
#
#         Args:
#             source: name of the config source, generally running|startup
#             config_result: scrapli Response object containing fetched config
#
#         Returns:
#             str: desired configuration string
#
#         Raises:
#             GetConfigError: if the config result response indicates failure
#
#         """
#         if config_result.failed:
#             raise GetConfigError(f"failed to get {source} config")
#
#         config: str = config_result.result
#         return config
#
#     def _pre_load_config(self, config: str, replace: bool) -> str:
#         """
#         Handle pre "load_config" operations for parity between sync and async
#
#         Args:
#             config: candidate config to load
#             replace: True/False replace the configuration; passed here so it can be set at the
#                 class level as we need to stay in config mode and we need to know if we are doing
#                 a merge or a replace when we go to diff things
#
#         Returns:
#             str: string of config to write to candidate config file
#
#         Raises:
#             N/A
#
#         """
#         self.candidate_config = config
#
#         configure_mode = "patch"
#         if replace:
#             configure_mode = "override"
#
#         load_command = f"load {configure_mode} terminal"
#         end_command = "\x04"
#
#         config_to_send = f"{load_command}\n{config}\n{end_command}"
#
#         self._in_configuration_session = True
#         self._replace = replace
#
#         return config_to_send
#
#     def _pre_diff_config(self) -> None:
#         """
#         Handle pre "load_config" operations for parity between sync and async
#
#         Args:
#             N/A
#
#         Returns:
#             str: command to use to diff the configuration
#
#         Raises:
#             DiffConfigError: if no config session exists then we have no config to diff!
#
#         """
#         if not self.candidate_config_filename:
#             raise DiffConfigError(
#                 "no candidate configuration exists, you must load a config in order to diff it!"
#             )
#
#     def _post_diff_config(
#         self, host: str, source: str, source_config: str, device_diff: str
#     ) -> ScrapliCfgDiff:
#         """
#         Handle post "diff_config" operations for parity between sync and async
#
#         Args:
#             host: host the connection is operating against
#             source: name of the source config store
#             source_config: current config of the source config store
#             device_diff: diff generated by the device (if any)
#
#         Returns:
#             ScrapliCfgDiff: scrapli cfg diff object
#
#         Raises:
#             N/A
#
#         """
#         # TODO dunno what needs to happen here for juniper yet
#         # source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl="")
#         source_config = "\n".join(line for line in source_config.splitlines() if line)
#         candidate_config = re.sub(pattern=CHECKPOINT_LINE, string=self.candidate_config, repl="")
#         candidate_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=candidate_config, repl="")
#         candidate_config = "\n".join(line for line in self.candidate_config.splitlines() if line)
#
#         diff = ScrapliCfgDiff(
#             host=host,
#             source=source,
#             source_config=source_config,
#             candidate_config=candidate_config,
#             device_diff=device_diff,
#         )
#         return diff
#
#     def _pre_abort_config(self) -> None:
#         """
#         Handle pre "abort_config" operations for parity between sync and async
#
#         Args:
#             N/A
#
#         Returns:
#             None
#
#         Raises:
#             AbortConfigError: if no config session exists then we have no config to abort!
#
#         """
#         if not self.candidate_config:
#             raise AbortConfigError(
#                 "no candidate configuration filename exists, you must load a config in order to "
#                 "abort it!"
#             )
#
#     def _post_abort_config(self) -> None:
#         """
#         Handle post "abort_config" operations for parity between sync and async
#
#         Args:
#             N/A
#
#         Returns:
#             None
#
#         Raises:
#             AbortConfigError: if the config session abort operation failed
#
#         """
#         self.candidate_config = ""
#         self._in_configuration_session = False
#
#     def _pre_commit_config(self) -> None:
#         """
#         Handle pre "commit_config" operations for parity between sync and async
#
#         Args:
#             N/A
#
#         Returns:
#             None
#
#         Raises:
#             CommitConfigError: if no config session exists then we have no config to commit!
#
#         """
#         if not self.candidate_config_filename:
#             raise CommitConfigError(
#                 "no candidate configuration filename exists, you must load a config in order to "
#                 "commit it!"
#             )
#
#     def _post_commit_config(
#         self, commit_result: Response, cleanup_result: Optional[Response]
#     ) -> None:
#         """
#         Handle post "commit_config" operations for parity between sync and async
#
#         Args:
#             commit_result: scrapli Response object from committing the config session
#             cleanup_result: optional result of cleanup (remove candidate config) operation
#
#         Returns:
#             None
#
#         Raises:
#             CommitConfigError: if the config session abort operation failed
#
#         """
#         self.candidate_config = ""
#         self.candidate_config_filename = ""
#
#         if commit_result.failed:
#             raise CommitConfigError("failed to commit config session")
#
#         if isinstance(cleanup_result, Response) and cleanup_result.failed:
#             raise CleanupError("failed to cleanup candidate config on device filesystem")
#
#     def _prepare_config_payloads(self, config: str) -> str:
#         """
#         Prepare a configuration so it can be nicely sent to the device via scrapli
#
#         Args:
#             config: configuration to prep
#
#         Returns:
#             str: string of config lines to write to candidate config file
#
#         Raises:
#             N/A
#
#         """
#         # with the "normal" method (the way iosxe does this) it seems to want to stop at 250ish
#         # lines... so this works but its kinda wonky... the actual lines we want to put in the txt
#         # file are enclosed in curly braces for tcl-reasons i guess
#         tclsh_filesystem = f"/{self.filesystem.strip(':')}/"
#         tclsh_start_file = (
#           f'set fl [open "{tclsh_filesystem}{self.candidate_config_filename}" wb+]'
#         )
#         tcl_config = "\n".join(
#             [f"puts -nonewline $fl {{{line}\r}}" for line in config.splitlines()]
#         )
#         tclsh_end_file = "close $fl"
#         final_config = "\n".join((tclsh_start_file, tcl_config, tclsh_end_file))
#
#         return final_config
