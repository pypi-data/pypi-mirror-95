# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['map_dict_ex', 'batch_sz', 'UnCollatable', 'D']

# Cell
# Python native modules
import os
# Third party libs
from fastcore.all import *
from fastai.torch_core import *
from fastai.basics import *
import pandas as pd
# Local modules

# Cell
def map_dict_ex(d,f,*args,gen=False,wise=None,**kwargs):
    "Like `map`, but for dicts and uses `bind`, and supports `str` and indexing"
    g = (bind(f,*args,**kwargs) if callable(f)
         else f.format if isinstance(f,str)
         else f.__getitem__)

    if wise is None:  return map(g,d.items())
    return ((k,g(v)) if wise=='value' else (g(k),v) for k,v in d.items())

# Cell
def batch_sz(arr):
    if isinstance(arr,np.ndarray): return v.shape[0]
    elif isinstance(v,Tensor):     return v.size()[0]
    return None

class UnCollatable(Exception):
    def __init__(self,message='',collate_elements:dict=None,reasons:str=None):
        store_attr()
        self.reasons=reasons.split(',')
        self.msg=''
        if 'nones' in reasons: self.msg+='These '

    def __str__(self):
        return f'The value of %s'%self.message

class D(dict):
    def _new(self,*args,**kwargs): return type(self)(*args,**kwargs)
    def filter(self,f=noop,negate=False,gen=False, **kwargs):
        return self._new(filter_ex(self,f=f,negate=negate,gen=gen,**kwargs))

    def map(self,f,*args,gen=False,**kwargs):
        return (self._new,noop)[gen](map_dict_ex(self,f,*args,**kwargs))
    def mapk(self,f,*args,gen=False,wise='key',**kwargs):
        return self.map(f,*args,gen=gen,wise=wise,**kwargs)
    def mapv(self,f,*args,gen=False,wise='value',**kwargs):
        return self.map(f,*args,gen=gen,wise=wise,**kwargs)

    def bs(self):
        bs_map=self.mapv(batch_sz)
        if any([self.mapv(isnone).values()]): raise UnCollatable(bs_map,'nones')

    def pandas(self):
        d=deepcopy(self)
        items=list(d.items())
        for k,v in items:
            if hasattr(v,'mean'): d[f'{k}_mu']=v.mean(axis=1)
            bs=batch_sz(v)
            if isinstance(v,np.ndarray): d[k]=np.array([v.shape]*bs)
            if isinstance(v,Tensor):     d[k]=Tensor([v.size()]*bs)
        return pd.DataFrame(d)