# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2021-02-04T17:57:27+00:00

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, Iterator, List, Mapping, Optional, Sequence, Union
from uuid import UUID

from pydantic import EmailStr, Extra, Field

from kelvin.sdk.client.data_model import DataModelBase, PaginatorDataModel
from kelvin.sdk.client.utils import instance_classmethod

from . import Logs, Type1, pagination, requests


class ACP(DataModelBase):
    """
    ACP object.

    Parameters
    ----------
    cluster_name: Optional[str]
    created: Optional[datetime]
    kelvin_info: Optional[Dict[str, Any]]
    manifests_scrape_enabled: Optional[bool]
    manifests_scrape_interval: Optional[int]
    metadata: Optional[Dict[str, Any]]
    metrics_enabled: Optional[bool]
    metrics_scrape_interval: Optional[int]
    name: Optional[str]
    network_info: Optional[Dict[str, Any]]
    node_name: Optional[str]
    status_scrape_enabled: Optional[bool]
    status_scrape_interval: Optional[int]
    system_info: Optional[Dict[str, Any]]
    title: Optional[str]
    updated: Optional[datetime]

    """

    cluster_name: Optional[str] = None
    created: Optional[datetime] = None
    kelvin_info: Optional[Dict[str, Any]] = None
    manifests_scrape_enabled: Optional[bool] = None
    manifests_scrape_interval: Optional[int] = None
    metadata: Optional[Dict[str, Any]] = None
    metrics_enabled: Optional[bool] = None
    metrics_scrape_interval: Optional[int] = None
    name: Optional[str] = Field(None, max_length=64)
    network_info: Optional[Dict[str, Any]] = None
    node_name: Optional[str] = None
    status_scrape_enabled: Optional[bool] = None
    status_scrape_interval: Optional[int] = None
    system_info: Optional[Dict[str, Any]] = None
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def list_acp(
        self_or_cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACP], ACPListPaginated]:
        """
        List ACP

        **Pagination Key:** `acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACP``: ``GET`` ``/api/v4/acps/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter ACPs by name
        search : :obj:`Sequence[str]`
            Search ACP by name or title
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/list",
            {},
            {
                "names": names,
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_acp_metadata_bulk(
        cls,
        data: Optional[Union[requests.ACPMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create ACP Metadata Bulk

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createACPMetadataBulk``: ``POST`` ``/api/v4/acps/metadata/create``

        Parameters
        ----------
        data: requests.ACPMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/acps/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ACPMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_acp_metadata_bulk(
        cls,
        data: Optional[Union[requests.ACPMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete ACP Metadata Bulk

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteACPMetadataBulk``: ``POST`` ``/api/v4/acps/metadata/delete``

        Parameters
        ----------
        data: requests.ACPMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/acps/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ACPMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_acp_status(
        cls,
        acp_names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        source: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACPStatus], ACPStatusListPaginated]:
        """
        List ACP Status

        **Pagination Key:** `acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACPStatus``: ``GET`` ``/api/v4/acps/status/list``

        Parameters
        ----------
        acp_names : :obj:`Sequence[str]`
            Filter by ACP names
        search : :obj:`Sequence[str]`
            Search ACPs by title and name
        source : :obj:`str`
            Source should be `cache` or `live`. Default: `cache`
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/acps/status/list",
            {},
            {
                "acp_names": acp_names,
                "search": search,
                "source": source,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def delete_acp(self_or_cls, acp_name: str, dry_run: bool = False, client: Any = None) -> None:
        """
        Delete ACP

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteACP``: ``POST`` ``/api/v4/acps/{acp_name}/delete``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/delete",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def force_update_acp_edge_app_version(
        self_or_cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Force Update ACP Edge App Version

        **Permission Required:** `kelvin.permission.acp.read`.

        ``forceUpdateACPEdgeAppVersion``: ``POST`` ``/api/v4/acps/{acp_name}/edge-apps/version/force-update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/edge-apps/version/force-update",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def get_acp_edge_app_version(
        self_or_cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> ACPEdgeAppVersion:
        """
        Get ACP Edge App Version

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPEdgeAppVersion``: ``GET`` ``/api/v4/acps/{acp_name}/edge-apps/version/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/edge-apps/version/get",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ACPEdgeAppVersion,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def get_acp(
        self_or_cls,
        acp_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ACP:
        """
        Get ACP

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACP``: ``GET`` ``/api/v4/acps/{acp_name}/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/get",
            {"acp_name": acp_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ACP, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def create_acp_metadata(
        self_or_cls,
        acp_name: str,
        data: Optional[Union[requests.ACPMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Create ACP Metadata

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/create``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/create",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataCreate,
            False,
            {"201": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def list_acp_metadata(
        self_or_cls,
        acp_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACPMetaDataItem], ACPMetadataListPaginated]:
        """
        List ACP Metadata

        **Pagination Key:** `acp_metadata_name,acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/list``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        search : :obj:`Sequence[str]`
            Search ACP Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/list",
            {"acp_name": acp_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def delete_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete ACP Metadata

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def get_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ACPMetadata:
        """
        Get ACP Metadata

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def update_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        data: Optional[Union[requests.ACPMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Update ACP Metadata

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name
        data: requests.ACPMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataUpdate,
            False,
            {
                "200": ACPMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def get_acp_metrics(
        self_or_cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> ACPMetrics:
        """
        Get ACP Metrics

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPMetrics``: ``GET`` ``/api/v4/acps/{acp_name}/metrics/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metrics/get",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetrics, "400": ErrorMessages, "401": ErrorMessages, "500": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def get_acp_status(
        self_or_cls,
        acp_name: str,
        source: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ACPStatus:
        """
        Get ACP Status

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPStatus``: ``GET`` ``/api/v4/acps/{acp_name}/status/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        source : :obj:`str`
            Source should be `cache` or `live`. Default: `cache`

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/status/get",
            {"acp_name": acp_name},
            {"source": source},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPStatus, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def update_acp_status(
        self_or_cls,
        acp_name: str,
        data: Optional[Union[requests.ACPStatusUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPStatus:
        """
        Update ACP Status

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACPStatus``: ``POST`` ``/api/v4/acps/{acp_name}/status/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPStatusUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPStatusUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/status/update",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPStatusUpdate,
            False,
            {"200": ACPStatus, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_name": "name"})
    def update_acp(
        self_or_cls,
        acp_name: str,
        data: Optional[Union[requests.ACPUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACP:
        """
        Update ACP

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACP``: ``POST`` ``/api/v4/acps/{acp_name}/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/update",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPUpdate,
            False,
            {
                "200": ACP,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ACPAllocation(DataModelBase):
    """
    ACPAllocation object.

    Parameters
    ----------
    cpu_capacity: Optional[float]
    cpu_requests: Optional[float]
    memory_capacity: Optional[float]
    memory_requests: Optional[float]

    """

    cpu_capacity: Optional[float] = None
    cpu_requests: Optional[float] = None
    memory_capacity: Optional[float] = None
    memory_requests: Optional[float] = None


class ACPCPUUtilization(DataModelBase):
    """
    ACPCPUUtilization object.

    Parameters
    ----------
    timestamp: Optional[int]
    value: Optional[float]

    """

    timestamp: Optional[int] = None
    value: Optional[float] = None


class ACPDisk(DataModelBase):
    """
    ACPDisk object.

    Parameters
    ----------
    total_bytes: Optional[float]
    used_bytes: Optional[float]

    """

    total_bytes: Optional[float] = None
    used_bytes: Optional[float] = None


class ACPEdgeAppVersion(DataModelBase):
    """
    ACPEdgeAppVersion object.

    Parameters
    ----------
    edge_app_version: Optional[str]
    has_updates: Optional[bool]
    platform_version: Optional[str]

    """

    edge_app_version: Optional[str] = None
    has_updates: Optional[bool] = None
    platform_version: Optional[str] = None

    @classmethod
    def force_update_acp_edge_app_version(
        cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Force Update ACP Edge App Version

        **Permission Required:** `kelvin.permission.acp.read`.

        ``forceUpdateACPEdgeAppVersion``: ``POST`` ``/api/v4/acps/{acp_name}/edge-apps/version/force-update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/edge-apps/version/force-update",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_acp_edge_app_version(
        cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> ACPEdgeAppVersion:
        """
        Get ACP Edge App Version

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPEdgeAppVersion``: ``GET`` ``/api/v4/acps/{acp_name}/edge-apps/version/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/edge-apps/version/get",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ACPEdgeAppVersion,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result


class ACPListPaginated(PaginatorDataModel[ACP]):
    """
    ACPListPaginated object.

    Parameters
    ----------
    data: Optional[List[ACP]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ACP]] = None
    pagination: Optional[pagination.Pagination] = None


class ACPMemoryUsage(DataModelBase):
    """
    ACPMemoryUsage object.

    Parameters
    ----------
    timestamp: Optional[int]
    value: Optional[float]

    """

    timestamp: Optional[int] = None
    value: Optional[float] = None


class ACPMetaDataItem(DataModelBase):
    """
    ACPMetaDataItem object.

    Parameters
    ----------
    acp_name: Optional[str]
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]

    """

    acp_name: Optional[str] = None
    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_acp_metadata(
        self_or_cls,
        acp_name: str,
        data: Optional[Union[requests.ACPMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Create ACP Metadata

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/create``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/create",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataCreate,
            False,
            {"201": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_acp_metadata(
        self_or_cls,
        acp_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACPMetaDataItem], ACPMetadataListPaginated]:
        """
        List ACP Metadata

        **Pagination Key:** `acp_metadata_name,acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/list``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        search : :obj:`Sequence[str]`
            Search ACP Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/list",
            {"acp_name": acp_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete ACP Metadata

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ACPMetadata:
        """
        Get ACP Metadata

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        data: Optional[Union[requests.ACPMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Update ACP Metadata

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name
        data: requests.ACPMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataUpdate,
            False,
            {
                "200": ACPMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ACPMetadata(DataModelBase):
    """
    ACPMetadata object.

    Parameters
    ----------
    acp_name: Optional[str]
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]

    """

    acp_name: Optional[str] = None
    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_acp_metadata(
        self_or_cls,
        acp_name: str,
        data: Optional[Union[requests.ACPMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Create ACP Metadata

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/create``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/create",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataCreate,
            False,
            {"201": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_acp_metadata(
        self_or_cls,
        acp_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACPMetaDataItem], ACPMetadataListPaginated]:
        """
        List ACP Metadata

        **Pagination Key:** `acp_metadata_name,acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/list``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        search : :obj:`Sequence[str]`
            Search ACP Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/list",
            {"acp_name": acp_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"acp_metadata_name": "name"})
    def delete_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete ACP Metadata

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/delete",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_metadata_name": "name"})
    def get_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ACPMetadata:
        """
        Get ACP Metadata

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPMetadata``: ``GET`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/get",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"acp_metadata_name": "name"})
    def update_acp_metadata(
        self_or_cls,
        acp_name: str,
        acp_metadata_name: str,
        data: Optional[Union[requests.ACPMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPMetadata:
        """
        Update ACP Metadata

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACPMetadata``: ``POST`` ``/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        acp_metadata_name : :obj:`str`, optional
            ACP Metadata name
        data: requests.ACPMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/metadata/{acp_metadata_name}/update",
            {"acp_name": acp_name, "acp_metadata_name": acp_metadata_name},
            {},
            {},
            {},
            data,
            requests.ACPMetadataUpdate,
            False,
            {
                "200": ACPMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ACPMetadataListPaginated(PaginatorDataModel[ACPMetaDataItem]):
    """
    ACPMetadataListPaginated object.

    Parameters
    ----------
    data: Optional[List[ACPMetaDataItem]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ACPMetaDataItem]] = None
    pagination: Optional[pagination.Pagination] = None


class ACPNetwork(DataModelBase):
    """
    ACPNetwork object.

    Parameters
    ----------
    total_rx: Optional[float]
    total_tx: Optional[float]

    """

    total_rx: Optional[float] = None
    total_tx: Optional[float] = None


class ACPSettingsAutoUpdate(DataModelBase):
    """
    ACPSettingsAutoUpdate object.

    Parameters
    ----------
    enabled: Optional[bool]
    interval: Optional[int]

    """

    enabled: Optional[bool] = None
    interval: Optional[int] = None


class ACPSettingsMetrics(DataModelBase):
    """
    ACPSettingsMetrics object.

    Parameters
    ----------
    enabled: Optional[bool]
    interval: Optional[int]

    """

    enabled: Optional[bool] = None
    interval: Optional[int] = None


class ACPSettingsStatus(DataModelBase):
    """
    ACPSettingsStatus object.

    Parameters
    ----------
    enabled: Optional[bool]
    interval: Optional[int]

    """

    enabled: Optional[bool] = None
    interval: Optional[int] = None


class ACPStatusValues(DataModelBase):
    """
    ACPStatusValues object.

    Parameters
    ----------
    last_seen: Optional[datetime]
    message: Optional[str]
    state: Optional[str]
    warnings: Optional[List[str]]

    """

    last_seen: Optional[datetime] = None
    message: Optional[str] = None
    state: Optional[str] = None
    warnings: Optional[List[str]] = None


class AppVersion(DataModelBase):
    """
    AppVersion object.

    Parameters
    ----------
    created: Optional[datetime]
    id: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]
    version: Optional[str]

    """

    created: Optional[datetime] = None
    id: Optional[str] = None
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None
    version: Optional[str] = None

    @classmethod
    def delete_app_version(
        cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete App Version

        **Note:** This operation also deletes the associated Docker Image

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/delete",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def download_app_version(
        cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Download App Version


        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``downloadAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/download``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/download",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_app_version(
        cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> AppVersion:
        """
        Get App Version

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersion, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_app_version_status(
        cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> AppVersionStatus:
        """
        Get App Version Status

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersionStatus``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/status/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/status/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersionStatus, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def upload_app_version(
        cls, app_name: str, app_version: str, file: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Upload App Version


        **Permission Required:** `kelvin.permission.appregistry.create`.

        ``uploadAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/upload``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version
        file : :obj:`str`, optional
            File to upload

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/upload",
            {"app_name": app_name, "app_version": app_version},
            {},
            {"file": file},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result


class AppVersionStatus(DataModelBase):
    """
    AppVersionStatus object.

    Parameters
    ----------
    build_log: Optional[str]
    id: Optional[str]
    name: Optional[str]
    status: Optional[str]
    version: Optional[str]

    """

    build_log: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    status: Optional[str] = None
    version: Optional[str] = None

    @classmethod
    def list_app_version_status(
        cls,
        app_versions: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[AppVersionStatus], AppVersionStatusListPaginated]:
        """
        List App Version Status

        **Pagination Key:** `app_version_id`

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``listAppVersionStatus``: ``GET`` ``/api/v4/appregistry/versions/status/list``

        Parameters
        ----------
        app_versions : :obj:`Sequence[str]`
            Filter by App Versions. Pattern: `<app_name>:<version>`
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/versions/status/list",
            {},
            {
                "app_versions": app_versions,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersionStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_app_version_status(
        cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> AppVersionStatus:
        """
        Get App Version Status

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersionStatus``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/status/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/status/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersionStatus, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result


class AppVersionStatusListPaginated(PaginatorDataModel[AppVersionStatus]):
    """
    AppVersionStatusListPaginated object.

    Parameters
    ----------
    data: Optional[List[AppVersionStatus]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[AppVersionStatus]] = None
    pagination: Optional[pagination.Pagination] = None


class AuditLogger(DataModelBase):
    """
    AuditLogger object.

    Parameters
    ----------
    action: Optional[str]
    created: Optional[datetime]
    id: Optional[int]
    identifier: Optional[str]
    meta: Optional[Dict[str, Any]]
    namespace: Optional[str]
    request_id: Optional[str]
    user_id: Optional[str]
    username: Optional[str]

    """

    action: Optional[str] = None
    created: Optional[datetime] = None
    id: Optional[int] = None
    identifier: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
    namespace: Optional[str] = None
    request_id: Optional[str] = None
    user_id: Optional[str] = None
    username: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def list_audit_log(
        self_or_cls,
        action: Optional[Sequence[str]] = None,
        user_id: Optional[Sequence[str]] = None,
        namespace: Optional[Sequence[str]] = None,
        identifier: Optional[Sequence[str]] = None,
        username: Optional[Sequence[str]] = None,
        request_id: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        from_date_time: Optional[str] = None,
        to_date_time: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[AuditLogger], AuditLoggerListPaginated]:
        """
        List Audit Log

        **Note:** Both `from_date_time` and `to_date_time` support RFC3339 format with microseconds

        **Pagination Key:** `audit_log_id`

        **Permission Required:** `kelvin.permission.audit_log.read`.

        ``listAuditLog``: ``GET`` ``/api/v4/instance/auditlog/list``

        Parameters
        ----------
        action : :obj:`Sequence[str]`
            Filter by action
        user_id : :obj:`Sequence[str]`
            Filter by user_id
        namespace : :obj:`Sequence[str]`
            Filter by namespace
        identifier : :obj:`Sequence[str]`
            Filter by identifier
        username : :obj:`Sequence[str]`
            Filter by username
        request_id : :obj:`Sequence[str]`
            Filter by request_id
        search : :obj:`Sequence[str]`
            Search Audit Log by action, username or namespace
        from_date_time : :obj:`str`
            Filter actions occurred at or after this date-time
        to_date_time : :obj:`str`
            Filter actions occurred until or at this date-time
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/instance/auditlog/list",
            {},
            {
                "action": action,
                "user_id": user_id,
                "namespace": namespace,
                "identifier": identifier,
                "username": username,
                "request_id": request_id,
                "search": search,
                "from_date_time": from_date_time,
                "to_date_time": to_date_time,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AuditLoggerListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"audit_logger_id": "id"})
    def get_audit_log(
        self_or_cls, audit_logger_id: str, dry_run: bool = False, client: Any = None
    ) -> AuditLogger:
        """
        Get Audit Log

        **Permission Required:** `kelvin.permission.audit_log.read`.

        ``getAuditLog``: ``GET`` ``/api/v4/instance/auditlog/{audit_logger_id}/get``

        Parameters
        ----------
        audit_logger_id : :obj:`str`, optional
            Audit Logger ID

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/instance/auditlog/{audit_logger_id}/get",
            {"audit_logger_id": audit_logger_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AuditLogger, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class AuditLoggerListPaginated(PaginatorDataModel[AuditLogger]):
    """
    AuditLoggerListPaginated object.

    Parameters
    ----------
    data: Optional[List[AuditLogger]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[AuditLogger]] = None
    pagination: Optional[pagination.Pagination] = None


class ClusterCIDR(DataModelBase):
    """
    ClusterCIDR object.

    Parameters
    ----------
    pod_cidr: Optional[str]
    service_cidr: Optional[str]

    """

    pod_cidr: Optional[str] = None
    service_cidr: Optional[str] = None


class ClusterCIDRItem(DataModelBase):
    """
    ClusterCIDRItem object.

    Parameters
    ----------
    cluster_name: Optional[str]
    created: Optional[datetime]
    kube_pod_cidr: Optional[str]
    kube_service_cidr: Optional[str]
    updated: Optional[datetime]

    """

    cluster_name: Optional[str] = None
    created: Optional[datetime] = None
    kube_pod_cidr: Optional[str] = None
    kube_service_cidr: Optional[str] = None
    updated: Optional[datetime] = None

    @classmethod
    def list_cluster_cidr(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ClusterCIDRItem], ClusterCIDRListPaginated]:
        """
        List Cluster CIDR

        **Pagination Key:** `kube_pod_cidr,kube_service_cidr`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listClusterCIDR``: ``GET`` ``/api/v4/orchestration/cidr/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search CIDR by Kubernetes Pod IP, Kubernetes Service IP or Cluster
            Name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/cidr/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ClusterCIDRListPaginated, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result


class ClusterCIDRListPaginated(PaginatorDataModel[ClusterCIDRItem]):
    """
    ClusterCIDRListPaginated object.

    Parameters
    ----------
    data: Optional[List[ClusterCIDRItem]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ClusterCIDRItem]] = None
    pagination: Optional[pagination.Pagination] = None


class ClusterManifestItem(DataModelBase):
    """
    ClusterManifestItem object.

    Parameters
    ----------
    content: Optional[str]
    file_name: Optional[str]

    """

    content: Optional[str] = None
    file_name: Optional[str] = None


class ClusterManifestList(DataModelBase):
    """
    ClusterManifestList object.

    Parameters
    ----------
    manifests: Optional[List[ClusterManifestItem]]
    revision: Optional[str]

    """

    manifests: Optional[List[ClusterManifestItem]] = None
    revision: Optional[str] = None

    @classmethod
    def get_cluster_manifests(
        cls,
        cluster_name: str,
        version: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ClusterManifestList:
        """
        Get Cluster Manifests

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getClusterManifests``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/manifests/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        version : :obj:`str`
            Current Version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/manifests/get",
            {"cluster_name": cluster_name},
            {"version": version},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ClusterManifestList,
                "204": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result


class ComponentStatus(DataModelBase):
    """
    ComponentStatus object.

    Parameters
    ----------
    name: Optional[str]
    status: Optional[bool]

    """

    name: Optional[str] = None
    status: Optional[bool] = None


class DataLabelCluster(DataModelBase):
    """
    DataLabelCluster object.

    Parameters
    ----------
    count: Optional[int]
    end_date: Optional[datetime]
    label_names: Optional[List[str]]
    start_date: Optional[datetime]

    """

    count: Optional[int] = None
    end_date: Optional[datetime] = None
    label_names: Optional[List[str]] = None
    start_date: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def get_data_labels_clustering(
        self_or_cls,
        data: Optional[Union[requests.DataLabelCluster, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> DataLabelCluster:
        """
        Get Data Labels Clustering

        **Note**:
        * `time_bucket`: needed to aggregate a cluster. Use Go parsing for duration:
        https://golang.org/pkg/time/#ParseDuration
        * `label_names`: lists data labels using **OR** operator;
        * `metrics`: lists data labels using **OR** operator;
        * `start_date`: lists data labels with start_date >= query date (RFC3339 format with microseconds);
        * `end_date`: lists data labels with end_date <= query date (RFC3339 format with microseconds)

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getDataLabelsClustering``: ``POST`` ``/api/v4/datalabels/clustering/get``

        Parameters
        ----------
        data: requests.DataLabelCluster, optional
        **kwargs:
            Extra parameters for requests.DataLabelCluster

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/clustering/get",
            {},
            {},
            {},
            {},
            data,
            requests.DataLabelCluster,
            False,
            {"200": DataLabelCluster, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result


class DataLabelMetricItem(DataModelBase):
    """
    DataLabelMetricItem object.

    Parameters
    ----------
    acp_name: Optional[str]
    key: Optional[str]
    source: Optional[str]
    type: Optional[str]

    """

    acp_name: Optional[str] = None
    key: Optional[str] = None
    source: Optional[str] = None
    type: Optional[str] = None


class DataLabelSource(DataModelBase):
    """
    DataLabelSource object.

    Parameters
    ----------
    info: Optional[Dict[str, Any]]
    type: Optional[Type1]

    """

    info: Optional[Dict[str, Any]] = None
    type: Optional[Type1] = None


class DataModelSchema(DataModelBase):
    """
    DataModelSchema object.

    Parameters
    ----------

    """

    class Config(DataModelBase.Config):
        extra = Extra.allow

    @classmethod
    def get_data_model_schema(
        cls,
        data_model_name: str,
        data_model_version: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> DataModelSchema:
        """
        Get Data Model Schema

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``getDataModelSchema``: ``GET`` ``/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/schema/get``

        Parameters
        ----------
        data_model_name : :obj:`str`, optional
            Data Model name
        data_model_version : :obj:`str`, optional
            Data Model version

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/schema/get",
            {"data_model_name": data_model_name, "data_model_version": data_model_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataModelSchema,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result


class ErrorMessage(DataModelBase):
    """
    ErrorMessage object.

    Parameters
    ----------
    error_code: Optional[int]
    http_status_code: Optional[int]
    message: Optional[List[str]]

    """

    error_code: Optional[int] = None
    http_status_code: Optional[int] = Field(None, example=400)
    message: Optional[List[str]] = None


class ErrorMessages(DataModelBase):
    """
    ErrorMessages object.

    Parameters
    ----------
    errors: Optional[List[ErrorMessage]]

    """

    errors: Optional[List[ErrorMessage]] = None


class ICDField(DataModelBase):
    """
    ICDField object.

    Parameters
    ----------
    array: Optional[bool]
    description: Optional[str]
    name: Optional[str]
    type: Optional[str]

    """

    array: Optional[bool] = None
    description: Optional[str] = None
    name: Optional[str] = None
    type: Optional[str] = None


class ICDPayload(DataModelBase):
    """
    ICDPayload object.

    Parameters
    ----------
    class_name: Optional[str]
    description: Optional[str]
    fields: Optional[List[ICDField]]
    name: Optional[str]
    version: Optional[str]

    """

    class_name: Optional[str] = None
    description: Optional[str] = None
    fields: Optional[List[ICDField]] = None
    name: Optional[str] = None
    version: Optional[str] = None


class InstanceHealthStatus(DataModelBase):
    """
    InstanceHealthStatus object.

    Parameters
    ----------
    components: Optional[List[ComponentStatus]]
    status: Optional[bool]

    """

    components: Optional[List[ComponentStatus]] = None
    status: Optional[bool] = None

    @classmethod
    def get_instance_health_status(
        cls, dry_run: bool = False, client: Any = None
    ) -> InstanceHealthStatus:
        """
        Get Instance Health Status

        **Permission Required:** `n/a`.

        ``getInstanceHealthStatus``: ``GET`` ``/api/v4/instance/status/get``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/instance/status/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"201": InstanceHealthStatus, "400": ErrorMessages},
            False,
            dry_run,
        )
        return result


class Label(DataModelBase):
    """
    Label object.

    Parameters
    ----------
    created: Optional[datetime]
    metadata: Optional[Dict[str, Any]]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    name: Optional[str] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_label(
        self_or_cls,
        data: Optional[Union[requests.LabelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Label:
        """
        Create Label

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabel``: ``POST`` ``/api/v4/datalabels/labels/create``

        Parameters
        ----------
        data: requests.LabelCreate, optional
        **kwargs:
            Extra parameters for requests.LabelCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/create",
            {},
            {},
            {},
            {},
            data,
            requests.LabelCreate,
            False,
            {"201": Label, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_label(
        self_or_cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[Label], LabelListPaginated]:
        """
        List Label

        **Pagination Key:** `label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listLabel``: ``GET`` ``/api/v4/datalabels/labels/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter labels by name
        search : :obj:`Sequence[str]`
            Search Labels by name or title
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/list",
            {},
            {
                "names": names,
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": LabelListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_label_metadata_bulk(
        cls,
        data: Optional[Union[requests.LabelMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Label Metadata Bulk

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabelMetadataBulk``: ``POST`` ``/api/v4/datalabels/labels/metadata/create``

        Parameters
        ----------
        data: requests.LabelMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.LabelMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_label_metadata_bulk(
        cls,
        data: Optional[Union[requests.LabelMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Label Metadata Bulk

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabelMetadataBulk``: ``POST`` ``/api/v4/datalabels/labels/metadata/delete``

        Parameters
        ----------
        data: requests.LabelMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.LabelMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def delete_label(
        self_or_cls, label_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete Label

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabel``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/delete``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/delete",
            {"label_name": label_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def get_label(
        self_or_cls,
        label_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> Label:
        """
        Get Label

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getLabel``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/get``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/get",
            {"label_name": label_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": Label, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def create_label_metadata(
        self_or_cls,
        label_name: str,
        data: Optional[Union[requests.LabelMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Create Label Metadata

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/create``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        data: requests.LabelMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/create",
            {"label_name": label_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataCreate,
            False,
            {
                "201": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def list_label_metadata(
        self_or_cls,
        label_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[LabelMetadata], LabelMetadataListPaginated]:
        """
        List Label Metadata

        **Pagination Key:** `label_metadata_name,label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/list``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        search : :obj:`Sequence[str]`
            Search Label Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/list",
            {"label_name": label_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": LabelMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def delete_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete Label Metadata

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def get_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> LabelMetadata:
        """
        Get Label Metadata

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def update_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        data: Optional[Union[requests.LabelMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Update Label Metadata

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name
        data: requests.LabelMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataUpdate,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_name": "name"})
    def update_label(
        self_or_cls,
        label_name: str,
        data: Optional[Union[requests.LabelUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Label:
        """
        Update Label

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateLabel``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/update``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        data: requests.LabelUpdate, optional
        **kwargs:
            Extra parameters for requests.LabelUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/update",
            {"label_name": label_name},
            {},
            {},
            {},
            data,
            requests.LabelUpdate,
            False,
            {
                "200": Label,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class LabelListPaginated(PaginatorDataModel[Label]):
    """
    LabelListPaginated object.

    Parameters
    ----------
    data: Optional[List[Label]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[Label]] = None
    pagination: Optional[pagination.Pagination] = None


class LabelMetadata(DataModelBase):
    """
    LabelMetadata object.

    Parameters
    ----------
    created: Optional[datetime]
    label_name: Optional[str]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    label_name: Optional[str] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_label_metadata(
        self_or_cls,
        label_name: str,
        data: Optional[Union[requests.LabelMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Create Label Metadata

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/create``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        data: requests.LabelMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/create",
            {"label_name": label_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataCreate,
            False,
            {
                "201": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_label_metadata(
        self_or_cls,
        label_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[LabelMetadata], LabelMetadataListPaginated]:
        """
        List Label Metadata

        **Pagination Key:** `label_metadata_name,label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/list``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        search : :obj:`Sequence[str]`
            Search Label Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/list",
            {"label_name": label_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": LabelMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"label_metadata_name": "name"})
    def delete_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete Label Metadata

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_metadata_name": "name"})
    def get_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> LabelMetadata:
        """
        Get Label Metadata

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"label_metadata_name": "name"})
    def update_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        data: Optional[Union[requests.LabelMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Update Label Metadata

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name
        data: requests.LabelMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataUpdate,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class LabelMetadataListPaginated(PaginatorDataModel[LabelMetadata]):
    """
    LabelMetadataListPaginated object.

    Parameters
    ----------
    data: Optional[List[LabelMetadata]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[LabelMetadata]] = None
    pagination: Optional[pagination.Pagination] = None


class NetworkingAddressItem(DataModelBase):
    """
    NetworkingAddressItem object.

    Parameters
    ----------
    address: Optional[str]
    interface: Optional[str]
    port: Optional[int]

    """

    address: Optional[str] = None
    interface: Optional[str] = None
    port: Optional[int] = None


class NetworkingItem(DataModelBase):
    """
    NetworkingItem object.

    Parameters
    ----------
    addresses: Optional[List[NetworkingAddressItem]]
    name: Optional[str]
    protocol: Optional[str]

    """

    addresses: Optional[List[NetworkingAddressItem]] = None
    name: Optional[str] = None
    protocol: Optional[str] = None


class OrchestrationProvision(DataModelBase):
    """
    OrchestrationProvision object.

    Parameters
    ----------
    provision_script: Optional[str]

    """

    provision_script: Optional[str] = None

    @classmethod
    def download_cluster_provision_script(
        cls, dry_run: bool = False, client: Any = None
    ) -> OrchestrationProvision:
        """
        Download Cluster Provision Script

        **Permission Required:** `kelvin.permission.orchestration.read`.

        ``downloadClusterProvisionScript``: ``GET`` ``/api/v4/orchestration/clusters/provision/script/download``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/provision/script/download",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": OrchestrationProvision, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class Secret(DataModelBase):
    """
    Secret object.

    Parameters
    ----------
    name: Optional[str]

    """

    name: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_secret(
        self_or_cls,
        data: Optional[Union[requests.SecretCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Secret:
        """
        Create Secret

        **Permission Required:** `kelvin.permission.secret.update`.

        ``createSecret``: ``POST`` ``/api/v4/secrets/create``

        Parameters
        ----------
        data: requests.SecretCreate, optional
        **kwargs:
            Extra parameters for requests.SecretCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/secrets/create",
            {},
            {},
            {},
            {},
            data,
            requests.SecretCreate,
            False,
            {"201": Secret, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_secret(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[Secret], SecretListPaginated]:
        """
        List Secret

        **Pagination Key:** `secret_name`

        **Permission Required:** `kelvin.permission.secret.read`.

        ``listSecret``: ``GET`` ``/api/v4/secrets/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search secrets by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/secrets/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": SecretListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"secret_name": "name"})
    def delete_secret(
        self_or_cls, secret_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete Secret

        **Permission Required:** `kelvin.permission.secret.delete`.

        ``deleteSecret``: ``POST`` ``/api/v4/secrets/{secret_name}/delete``

        Parameters
        ----------
        secret_name : :obj:`str`, optional
            Secret name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/secrets/{secret_name}/delete",
            {"secret_name": secret_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result


class SecretListPaginated(PaginatorDataModel[Secret]):
    """
    SecretListPaginated object.

    Parameters
    ----------
    data: Optional[List[Secret]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[Secret]] = None
    pagination: Optional[pagination.Pagination] = None


class StorageData(DataModelBase):
    """
    StorageData object.

    Parameters
    ----------
    _insertion_timestamp: Optional[int]
    acp_name: Optional[str]
    key: Optional[str]
    payload: Optional[Dict[str, Any]]
    source: Optional[str]
    timestamp: Optional[int]
    type: Optional[str]

    """

    _insertion_timestamp: Optional[int] = None
    acp_name: Optional[str] = Field(None, max_length=64)
    key: Optional[str] = Field(None, max_length=128)
    payload: Optional[Dict[str, Any]] = None
    source: Optional[str] = Field(None, max_length=64)
    timestamp: Optional[int] = None
    type: Optional[str] = Field(None, max_length=256)


class StorageMetric(DataModelBase):
    """
    StorageMetric object.

    Parameters
    ----------
    acp_name: Optional[str]
    created: Optional[datetime]
    fields: Optional[List[str]]
    key: Optional[str]
    source: Optional[str]
    title: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]

    """

    acp_name: Optional[str] = Field(None, max_length=64)
    created: Optional[datetime] = None
    fields: Optional[List[str]] = None
    key: Optional[str] = Field(None, max_length=128)
    source: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    type: Optional[str] = Field(None, max_length=256)
    updated: Optional[datetime] = None


class StorageMetricListPaginated(PaginatorDataModel[StorageMetric]):
    """
    StorageMetricListPaginated object.

    Parameters
    ----------
    data: Optional[List[StorageMetric]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[StorageMetric]] = None
    pagination: Optional[pagination.Pagination] = None


class User(DataModelBase):
    """
    User object.

    Parameters
    ----------
    created: Optional[datetime]
    email: Optional[EmailStr]
    first_name: Optional[str]
    id: Optional[UUID]
    last_name: Optional[str]
    username: Optional[str]

    """

    created: Optional[datetime] = None
    email: Optional[EmailStr] = None
    first_name: Optional[str] = Field(None, max_length=64)
    id: Optional[UUID] = None
    last_name: Optional[str] = Field(None, max_length=64)
    username: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def list_user(
        self_or_cls,
        username: Optional[Sequence[str]] = None,
        email: Optional[Sequence[str]] = None,
        name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[User], UserListPaginated]:
        """
        List User

        **Pagination Key:** `user_id`

        **Permission Required:** `kelvin.permission.user.read`.

        ``listUser``: ``GET`` ``/api/v4/users/list``

        Parameters
        ----------
        username : :obj:`Sequence[str]`
            User's username
        email : :obj:`Sequence[str]`
            User's email
        name : :obj:`Sequence[str]`
            User's name
        search : :obj:`Sequence[str]`
            Search Users by name or email
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/users/list",
            {},
            {
                "username": username,
                "email": email,
                "name": name,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_current_user(cls, dry_run: bool = False, client: Any = None) -> UserWithPermissions:
        """
        Get Current User

        **Permission Required:** `n/a`.

        ``getCurrentUser``: ``GET`` ``/api/v4/users/me``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/users/me",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserWithPermissions, "400": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"user_id": "id"})
    def get_user(self_or_cls, user_id: str, dry_run: bool = False, client: Any = None) -> User:
        """
        Get User

        **Permission Required:** `kelvin.permission.user.read`.

        ``getUser``: ``GET`` ``/api/v4/users/{user_id}/get``

        Parameters
        ----------
        user_id : :obj:`str`, optional
            User ID

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/users/{user_id}/get",
            {"user_id": user_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": User, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class UserListPaginated(PaginatorDataModel[User]):
    """
    UserListPaginated object.

    Parameters
    ----------
    data: Optional[List[User]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[User]] = None
    pagination: Optional[pagination.Pagination] = None


class UserWithPermissions(DataModelBase):
    """
    UserWithPermissions object.

    Parameters
    ----------
    created: Optional[datetime]
    email: Optional[EmailStr]
    first_name: Optional[str]
    id: Optional[UUID]
    last_name: Optional[str]
    permissions: Optional[List[str]]
    username: Optional[str]

    """

    created: Optional[datetime] = None
    email: Optional[EmailStr] = None
    first_name: Optional[str] = Field(None, max_length=64)
    id: Optional[UUID] = None
    last_name: Optional[str] = Field(None, max_length=64)
    permissions: Optional[List[str]] = None
    username: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def list_user(
        self_or_cls,
        username: Optional[Sequence[str]] = None,
        email: Optional[Sequence[str]] = None,
        name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[User], UserListPaginated]:
        """
        List User

        **Pagination Key:** `user_id`

        **Permission Required:** `kelvin.permission.user.read`.

        ``listUser``: ``GET`` ``/api/v4/users/list``

        Parameters
        ----------
        username : :obj:`Sequence[str]`
            User's username
        email : :obj:`Sequence[str]`
            User's email
        name : :obj:`Sequence[str]`
            User's name
        search : :obj:`Sequence[str]`
            Search Users by name or email
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/users/list",
            {},
            {
                "username": username,
                "email": email,
                "name": name,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": UserListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_current_user(cls, dry_run: bool = False, client: Any = None) -> UserWithPermissions:
        """
        Get Current User

        **Permission Required:** `n/a`.

        ``getCurrentUser``: ``GET`` ``/api/v4/users/me``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/users/me",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": UserWithPermissions, "400": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_user(cls, user_id: str, dry_run: bool = False, client: Any = None) -> User:
        """
        Get User

        **Permission Required:** `kelvin.permission.user.read`.

        ``getUser``: ``GET`` ``/api/v4/users/{user_id}/get``

        Parameters
        ----------
        user_id : :obj:`str`, optional
            User ID

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/users/{user_id}/get",
            {"user_id": user_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": User, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class ViewGroupMetadata(DataModelBase):
    """
    ViewGroupMetadata object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]
    view_group_name: Optional[str]

    """

    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None
    view_group_name: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Create View Group Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/create``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        data: requests.ViewGroupMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/create",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataCreate,
            False,
            {
                "201": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroupMetadata], ViewGroupMetadataListPaginated]:
        """
        List View Group Metadata

        **Pagination Key:** `view_group_metadata_name,view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/list``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        search : :obj:`Sequence[str]`
            Search View Group Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/list",
            {"view_group_name": view_group_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_group_metadata_name": "name"})
    def delete_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Group Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_metadata_name": "name"})
    def get_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroupMetadata:
        """
        Get View Group Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_metadata_name": "name"})
    def update_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        data: Optional[Union[requests.ViewGroupMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Update View Group Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name
        data: requests.ViewGroupMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataUpdate,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewGroupMetadataListPaginated(PaginatorDataModel[ViewGroupMetadata]):
    """
    ViewGroupMetadataListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewGroupMetadata]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewGroupMetadata]] = None
    pagination: Optional[pagination.Pagination] = None


class ViewItem(DataModelBase):
    """
    ViewItem object.

    Parameters
    ----------
    created: Optional[datetime]
    metadata: Optional[Dict[str, Any]]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]
    view_type_name: Optional[str]

    """

    created: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None
    view_type_name: Optional[str] = Field(None, max_length=64)

    @instance_classmethod
    @DataModelBase.translate()
    def create_view(
        self_or_cls,
        data: Optional[Union[requests.ViewCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> View:
        """
        Create View

        **Permission Required:** `kelvin.permission.view.create`.

        ``createView``: ``POST`` ``/api/v4/views/create``

        Parameters
        ----------
        data: requests.ViewCreate, optional
        **kwargs:
            Extra parameters for requests.ViewCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewCreate,
            False,
            {"201": View, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group(
        self_or_cls,
        data: Optional[Union[requests.ViewGroupCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Create View Group

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroup``: ``POST`` ``/api/v4/views/groups/create``

        Parameters
        ----------
        data: requests.ViewGroupCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupCreate,
            False,
            {"201": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_group(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroup], ViewGroupListPaginated]:
        """
        List View Group

        **Pagination Key:** `view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroup``: ``GET`` ``/api/v4/views/groups/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Group by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/create``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/delete``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_group(
        cls, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Group

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/delete",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_group(
        self_or_cls,
        view_group_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroup:
        """
        Get View Group

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroup``: ``GET`` ``/api/v4/views/groups/{view_group_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/get",
            {"view_group_name": view_group_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Create View Group Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/create``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        data: requests.ViewGroupMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/create",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataCreate,
            False,
            {
                "201": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_view_group_metadata(
        cls,
        view_group_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroupMetadata], ViewGroupMetadataListPaginated]:
        """
        List View Group Metadata

        **Pagination Key:** `view_group_metadata_name,view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/list``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        search : :obj:`Sequence[str]`
            Search View Group Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/list",
            {"view_group_name": view_group_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def delete_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Group Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroupMetadata:
        """
        Get View Group Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @classmethod
    def update_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        data: Optional[Union[requests.ViewGroupMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Update View Group Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name
        data: requests.ViewGroupMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataUpdate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataUpdate,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_group(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Update View Group

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        data: requests.ViewGroupUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/update",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupUpdate,
            False,
            {
                "200": ViewGroup,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        view_type_name: Optional[Sequence[str]] = None,
        view_group_name: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewItem], ViewListPaginated]:
        """
        List View

        **Pagination Key:** `view_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listView``: ``GET`` ``/api/v4/views/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search views by name or title
        view_type_name : :obj:`Sequence[str]`
            Filter views by view type
        view_group_name : :obj:`Sequence[str]`
            Filter views by view group
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/list",
            {},
            {
                "search": search,
                "view_type_name": view_type_name,
                "view_group_name": view_group_name,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewMetadataBulk``: ``POST`` ``/api/v4/views/metadata/create``

        Parameters
        ----------
        data: requests.ViewMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewMetadataBulk``: ``POST`` ``/api/v4/views/metadata/delete``

        Parameters
        ----------
        data: requests.ViewMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type(
        self_or_cls,
        data: Optional[Union[requests.ViewTypeCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Create View Type

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewType``: ``POST`` ``/api/v4/views/types/create``

        Parameters
        ----------
        data: requests.ViewTypeCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeCreate,
            False,
            {"201": ViewType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_type(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewType], ViewTypeListPaginated]:
        """
        List View Type

        **Pagination Key:** `view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewType``: ``GET`` ``/api/v4/views/types/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Type by name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/list",
            {},
            {
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/create``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/delete``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_view_type(
        self_or_cls, view_type_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Type

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/delete",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_type(
        self_or_cls,
        view_type_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewType:
        """
        Get View Type

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewType``: ``GET`` ``/api/v4/views/types/{view_type_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/get",
            {"view_type_name": view_type_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Create View Type Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/create``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/create",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataCreate,
            False,
            {
                "201": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewTypeMetadata], ViewTypeMetadataListPaginated]:
        """
        List View Type Metadata

        **Pagination Key:** `view_type_metadata_name,view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/list``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        search : :obj:`Sequence[str]`
            Search View Type Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/list",
            {"view_type_name": view_type_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Type Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewTypeMetadata:
        """
        Get View Type Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        data: Optional[Union[requests.ViewTypeMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Update View Type Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name
        data: requests.ViewTypeMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataUpdate,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_type(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Update View Type

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/update",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeUpdate,
            False,
            {
                "200": ViewType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view(cls, view_name: str, dry_run: bool = False, client: Any = None) -> None:
        """
        Delete View

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteView``: ``POST`` ``/api/v4/views/{view_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/delete",
            {"view_name": view_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view(
        self_or_cls,
        view_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> View:
        """
        Get View

        **Permission Required:** `kelvin.permission.view.read`.

        ``getView``: ``GET`` ``/api/v4/views/{view_name}/get``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/get",
            {"view_name": view_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": View, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def create_view_view_group_relationship(
        cls, view_name: str, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Create View View Group Relationship

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewViewGroupRelationship``: ``POST`` ``/api/v4/views/{view_name}/groups/{view_group_name}/create``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/groups/{view_group_name}/create",
            {"view_name": view_name, "view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"201": None, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def delete_view_view_group_relationship(
        cls, view_name: str, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View View Group Relationship

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewViewGroupRelationship``: ``POST`` ``/api/v4/views/{view_name}/groups/{view_group_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/groups/{view_group_name}/delete",
            {"view_name": view_name, "view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_metadata(
        self_or_cls,
        view_name: str,
        data: Optional[Union[requests.ViewMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Create View Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/create``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        data: requests.ViewMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/create",
            {"view_name": view_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataCreate,
            False,
            {"201": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_view_metadata(
        cls,
        view_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewMetadata], ViewMetadataListPaginated]:
        """
        List View Metadata

        **Pagination Key:** `view_metadata_name,view_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/list``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        search : :obj:`Sequence[str]`
            Search View Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/list",
            {"view_name": view_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def delete_view_metadata(
        cls, view_name: str, view_metadata_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_view_metadata(
        cls, view_name: str, view_metadata_name: str, dry_run: bool = False, client: Any = None
    ) -> ViewMetadata:
        """
        Get View Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/get``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/get",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def update_view_metadata(
        cls,
        view_name: str,
        view_metadata_name: str,
        data: Optional[Union[requests.ViewMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Update View Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/update``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name
        data: requests.ViewMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataUpdate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/update",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataUpdate,
            False,
            {
                "200": ViewMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view(
        self_or_cls,
        view_name: str,
        data: Optional[Union[requests.ViewUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> View:
        """
        Update View

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateView``: ``POST`` ``/api/v4/views/{view_name}/update``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        data: requests.ViewUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/update",
            {"view_name": view_name},
            {},
            {},
            {},
            data,
            requests.ViewUpdate,
            False,
            {
                "200": View,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewListPaginated(PaginatorDataModel[ViewItem]):
    """
    ViewListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewItem]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewItem]] = None
    pagination: Optional[pagination.Pagination] = None


class ViewMetadata(DataModelBase):
    """
    ViewMetadata object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]
    view_name: Optional[str]

    """

    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None
    view_name: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_metadata(
        self_or_cls,
        view_name: str,
        data: Optional[Union[requests.ViewMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Create View Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/create``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        data: requests.ViewMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/create",
            {"view_name": view_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataCreate,
            False,
            {"201": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_metadata(
        self_or_cls,
        view_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewMetadata], ViewMetadataListPaginated]:
        """
        List View Metadata

        **Pagination Key:** `view_metadata_name,view_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/list``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        search : :obj:`Sequence[str]`
            Search View Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/list",
            {"view_name": view_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_metadata_name": "name"})
    def delete_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_metadata_name": "name"})
    def get_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewMetadata:
        """
        Get View Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/get``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/get",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_metadata_name": "name"})
    def update_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        data: Optional[Union[requests.ViewMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Update View Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/update``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name
        data: requests.ViewMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/update",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataUpdate,
            False,
            {
                "200": ViewMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewMetadataListPaginated(PaginatorDataModel[ViewMetadata]):
    """
    ViewMetadataListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewMetadata]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewMetadata]] = None
    pagination: Optional[pagination.Pagination] = None


class ViewMetric(DataModelBase):
    """
    ViewMetric object.

    Parameters
    ----------
    acp_name: Optional[str]
    key: Optional[str]
    source: Optional[str]
    type: Optional[str]

    """

    acp_name: Optional[str] = None
    key: Optional[str] = None
    source: Optional[str] = None
    type: Optional[str] = None


class ViewType(DataModelBase):
    """
    ViewType object.

    Parameters
    ----------
    created: Optional[datetime]
    metadata: Optional[Dict[str, Any]]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]

    """

    created: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type(
        self_or_cls,
        data: Optional[Union[requests.ViewTypeCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Create View Type

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewType``: ``POST`` ``/api/v4/views/types/create``

        Parameters
        ----------
        data: requests.ViewTypeCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeCreate,
            False,
            {"201": ViewType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_type(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewType], ViewTypeListPaginated]:
        """
        List View Type

        **Pagination Key:** `view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewType``: ``GET`` ``/api/v4/views/types/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Type by name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/list",
            {},
            {
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/create``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/delete``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def delete_view_type(
        self_or_cls, view_type_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Type

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/delete",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def get_view_type(
        self_or_cls,
        view_type_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewType:
        """
        Get View Type

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewType``: ``GET`` ``/api/v4/views/types/{view_type_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/get",
            {"view_type_name": view_type_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def create_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Create View Type Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/create``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/create",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataCreate,
            False,
            {
                "201": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def list_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewTypeMetadata], ViewTypeMetadataListPaginated]:
        """
        List View Type Metadata

        **Pagination Key:** `view_type_metadata_name,view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/list``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        search : :obj:`Sequence[str]`
            Search View Type Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/list",
            {"view_type_name": view_type_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def delete_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Type Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def get_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewTypeMetadata:
        """
        Get View Type Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def update_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        data: Optional[Union[requests.ViewTypeMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Update View Type Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name
        data: requests.ViewTypeMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataUpdate,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_name": "name"})
    def update_view_type(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Update View Type

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/update",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeUpdate,
            False,
            {
                "200": ViewType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewTypeListPaginated(PaginatorDataModel[ViewType]):
    """
    ViewTypeListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewType]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewType]] = None
    pagination: Optional[pagination.Pagination] = None


class ViewTypeMetadata(DataModelBase):
    """
    ViewTypeMetadata object.

    Parameters
    ----------
    created: Optional[datetime]
    name: Optional[str]
    payload: Optional[Dict[str, Any]]
    updated: Optional[datetime]
    view_typename: Optional[str]

    """

    created: Optional[datetime] = None
    name: Optional[str] = Field(None, max_length=64)
    payload: Optional[Dict[str, Any]] = None
    updated: Optional[datetime] = None
    view_typename: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Create View Type Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/create``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/create",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataCreate,
            False,
            {
                "201": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_view_type_metadata(
        cls,
        view_type_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewTypeMetadata], ViewTypeMetadataListPaginated]:
        """
        List View Type Metadata

        **Pagination Key:** `view_type_metadata_name,view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/list``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        search : :obj:`Sequence[str]`
            Search View Type Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/list",
            {"view_type_name": view_type_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_type_metadata_name": "name"})
    def delete_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Type Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_metadata_name": "name"})
    def get_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewTypeMetadata:
        """
        Get View Type Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_type_metadata_name": "name"})
    def update_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        data: Optional[Union[requests.ViewTypeMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Update View Type Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name
        data: requests.ViewTypeMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataUpdate,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewTypeMetadataListPaginated(PaginatorDataModel[ViewTypeMetadata]):
    """
    ViewTypeMetadataListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewTypeMetadata]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewTypeMetadata]] = None
    pagination: Optional[pagination.Pagination] = None


class WireguardPeer(DataModelBase):
    """
    WireguardPeer object.

    Parameters
    ----------
    allowed_ips: Optional[List[str]]
    created: Optional[str]
    endpoint: Optional[str]
    name: Optional[str]
    public_key: Optional[str]
    title: Optional[str]
    type: Optional[str]
    updated: Optional[str]
    wireguard_ip: Optional[str]

    """

    allowed_ips: Optional[List[str]] = None
    created: Optional[str] = None
    endpoint: Optional[str] = None
    name: Optional[str] = None
    public_key: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    updated: Optional[str] = None
    wireguard_ip: Optional[str] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_wireguard_peer(
        self_or_cls,
        data: Optional[Union[requests.WireguardPeerCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> WireguardPeer:
        """
        Create Wireguard Peer

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createWireguardPeer``: ``POST`` ``/api/v4/wireguard/peers/create``

        Parameters
        ----------
        data: requests.WireguardPeerCreate, optional
        **kwargs:
            Extra parameters for requests.WireguardPeerCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/create",
            {},
            {},
            {},
            {},
            data,
            requests.WireguardPeerCreate,
            False,
            {
                "201": WireguardPeer,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_wireguard_peer(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[WireguardPeer], WireguardPeerListPaginated]:
        """
        List Wireguard Peer

        **Pagination Key:** `wireguard_peer_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listWireguardPeer``: ``GET`` ``/api/v4/wireguard/peers/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search Peers by name, title or public key
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/wireguard/peers/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WireguardPeerListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_wireguard_graph(
        cls, format: Optional[str] = None, dry_run: bool = False, client: Any = None
    ) -> WireguardTunnel:
        """
        Get Wireguard Graph returns a visual representation of all the tunnels in the system

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getWireguardGraph``: ``POST`` ``/api/v4/wireguard/peers/tunnels/graph/get``

        Parameters
        ----------
        format : :obj:`str`
            Desired return format (svg or dot)

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/tunnels/graph/get",
            {},
            {"format": format},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @classmethod
    def delete_wireguard_peer(
        cls, peer_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete Wireguard Peer

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteWireguardPeer``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/delete``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Peer name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/delete",
            {"peer_name": peer_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_wireguard_peer(
        cls, peer_name: str, dry_run: bool = False, client: Any = None
    ) -> WireguardPeer:
        """
        Get Wireguard Peer

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getWireguardPeer``: ``GET`` ``/api/v4/wireguard/peers/{peer_name}/get``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Peer name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/wireguard/peers/{peer_name}/get",
            {"peer_name": peer_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": WireguardPeer, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessage},
            False,
            dry_run,
        )
        return result

    @classmethod
    def create_wireguard_tunnel(
        cls,
        peer_name: str,
        data: Optional[Union[requests.WireguardTunnelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> WireguardTunnel:
        """
        Create Wireguard Tunnel

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createWireguardTunnel``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/create``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer
        data: requests.WireguardTunnelCreate, optional
        **kwargs:
            Extra parameters for requests.WireguardTunnelCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/create",
            {"peer_name": peer_name},
            {},
            {},
            {},
            data,
            requests.WireguardTunnelCreate,
            False,
            {
                "201": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_wireguard_tunnel(
        cls, peer_name: str, dry_run: bool = False, client: Any = None
    ) -> WireguardTunnel:
        """
        Delete Wireguard Tunnel

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteWireguardTunnel``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/delete``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/delete",
            {"peer_name": peer_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @classmethod
    def list_wireguard_tunnel(
        cls,
        peer_name: str,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[WireguardPeer], WireguardPeerListPaginated]:
        """
        List Wireguard Tunnel

        **Pagination Key:** `wireguard_peer_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listWireguardTunnel``: ``GET`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/list``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/list",
            {"peer_name": peer_name},
            {
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WireguardPeerListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def update_wireguard_peer(
        self_or_cls,
        peer_name: str,
        data: Optional[Union[requests.WireguardPeerUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> WireguardPeer:
        """
        Update Wireguard Peer

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateWireguardPeer``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/update``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Peer name
        data: requests.WireguardPeerUpdate, optional
        **kwargs:
            Extra parameters for requests.WireguardPeerUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/update",
            {"peer_name": peer_name},
            {},
            {},
            {},
            data,
            requests.WireguardPeerUpdate,
            False,
            {
                "200": WireguardPeer,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessage,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class WireguardPeerListPaginated(PaginatorDataModel[WireguardPeer]):
    """
    WireguardPeerListPaginated object.

    Parameters
    ----------
    data: Optional[List[WireguardPeer]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[WireguardPeer]] = None
    pagination: Optional[pagination.Pagination] = None


class WireguardTunnel(DataModelBase):
    """
    WireguardTunnel object.

    Parameters
    ----------
    created: Optional[str]
    keep_alive: Optional[int]
    updated: Optional[str]
    wireguard_peer: Optional[str]

    """

    created: Optional[str] = None
    keep_alive: Optional[int] = None
    updated: Optional[str] = None
    wireguard_peer: Optional[str] = None

    @classmethod
    def get_wireguard_graph(
        cls, format: Optional[str] = None, dry_run: bool = False, client: Any = None
    ) -> WireguardTunnel:
        """
        Get Wireguard Graph returns a visual representation of all the tunnels in the system

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getWireguardGraph``: ``POST`` ``/api/v4/wireguard/peers/tunnels/graph/get``

        Parameters
        ----------
        format : :obj:`str`
            Desired return format (svg or dot)

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/tunnels/graph/get",
            {},
            {"format": format},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_wireguard_tunnel(
        self_or_cls,
        peer_name: str,
        data: Optional[Union[requests.WireguardTunnelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> WireguardTunnel:
        """
        Create Wireguard Tunnel

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createWireguardTunnel``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/create``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer
        data: requests.WireguardTunnelCreate, optional
        **kwargs:
            Extra parameters for requests.WireguardTunnelCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/create",
            {"peer_name": peer_name},
            {},
            {},
            {},
            data,
            requests.WireguardTunnelCreate,
            False,
            {
                "201": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_wireguard_tunnel(
        cls, peer_name: str, dry_run: bool = False, client: Any = None
    ) -> WireguardTunnel:
        """
        Delete Wireguard Tunnel

        **Permission Required:** `kelvin.permission.acp.delete`.

        ``deleteWireguardTunnel``: ``POST`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/delete``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/delete",
            {"peer_name": peer_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WireguardTunnel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @classmethod
    def list_wireguard_tunnel(
        cls,
        peer_name: str,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[WireguardPeer], WireguardPeerListPaginated]:
        """
        List Wireguard Tunnel

        **Pagination Key:** `wireguard_peer_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listWireguardTunnel``: ``GET`` ``/api/v4/wireguard/peers/{peer_name}/tunnels/list``

        Parameters
        ----------
        peer_name : :obj:`str`, optional
            Source peer
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/wireguard/peers/{peer_name}/tunnels/list",
            {"peer_name": peer_name},
            {
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WireguardPeerListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result


class Workload(DataModelBase):
    """
    Workload object.

    Parameters
    ----------
    acp_name: Optional[str]
    app_name: Optional[str]
    app_version: Optional[str]
    created: Optional[datetime]
    enabled: Optional[bool]
    name: Optional[str]
    networking: Optional[List[NetworkingItem]]
    payload: Optional[Dict[str, Any]]
    title: Optional[str]
    updated: Optional[datetime]

    """

    acp_name: Optional[str] = None
    app_name: Optional[str] = None
    app_version: Optional[str] = None
    created: Optional[datetime] = None
    enabled: Optional[bool] = None
    name: Optional[str] = None
    networking: Optional[List[NetworkingItem]] = None
    payload: Optional[Dict[str, Any]] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def deploy_workload(
        self_or_cls,
        data: Optional[Union[requests.WorkloadDeploy, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Workload:
        """
        Deploy Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``deployWorkload``: ``POST`` ``/api/v4/workloads/deploy``

        Parameters
        ----------
        data: requests.WorkloadDeploy, optional
        **kwargs:
            Extra parameters for requests.WorkloadDeploy

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/workloads/deploy",
            {},
            {},
            {},
            {},
            data,
            requests.WorkloadDeploy,
            False,
            {"201": Workload, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_workload(
        self_or_cls,
        app_name: Optional[Sequence[str]] = None,
        app_version: Optional[Sequence[str]] = None,
        acp_name: Optional[Sequence[str]] = None,
        enabled: Optional[bool] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        search: Optional[Sequence[str]] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[Workload], WorkloadListPaginated]:
        """
        List Workload

        **Pagination Key:** `workload_name`

        **Permission Required:** `kelvin.permission.workload.read`.

        ``listWorkload``: ``GET`` ``/api/v4/workloads/list``

        Parameters
        ----------
        app_name : :obj:`Sequence[str]`
            App Name
        app_version : :obj:`Sequence[str]`
            App Version
        acp_name : :obj:`Sequence[str]`
            ACP Name
        enabled : :obj:`bool`
            Filter workloads by enabled status
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        search : :obj:`Sequence[str]`
            Search workloads by name, title, App name and ACP name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/list",
            {},
            {
                "app_name": app_name,
                "app_version": app_version,
                "acp_name": acp_name,
                "enabled": enabled,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "search": search,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def list_workload_status(
        self_or_cls,
        app_name: Optional[Sequence[str]] = None,
        app_version: Optional[Sequence[str]] = None,
        acp_name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        source: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[WorkloadStatusItem], WorkloadStatusListPaginated]:
        """
        List Workload Status

        **Pagination Key:** `workload_name`

        **Permission Required:** `kelvin.permission.workload.read`.

        ``listWorkloadStatus``: ``GET`` ``/api/v4/workloads/status/list``

        Parameters
        ----------
        app_name : :obj:`Sequence[str]`
            App Name
        app_version : :obj:`Sequence[str]`
            App Version
        acp_name : :obj:`Sequence[str]`
            ACP Name
        search : :obj:`Sequence[str]`
            Search Workloads by title and name
        source : :obj:`str`
            Source should be 'cache' or 'live' (default is cache)
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/status/list",
            {},
            {
                "app_name": app_name,
                "app_version": app_version,
                "acp_name": acp_name,
                "search": search,
                "source": source,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload(
        self_or_cls, workload_name: str, dry_run: bool = False, client: Any = None
    ) -> Workload:
        """
        Get Workload

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/get",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Workload, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload_logs(
        self_or_cls,
        workload_name: str,
        tail_lines: Optional[str] = None,
        since_time: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> WorkloadLogs:
        """
        Get Workload Logs

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadLogs``: ``GET`` ``/api/v4/workloads/{workload_name}/logs/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        tail_lines : :obj:`str`
            The number of lines from the end of the logs to show
        since_time : :obj:`str`
            A timestamp from which to show logs

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/logs/get",
            {"workload_name": workload_name},
            {"tail_lines": tail_lines, "since_time": since_time},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WorkloadLogs,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload_metrics(
        self_or_cls, workload_name: str, dry_run: bool = False, client: Any = None
    ) -> WorkloadMetrics:
        """
        Get Workload Metrics

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadMetrics``: ``GET`` ``/api/v4/workloads/{workload_name}/metrics/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/metrics/get",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadMetrics, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def start_workload(
        self_or_cls, workload_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Start Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``startWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/start``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/start",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def get_workload_status(
        self_or_cls,
        workload_name: str,
        source: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> WorkloadStatusItem:
        """
        Get Workload Status

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadStatus``: ``GET`` ``/api/v4/workloads/{workload_name}/status/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        source : :obj:`str`
            Source should be 'cache' or 'live' (default is cache)

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/status/get",
            {"workload_name": workload_name},
            {"source": source},
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadStatusItem, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def stop_workload(
        self_or_cls, workload_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Stop Workload

        **Permission Required:** `kelvin.permission.workload.update`.

        ``stopWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/stop``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/stop",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"workload_name": "name"})
    def undeploy_workload(
        self_or_cls,
        workload_name: str,
        data: Optional[Union[requests.WorkloadUndeployOptions, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Undeploy Workload

        **Permission Required:** `kelvin.permission.workload.delete`.

        ``undeployWorkload``: ``POST`` ``/api/v4/workloads/{workload_name}/undeploy``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        data: requests.WorkloadUndeployOptions, optional
        **kwargs:
            Extra parameters for requests.WorkloadUndeployOptions

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/workloads/{workload_name}/undeploy",
            {"workload_name": workload_name},
            {},
            {},
            {},
            data,
            requests.WorkloadUndeployOptions,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result


class WorkloadAllocation(DataModelBase):
    """
    WorkloadAllocation object.

    Parameters
    ----------
    cpu_requests: Optional[float]
    memory_requests: Optional[float]

    """

    cpu_requests: Optional[float] = None
    memory_requests: Optional[float] = None


class WorkloadCPUUtilization(DataModelBase):
    """
    WorkloadCPUUtilization object.

    Parameters
    ----------
    timestamp: Optional[int]
    value: Optional[float]

    """

    timestamp: Optional[int] = None
    value: Optional[float] = None


class WorkloadListPaginated(PaginatorDataModel[Workload]):
    """
    WorkloadListPaginated object.

    Parameters
    ----------
    data: Optional[List[Workload]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[Workload]] = None
    pagination: Optional[pagination.Pagination] = None


class WorkloadLogs(DataModelBase):
    """
    WorkloadLogs object.

    Parameters
    ----------
    logs: Optional[Dict[str, Logs]]

    """

    logs: Optional[Dict[str, Logs]] = None

    @classmethod
    def get_workload_logs(
        cls,
        workload_name: str,
        tail_lines: Optional[str] = None,
        since_time: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> WorkloadLogs:
        """
        Get Workload Logs

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadLogs``: ``GET`` ``/api/v4/workloads/{workload_name}/logs/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        tail_lines : :obj:`str`
            The number of lines from the end of the logs to show
        since_time : :obj:`str`
            A timestamp from which to show logs

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/logs/get",
            {"workload_name": workload_name},
            {"tail_lines": tail_lines, "since_time": since_time},
            {},
            {},
            None,
            None,
            False,
            {
                "200": WorkloadLogs,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "500": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result


class WorkloadMemoryUsage(DataModelBase):
    """
    WorkloadMemoryUsage object.

    Parameters
    ----------
    timestamp: Optional[int]
    value: Optional[float]

    """

    timestamp: Optional[int] = None
    value: Optional[float] = None


class WorkloadNetwork(DataModelBase):
    """
    WorkloadNetwork object.

    Parameters
    ----------
    total_rx: Optional[float]
    total_tx: Optional[float]

    """

    total_rx: Optional[float] = None
    total_tx: Optional[float] = None


class WorkloadStatus(DataModelBase):
    """
    WorkloadStatus object.

    Parameters
    ----------
    last_seen: Optional[datetime]
    message: Optional[str]
    state: Optional[str]
    warnings: Optional[List[str]]

    """

    last_seen: Optional[datetime] = None
    message: Optional[str] = None
    state: Optional[str] = None
    warnings: Optional[List[str]] = None


class WorkloadStatusItem(DataModelBase):
    """
    WorkloadStatusItem object.

    Parameters
    ----------
    name: Optional[str]
    status: Optional[WorkloadStatus]

    """

    name: Optional[str] = None
    status: Optional[WorkloadStatus] = None

    @classmethod
    def list_workload_status(
        cls,
        app_name: Optional[Sequence[str]] = None,
        app_version: Optional[Sequence[str]] = None,
        acp_name: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        source: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[WorkloadStatusItem], WorkloadStatusListPaginated]:
        """
        List Workload Status

        **Pagination Key:** `workload_name`

        **Permission Required:** `kelvin.permission.workload.read`.

        ``listWorkloadStatus``: ``GET`` ``/api/v4/workloads/status/list``

        Parameters
        ----------
        app_name : :obj:`Sequence[str]`
            App Name
        app_version : :obj:`Sequence[str]`
            App Version
        acp_name : :obj:`Sequence[str]`
            ACP Name
        search : :obj:`Sequence[str]`
            Search Workloads by title and name
        source : :obj:`str`
            Source should be 'cache' or 'live' (default is cache)
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/workloads/status/list",
            {},
            {
                "app_name": app_name,
                "app_version": app_version,
                "acp_name": acp_name,
                "search": search,
                "source": source,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_workload_status(
        cls,
        workload_name: str,
        source: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> WorkloadStatusItem:
        """
        Get Workload Status

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadStatus``: ``GET`` ``/api/v4/workloads/{workload_name}/status/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name
        source : :obj:`str`
            Source should be 'cache' or 'live' (default is cache)

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/status/get",
            {"workload_name": workload_name},
            {"source": source},
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadStatusItem, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class WorkloadStatusListPaginated(PaginatorDataModel[WorkloadStatusItem]):
    """
    WorkloadStatusListPaginated object.

    Parameters
    ----------
    data: Optional[List[WorkloadStatusItem]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[WorkloadStatusItem]] = None
    pagination: Optional[pagination.Pagination] = None


class Storage(DataModelBase):
    """
    Storage object.

    Parameters
    ----------

    """

    @classmethod
    def create_historian_metric(
        cls,
        data: Optional[Union[requests.StorageBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Historian Metric persists time series data.

        **Note:**
        * If a Metric timestamp already exists on the database, this endpoint will
        overwrite the stored payload with the new payload value.

        **Payload Details:**
        * `acp_name`: name of the ACP
        * `source`: application that generated the data. Example: `modbus`
        * `key`: metric identifier. Example: `ns=2;s=wireline.line_speed`
        * `type`: type of the data. Example: `raw.int32`, `raw.float32`, `kelvin.plungermsg`
        * `payload`: data to persist
        * `timestamp`: UNIX timestamp in nanoseconds or RFC3339 string

        **Permission Required:** `kelvin.permission.storage.create`.

        ``createHistorianMetric``: ``POST`` ``/api/v4/storage/historian/create``

        Parameters
        ----------
        data: requests.StorageBulkCreate, optional
        **kwargs:
            Extra parameters for requests.StorageBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/create",
            {},
            {},
            {},
            {},
            data,
            requests.StorageBulkCreate,
            False,
            {"201": None, "207": ErrorMessages, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def get_historian_metric_last(
        cls,
        acp_name: str,
        source: str,
        key: str,
        type: str,
        fields: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> StorageData:
        """
        Get Historian Metric Last returns the last value inserted on the
        time series database for a single Metric. The calculation is
        based on the most recent timestamp available for the Metric.

        **Permission Required:** `kelvin.permission.storage.read`.

        ``getHistorianMetricLast``: ``GET`` ``/api/v4/storage/historian/last/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            Name of the ACP which produced the data
        source : :obj:`str`, optional
            Application that generated the data
        key : :obj:`str`, optional
            Metric identifier
        type : :obj:`str`, optional
            Metric type
        fields : :obj:`str`
            List of field identifiers

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/storage/historian/last/get",
            {},
            {"acp_name": acp_name, "source": source, "key": key, "type": type, "fields": fields},
            {},
            {},
            None,
            None,
            False,
            {"200": StorageData, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_historian_metric_last_advanced(
        cls,
        data: Optional[Union[requests.StorageLast, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Iterator[StorageData]:
        """
        Get Historian Metric Last Advanced returns the last values inserted on the
        time series database for a list of Metric selectors. The calculation is
        based on the most recent timestamp available for each Metric.

        **Permission Required:** `kelvin.permission.storage.read`.

        ``getHistorianMetricLastAdvanced``: ``POST`` ``/api/v4/storage/historian/last/get``

        Parameters
        ----------
        data: requests.StorageLast, optional
        **kwargs:
            Extra parameters for requests.StorageLast

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/last/get",
            {},
            {},
            {},
            {},
            data,
            requests.StorageLast,
            False,
            {"200": StorageData, "401": ErrorMessages, "404": ErrorMessages},
            True,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_historian_metric(
        cls,
        acp_name: Optional[str] = None,
        source: Optional[str] = None,
        key: Optional[str] = None,
        type: Optional[str] = None,
        search: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[StorageMetric], StorageMetricListPaginated]:
        """
        List Historian Metric

        **Pagination Key:** `acp_name,source,key,type`

        **Permission Required:** `kelvin.permission.storage.read`.

        ``listHistorianMetric``: ``GET`` ``/api/v4/storage/historian/list``

        Parameters
        ----------
        acp_name : :obj:`str`
            Name of the ACP which produced the data
        source : :obj:`str`
            Application that generated the data
        key : :obj:`str`
            Metric identifier
        type : :obj:`str`
            Metric type
        search : :obj:`str`
            Search metrics by ACP name, source, key or type
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/storage/historian/list",
            {},
            {
                "acp_name": acp_name,
                "source": source,
                "key": key,
                "type": type,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": StorageMetricListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def delete_historian_range(
        cls,
        data: Optional[Union[requests.StorageDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Historian Range will delete all associated time series values between a given time-range.

        **Payload Details:**
        * `start_time`: supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `end_time`: supports RFC3339 timestamps or UNIX timestamp in nanoseconds

        **Permission Required:** `kelvin.permission.storage.delete`.

        ``deleteHistorianRange``: ``POST`` ``/api/v4/storage/historian/range/delete``

        Parameters
        ----------
        data: requests.StorageDelete, optional
        **kwargs:
            Extra parameters for requests.StorageDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/range/delete",
            {},
            {},
            {},
            {},
            data,
            requests.StorageDelete,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def download_historian_metrics(
        cls,
        data: Optional[Union[requests.StorageRangeAdvanced, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Download Historian Metrics returns a **CSV file** with time series data for a given time range
        list of Metric selectors.

        **Payload Description:**
        * `start_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `end_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `time_bucket` uses an human readable format which is covered in more detail in
        https://golang.org/pkg/time/#ParseDuration. Example: `5m`, `1h`, `1w`
        * `time_shift` is used to shift the time buckets from the epoch. Every time bucket starts from epoch
        so, if you want to calculate the time bucket starting on a different date and time, you'll need to
        set this. Example: `5m`, `1h`, `1w`
        * `fill` allows you to fill missing points from a time bucket. Check below for supported fill values.
        * `agg` allows you to choose an aggregation. Check below for supported aggregations.

        **Supported Fill:**
        * `none`: Default behaviour.
        * `null`: Fills the missing points with null string
        * `linear`: Performs a linear regression
        * `previous`: Uses the previous non-empty value
        * `int value`: Fills the missing points with the specified number

        **Supported Aggregations:**
        * Numeric types (`raw.int32`, `raw.int64`, etc) are:
        `none`, `count`, `distinct`, `integral`, `mean`, `median`, `mode`, `spread`, `stddev`, `sum`
        * Non-numeric types (`raw.text`, `raw.beampump`, etc) are:
        `count`, `distinct` and `mode`

        **Permission Required:** `kelvin.permission.storage.read`.

        ``downloadHistorianMetrics``: ``POST`` ``/api/v4/storage/historian/range/download``

        Parameters
        ----------
        data: requests.StorageRangeAdvanced, optional
        **kwargs:
            Extra parameters for requests.StorageRangeAdvanced

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/range/download",
            {},
            {},
            {},
            {},
            data,
            requests.StorageRangeAdvanced,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def get_historian_metric_range(
        cls,
        acp_name: str,
        source: str,
        key: str,
        type: str,
        start_time: int,
        end_time: int,
        agg: Optional[str] = None,
        time_bucket: Optional[str] = None,
        time_shift: Optional[str] = None,
        fill: Optional[str] = None,
        order: Optional[str] = None,
        fields: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> Iterator[StorageData]:
        """
        Get Historian Metric Range returns time series data for a given time range
        and a list of Metric selectors.

        **Payload Description:**
        * `start_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `end_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `time_bucket` uses an human readable format which is covered in more detail in
        https://golang.org/pkg/time/#ParseDuration. Example: `5m`, `1h`, `1w`
        * `time_shift` is used to shift the time buckets from the epoch. Every time bucket starts from epoch
        so, if you want to calculate the time bucket starting on a different date and time, you'll need to
        set this. Example: `5m`, `1h`, `1w`
        * `fill` allows you to fill missing points from a time bucket. Check below for supported fill values.
        * `agg` allows you to choose an aggregation. Check below for supported aggregations.

        **Supported Fill:**
        * `none`: Default behaviour.
        * `null`: Fills the missing points with null string
        * `linear`: Performs a linear regression
        * `previous`: Uses the previous non-empty value
        * `int value`: Fills the missing points with the specified number

        **Supported Aggregations:**
        * Numeric types (`raw.int32`, `raw.int64`, etc) are:
        `none`, `count`, `distinct`, `integral`, `mean`, `median`, `mode`, `spread`, `stddev`, `sum`
        * Non-numeric types (`raw.text`, `raw.beampump`, etc) are:
        `count`, `distinct` and `mode`

        **Permission Required:** `kelvin.permission.storage.read`.

        ``getHistorianMetricRange``: ``GET`` ``/api/v4/storage/historian/range/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP that produced the data
        source : :obj:`str`, optional
            Source (application) that produced the data
        key : :obj:`str`, optional
            Key identifying the data
        type : :obj:`str`, optional
            Metric Type
        start_time : :obj:`int`, optional
            Value for the start of the range for which to get data
        end_time : :obj:`int`, optional
            Value for the end of the range for which to get data
        agg : :obj:`str`
            Aggregation (none, count, distinct, integral, mean, median, mode,
            spread, stddev, sum)
        time_bucket : :obj:`str`
            Interval for which to group by, in human readable format
        time_shift : :obj:`str`
            Interval by which to shift the time buckets, from epoch
        fill : :obj:`str`
            Filling for empty time buckets (check description for possible values)
        order : :obj:`str`
            Order of the data
        fields : :obj:`Sequence[str]`
            Fields

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/storage/historian/range/get",
            {},
            {
                "acp_name": acp_name,
                "source": source,
                "key": key,
                "type": type,
                "start_time": start_time,
                "end_time": end_time,
                "agg": agg,
                "time_bucket": time_bucket,
                "time_shift": time_shift,
                "fill": fill,
                "order": order,
                "fields": fields,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": StorageData, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            True,
            dry_run,
        )
        return result

    @classmethod
    def get_historian_metric_advanced_range(
        cls,
        data: Optional[Union[requests.StorageRangeAdvanced, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Iterator[StorageData]:
        """
        Get Historian Metric Advanced Range returns time series data for a given time range
        and a list of Metric selectors.

        **Payload Description:**
        * `start_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `end_time` supports RFC3339 timestamps or UNIX timestamp in nanoseconds
        * `time_bucket` uses an human readable format which is covered in more detail in
        https://golang.org/pkg/time/#ParseDuration. Example: `5m`, `1h`, `1w`
        * `time_shift` is used to shift the time buckets from the epoch. Every time bucket starts from epoch
        so, if you want to calculate the time bucket starting on a different date and time, you'll need to
        set this. Example: `5m`, `1h`, `1w`
        * `fill` allows you to fill missing points from a time bucket. Check below for supported fill values.
        * `agg` allows you to choose an aggregation. Check below for supported aggregations.

        **Supported Fill:**
        * `none`: Default behaviour.
        * `null`: Fills the missing points with null string
        * `linear`: Performs a linear regression
        * `previous`: Uses the previous non-empty value
        * `int value`: Fills the missing points with the specified number

        **Supported Aggregations:**
        * Numeric types (`raw.int32`, `raw.int64`, etc) are:
        `none`, `count`, `distinct`, `integral`, `mean`, `median`, `mode`, `spread`, `stddev`, `sum`
        * Non-numeric types (`raw.text`, `raw.beampump`, etc) are:
        `count`, `distinct` and `mode`

        **Permission Required:** `kelvin.permission.storage.read`.

        ``getHistorianMetricAdvancedRange``: ``POST`` ``/api/v4/storage/historian/range/get``

        Parameters
        ----------
        data: requests.StorageRangeAdvanced, optional
        **kwargs:
            Extra parameters for requests.StorageRangeAdvanced

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/range/get",
            {},
            {},
            {},
            {},
            data,
            requests.StorageRangeAdvanced,
            False,
            {"200": StorageData, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            True,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def update_historian_metric(
        cls,
        data: Optional[Union[requests.StorageUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Update Historian Metric allows updating the **title** of a Metric.

        **Permission Required:** `kelvin.permission.storage.update`.

        ``updateHistorianMetric``: ``POST`` ``/api/v4/storage/historian/update``

        Parameters
        ----------
        data: requests.StorageUpdate, optional
        **kwargs:
            Extra parameters for requests.StorageUpdate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/update",
            {},
            {},
            {},
            {},
            data,
            requests.StorageUpdate,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def upload_historian_metrics(cls, file: str, dry_run: bool = False, client: Any = None) -> None:
        """
        Upload Historian Metrics allows sending a **CSV file** with time series data
        to be persisted.

        **Permission Required:** `kelvin.permission.storage.create`.

        ``uploadHistorianMetrics``: ``POST`` ``/api/v4/storage/historian/upload``

        Parameters
        ----------
        file : :obj:`str`, optional
            CSV File

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/storage/historian/upload",
            {},
            {},
            {"file": file},
            {},
            None,
            None,
            False,
            {"201": None, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class ACPMetrics(DataModelBase):
    """
    ACPMetrics object.

    Parameters
    ----------
    allocation: Optional[ACPAllocation]
    cpu_utilization: Optional[List[ACPCPUUtilization]]
    disk: Optional[ACPDisk]
    memory_usage: Optional[List[ACPMemoryUsage]]
    network: Optional[ACPNetwork]

    """

    allocation: Optional[ACPAllocation] = None
    cpu_utilization: Optional[List[ACPCPUUtilization]] = None
    disk: Optional[ACPDisk] = None
    memory_usage: Optional[List[ACPMemoryUsage]] = None
    network: Optional[ACPNetwork] = None

    @classmethod
    def get_acp_metrics(
        cls, acp_name: str, dry_run: bool = False, client: Any = None
    ) -> ACPMetrics:
        """
        Get ACP Metrics

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPMetrics``: ``GET`` ``/api/v4/acps/{acp_name}/metrics/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/metrics/get",
            {"acp_name": acp_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPMetrics, "400": ErrorMessages, "401": ErrorMessages, "500": ErrorMessages},
            False,
            dry_run,
        )
        return result


class ACPSettings(DataModelBase):
    """
    ACPSettings object.

    Parameters
    ----------
    auto_update: Optional[ACPSettingsAutoUpdate]
    metrics: Optional[ACPSettingsMetrics]
    status: Optional[ACPSettingsStatus]

    """

    auto_update: Optional[ACPSettingsAutoUpdate] = None
    metrics: Optional[ACPSettingsMetrics] = None
    status: Optional[ACPSettingsStatus] = None


class ACPStatus(DataModelBase):
    """
    ACPStatus object.

    Parameters
    ----------
    name: Optional[str]
    status: Optional[ACPStatusValues]

    """

    name: Optional[str] = None
    status: Optional[ACPStatusValues] = None

    @classmethod
    def list_acp_status(
        cls,
        acp_names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        source: Optional[str] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ACPStatus], ACPStatusListPaginated]:
        """
        List ACP Status

        **Pagination Key:** `acp_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listACPStatus``: ``GET`` ``/api/v4/acps/status/list``

        Parameters
        ----------
        acp_names : :obj:`Sequence[str]`
            Filter by ACP names
        search : :obj:`Sequence[str]`
            Search ACPs by title and name
        source : :obj:`str`
            Source should be `cache` or `live`. Default: `cache`
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/acps/status/list",
            {},
            {
                "acp_names": acp_names,
                "search": search,
                "source": source,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ACPStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def get_acp_status(
        cls, acp_name: str, source: Optional[str] = None, dry_run: bool = False, client: Any = None
    ) -> ACPStatus:
        """
        Get ACP Status

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getACPStatus``: ``GET`` ``/api/v4/acps/{acp_name}/status/get``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        source : :obj:`str`
            Source should be `cache` or `live`. Default: `cache`

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/acps/{acp_name}/status/get",
            {"acp_name": acp_name},
            {"source": source},
            {},
            {},
            None,
            None,
            False,
            {"200": ACPStatus, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def update_acp_status(
        cls,
        acp_name: str,
        data: Optional[Union[requests.ACPStatusUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ACPStatus:
        """
        Update ACP Status

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateACPStatus``: ``POST`` ``/api/v4/acps/{acp_name}/status/update``

        Parameters
        ----------
        acp_name : :obj:`str`, optional
            ACP name
        data: requests.ACPStatusUpdate, optional
        **kwargs:
            Extra parameters for requests.ACPStatusUpdate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/acps/{acp_name}/status/update",
            {"acp_name": acp_name},
            {},
            {},
            {},
            data,
            requests.ACPStatusUpdate,
            False,
            {"200": ACPStatus, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result


class ACPStatusListPaginated(PaginatorDataModel[ACPStatus]):
    """
    ACPStatusListPaginated object.

    Parameters
    ----------
    data: Optional[List[ACPStatus]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ACPStatus]] = None
    pagination: Optional[pagination.Pagination] = None


class App(DataModelBase):
    """
    App object.

    Parameters
    ----------
    created: Optional[datetime]
    description: Optional[str]
    latest_version: Optional[str]
    name: Optional[str]
    title: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]
    versions: Optional[List[AppVersion]]

    """

    created: Optional[datetime] = None
    description: Optional[str] = None
    latest_version: Optional[str] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    type: Optional[str] = None
    updated: Optional[datetime] = None
    versions: Optional[List[AppVersion]] = None

    @classmethod
    def create_app(
        cls,
        data: Optional[Union[requests.AppCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> App:
        """
        Create App

        **Note:** If the App already exists, the App Version will be appended to the existing App

        **Permission Required:** `kelvin.permission.appregistry.create`.

        ``createApp``: ``POST`` ``/api/v4/appregistry/create``

        Parameters
        ----------
        data: requests.AppCreate, optional
        **kwargs:
            Extra parameters for requests.AppCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/create",
            {},
            {},
            {},
            {},
            data,
            requests.AppCreate,
            False,
            {"201": App, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_apps(
        self_or_cls,
        type: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[App], AppListPaginated]:
        """
        List Apps

        **Pagination Key:** `app_name`

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``listApps``: ``GET`` ``/api/v4/appregistry/list``

        Parameters
        ----------
        type : :obj:`Sequence[str]`
            Match the type field
        search : :obj:`Sequence[str]`
            Search Apps by name and title
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/list",
            {},
            {
                "type": type,
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AppListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"app_versions": "versions"})
    def list_app_version_status(
        self_or_cls,
        app_versions: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[AppVersionStatus], AppVersionStatusListPaginated]:
        """
        List App Version Status

        **Pagination Key:** `app_version_id`

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``listAppVersionStatus``: ``GET`` ``/api/v4/appregistry/versions/status/list``

        Parameters
        ----------
        app_versions : :obj:`Sequence[str]`
            Filter by App Versions. Pattern: `<app_name>:<version>`
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/versions/status/list",
            {},
            {
                "app_versions": app_versions,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersionStatusListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def delete_app(self_or_cls, app_name: str, dry_run: bool = False, client: Any = None) -> None:
        """
        Delete App

        **Note:** Deleting an App will also delete all App Versions

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteApp``: ``POST`` ``/api/v4/appregistry/{app_name}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/delete",
            {"app_name": app_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "412": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def get_app(self_or_cls, app_name: str, dry_run: bool = False, client: Any = None) -> App:
        """
        Get App

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getApp``: ``GET`` ``/api/v4/appregistry/{app_name}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/get",
            {"app_name": app_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": App, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def update_app(
        self_or_cls,
        app_name: str,
        data: Optional[Union[requests.AppUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> App:
        """
        Update App

        **Permission Required:** `kelvin.permission.appregistry.update`.

        ``updateApp``: ``POST`` ``/api/v4/appregistry/{app_name}/update``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        data: requests.AppUpdate, optional
        **kwargs:
            Extra parameters for requests.AppUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/update",
            {"app_name": app_name},
            {},
            {},
            {},
            data,
            requests.AppUpdate,
            False,
            {"200": App, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def delete_app_version(
        self_or_cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete App Version

        **Note:** This operation also deletes the associated Docker Image

        **Permission Required:** `kelvin.permission.appregistry.delete`.

        ``deleteAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/delete``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/delete",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def download_app_version(
        self_or_cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Download App Version


        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``downloadAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/download``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/download",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def get_app_version(
        self_or_cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> AppVersion:
        """
        Get App Version

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersion``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersion, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def get_app_version_status(
        self_or_cls, app_name: str, app_version: str, dry_run: bool = False, client: Any = None
    ) -> AppVersionStatus:
        """
        Get App Version Status

        **Permission Required:** `kelvin.permission.appregistry.read`.

        ``getAppVersionStatus``: ``GET`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/status/get``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/status/get",
            {"app_name": app_name, "app_version": app_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": AppVersionStatus, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"app_name": "name"})
    def upload_app_version(
        self_or_cls,
        app_name: str,
        app_version: str,
        file: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Upload App Version


        **Permission Required:** `kelvin.permission.appregistry.create`.

        ``uploadAppVersion``: ``POST`` ``/api/v4/appregistry/{app_name}/versions/{app_version}/upload``

        Parameters
        ----------
        app_name : :obj:`str`, optional
            App name
        app_version : :obj:`str`, optional
            App Version
        file : :obj:`str`, optional
            File to upload

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/appregistry/{app_name}/versions/{app_version}/upload",
            {"app_name": app_name, "app_version": app_version},
            {},
            {"file": file},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result


class AppListPaginated(PaginatorDataModel[App]):
    """
    AppListPaginated object.

    Parameters
    ----------
    data: Optional[List[App]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[App]] = None
    pagination: Optional[pagination.Pagination] = None


class Cluster(DataModelBase):
    """
    Cluster object.

    Parameters
    ----------
    cidr: Optional[ClusterCIDR]
    created: Optional[datetime]
    info: Optional[Dict[str, Any]]
    kelvin_info: Optional[Dict[str, Any]]
    kubeconfig: Optional[str]
    name: Optional[str]
    network_info: Optional[Dict[str, Any]]
    ready: Optional[bool]
    system_info: Optional[Dict[str, Any]]
    title: Optional[str]
    updated: Optional[datetime]

    """

    cidr: Optional[ClusterCIDR] = None
    created: Optional[datetime] = None
    info: Optional[Dict[str, Any]] = None
    kelvin_info: Optional[Dict[str, Any]] = None
    kubeconfig: Optional[str] = None
    name: Optional[str] = None
    network_info: Optional[Dict[str, Any]] = None
    ready: Optional[bool] = None
    system_info: Optional[Dict[str, Any]] = None
    title: Optional[str] = None
    updated: Optional[datetime] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_cluster(
        self_or_cls,
        data: Optional[Union[requests.ClusterCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Cluster:
        """
        Create Cluster

        **Permission Required:** `kelvin.permission.acp.create`.

        ``createCluster``: ``POST`` ``/api/v4/orchestration/clusters/create``

        Parameters
        ----------
        data: requests.ClusterCreate, optional
        **kwargs:
            Extra parameters for requests.ClusterCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/orchestration/clusters/create",
            {},
            {},
            {},
            {},
            data,
            requests.ClusterCreate,
            False,
            {
                "201": Cluster,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_cluster(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[Cluster], ClusterListPaginated]:
        """
        List Cluster

        **Pagination Key:** `cluster_name`

        **Permission Required:** `kelvin.permission.acp.read`.

        ``listCluster``: ``GET`` ``/api/v4/orchestration/clusters/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search Cluster by name or title
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ClusterListPaginated, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def download_cluster_provision_binary(
        cls, dry_run: bool = False, client: Any = None
    ) -> Iterator[bytes]:
        """
        Download Cluster Provision Binary

        **Permission Required:** `kelvin.permission.orchestration.read`.

        ``downloadClusterProvisionBinary``: ``GET`` ``/api/v4/orchestration/clusters/provision/bin/download``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/provision/bin/download",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": bytes, "400": ErrorMessages, "401": ErrorMessages},
            True,
            dry_run,
        )
        return result

    @classmethod
    def download_cluster_provision_script(
        cls, dry_run: bool = False, client: Any = None
    ) -> OrchestrationProvision:
        """
        Download Cluster Provision Script

        **Permission Required:** `kelvin.permission.orchestration.read`.

        ``downloadClusterProvisionScript``: ``GET`` ``/api/v4/orchestration/clusters/provision/script/download``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/provision/script/download",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": OrchestrationProvision, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_cluster(
        self_or_cls, cluster_name: str, dry_run: bool = False, client: Any = None
    ) -> Cluster:
        """
        Get Cluster

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getCluster``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/get",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": Cluster, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessage},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def get_cluster_manifests(
        self_or_cls,
        cluster_name: str,
        version: Optional[str] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ClusterManifestList:
        """
        Get Cluster Manifests

        **Permission Required:** `kelvin.permission.acp.read`.

        ``getClusterManifests``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/manifests/get``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        version : :obj:`str`
            Current Version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/manifests/get",
            {"cluster_name": cluster_name},
            {"version": version},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ClusterManifestList,
                "204": None,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def download_cluster_private_registry_credentials(
        self_or_cls, cluster_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Download Cluster Private Registry Credentials

        **Permission Required:** `kelvin.permission.acp.read`.

        ``downloadClusterPrivateRegistryCredentials``: ``GET`` ``/api/v4/orchestration/clusters/{cluster_name}/private-registry/download``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/orchestration/clusters/{cluster_name}/private-registry/download",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "500": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"cluster_name": "name"})
    def update_cluster(
        self_or_cls,
        cluster_name: str,
        data: Optional[Union[requests.ClusterUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Cluster:
        """
        Update Cluster

        **Permission Required:** `kelvin.permission.acp.update`.

        ``updateCluster``: ``POST`` ``/api/v4/orchestration/clusters/{cluster_name}/update``

        Parameters
        ----------
        cluster_name : :obj:`str`, optional
            Cluster name
        data: requests.ClusterUpdate, optional
        **kwargs:
            Extra parameters for requests.ClusterUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/orchestration/clusters/{cluster_name}/update",
            {"cluster_name": cluster_name},
            {},
            {},
            {},
            data,
            requests.ClusterUpdate,
            False,
            {
                "200": Cluster,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessage,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ClusterListPaginated(PaginatorDataModel[Cluster]):
    """
    ClusterListPaginated object.

    Parameters
    ----------
    data: Optional[List[Cluster]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[Cluster]] = None
    pagination: Optional[pagination.Pagination] = None


class DataLabel(DataModelBase):
    """
    DataLabel object.

    Parameters
    ----------
    confidence: Optional[int]
    created: Optional[datetime]
    description: Optional[str]
    end_date: Optional[datetime]
    id: Optional[int]
    info: Optional[Dict[str, Any]]
    label_name: Optional[str]
    metrics: Optional[List[DataLabelMetricItem]]
    source: Optional[DataLabelSource]
    start_date: Optional[datetime]
    updated: Optional[datetime]
    validation: Optional[bool]

    """

    confidence: Optional[int] = None
    created: Optional[datetime] = None
    description: Optional[str] = None
    end_date: Optional[datetime] = None
    id: Optional[int] = None
    info: Optional[Dict[str, Any]] = None
    label_name: Optional[str] = None
    metrics: Optional[List[DataLabelMetricItem]] = None
    source: Optional[DataLabelSource] = None
    start_date: Optional[datetime] = None
    updated: Optional[datetime] = None
    validation: Optional[bool] = None

    @instance_classmethod
    @DataModelBase.translate()
    def get_data_labels_clustering(
        self_or_cls,
        data: Optional[Union[requests.DataLabelCluster, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> DataLabelCluster:
        """
        Get Data Labels Clustering

        **Note**:
        * `time_bucket`: needed to aggregate a cluster. Use Go parsing for duration:
        https://golang.org/pkg/time/#ParseDuration
        * `label_names`: lists data labels using **OR** operator;
        * `metrics`: lists data labels using **OR** operator;
        * `start_date`: lists data labels with start_date >= query date (RFC3339 format with microseconds);
        * `end_date`: lists data labels with end_date <= query date (RFC3339 format with microseconds)

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getDataLabelsClustering``: ``POST`` ``/api/v4/datalabels/clustering/get``

        Parameters
        ----------
        data: requests.DataLabelCluster, optional
        **kwargs:
            Extra parameters for requests.DataLabelCluster

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/clustering/get",
            {},
            {},
            {},
            {},
            data,
            requests.DataLabelCluster,
            False,
            {"200": DataLabelCluster, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_data_label(
        self_or_cls,
        data: Optional[Union[requests.DataLabelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> DataLabel:
        """
        Create Data Label

        **Note:**
        * If `label_name` is provided and does not exist, it will create a new label
        * The `source.type` can be `workload` or `user`

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createDataLabel``: ``POST`` ``/api/v4/datalabels/create``

        Parameters
        ----------
        data: requests.DataLabelCreate, optional
        **kwargs:
            Extra parameters for requests.DataLabelCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/create",
            {},
            {},
            {},
            {},
            data,
            requests.DataLabelCreate,
            False,
            {"201": DataLabel, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def filter_data_label(
        self_or_cls,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        data: Optional[Union[requests.DataLabelFilter, Mapping[str, Any]]] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Union[Sequence[DataLabel], DataLabelListPaginated]:
        """
        Filter Data Label

        **Pagination Key:** `data_label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``filterDataLabel``: ``POST`` ``/api/v4/datalabels/filter``

        Parameters
        ----------
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination
        data: requests.DataLabelFilter, optional
        **kwargs:
            Extra parameters for requests.DataLabelFilter

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/filter",
            {},
            {
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            data,
            requests.DataLabelFilter,
            False,
            {"200": DataLabelListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_label(
        cls,
        data: Optional[Union[requests.LabelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Label:
        """
        Create Label

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabel``: ``POST`` ``/api/v4/datalabels/labels/create``

        Parameters
        ----------
        data: requests.LabelCreate, optional
        **kwargs:
            Extra parameters for requests.LabelCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/create",
            {},
            {},
            {},
            {},
            data,
            requests.LabelCreate,
            False,
            {"201": Label, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_label(
        cls,
        names: Optional[Sequence[str]] = None,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[Label], LabelListPaginated]:
        """
        List Label

        **Pagination Key:** `label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listLabel``: ``GET`` ``/api/v4/datalabels/labels/list``

        Parameters
        ----------
        names : :obj:`Sequence[str]`
            Filter labels by name
        search : :obj:`Sequence[str]`
            Search Labels by name or title
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/list",
            {},
            {
                "names": names,
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": LabelListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_label_metadata_bulk(
        cls,
        data: Optional[Union[requests.LabelMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create Label Metadata Bulk

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabelMetadataBulk``: ``POST`` ``/api/v4/datalabels/labels/metadata/create``

        Parameters
        ----------
        data: requests.LabelMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.LabelMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_label_metadata_bulk(
        cls,
        data: Optional[Union[requests.LabelMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete Label Metadata Bulk

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabelMetadataBulk``: ``POST`` ``/api/v4/datalabels/labels/metadata/delete``

        Parameters
        ----------
        data: requests.LabelMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.LabelMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_label(
        self_or_cls, label_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete Label

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabel``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/delete``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/delete",
            {"label_name": label_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_label(
        self_or_cls,
        label_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> Label:
        """
        Get Label

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getLabel``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/get``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/get",
            {"label_name": label_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": Label, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_label_metadata(
        self_or_cls,
        label_name: str,
        data: Optional[Union[requests.LabelMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Create Label Metadata

        **Permission Required:** `kelvin.permission.data_label.create`.

        ``createLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/create``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        data: requests.LabelMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/create",
            {"label_name": label_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataCreate,
            False,
            {
                "201": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_label_metadata(
        self_or_cls,
        label_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[LabelMetadata], LabelMetadataListPaginated]:
        """
        List Label Metadata

        **Pagination Key:** `label_metadata_name,label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/list``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        search : :obj:`Sequence[str]`
            Search Label Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/list",
            {"label_name": label_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": LabelMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete Label Metadata

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/delete",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> LabelMetadata:
        """
        Get Label Metadata

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getLabelMetadata``: ``GET`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/get",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_label_metadata(
        self_or_cls,
        label_name: str,
        label_metadata_name: str,
        data: Optional[Union[requests.LabelMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> LabelMetadata:
        """
        Update Label Metadata

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateLabelMetadata``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        label_metadata_name : :obj:`str`, optional
            Label Metadata name
        data: requests.LabelMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.LabelMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/metadata/{label_metadata_name}/update",
            {"label_name": label_name, "label_metadata_name": label_metadata_name},
            {},
            {},
            {},
            data,
            requests.LabelMetadataUpdate,
            False,
            {
                "200": LabelMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_label(
        self_or_cls,
        label_name: str,
        data: Optional[Union[requests.LabelUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Label:
        """
        Update Label

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateLabel``: ``POST`` ``/api/v4/datalabels/labels/{label_name}/update``

        Parameters
        ----------
        label_name : :obj:`str`, optional
            Label name
        data: requests.LabelUpdate, optional
        **kwargs:
            Extra parameters for requests.LabelUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/labels/{label_name}/update",
            {"label_name": label_name},
            {},
            {},
            {},
            data,
            requests.LabelUpdate,
            False,
            {
                "200": Label,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_data_label(
        cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[DataLabel], DataLabelListPaginated]:
        """
        List Data Label

        **Pagination Key:** `data_label_name`

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``listDataLabel``: ``GET`` ``/api/v4/datalabels/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search datalabels by description and label name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": DataLabelListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def get_data_label_range(
        self_or_cls,
        data: Optional[Union[requests.DataLabelRange, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> Iterator[DataLabel]:
        """
        Get Data Label Range

        **Note**:
        * Between filters a **AND*+ operator is implicit
        * `label_names`: lists data labels using **OR** operator;
        * `metrics`: lists data labels using **OR** operator;
        * `start_date`: lists data labels with start_date >= query date (RFC3339 format with microseconds);
        * `end_date`: lists data labels with end_date <= query date (RFC3339 format with microseconds)

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getDataLabelRange``: ``POST`` ``/api/v4/datalabels/range/get``

        Parameters
        ----------
        data: requests.DataLabelRange, optional
        **kwargs:
            Extra parameters for requests.DataLabelRange

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/range/get",
            {},
            {},
            {},
            {},
            data,
            requests.DataLabelRange,
            False,
            {"200": DataLabel, "400": ErrorMessages, "401": ErrorMessages},
            True,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_data_label(
        cls, datalabel_id: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete Data Label

        **Permission Required:** `kelvin.permission.data_label.delete`.

        ``deleteDataLabel``: ``POST`` ``/api/v4/datalabels/{datalabel_id}/delete``

        Parameters
        ----------
        datalabel_id : :obj:`str`, optional
            Data Label id

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/{datalabel_id}/delete",
            {"datalabel_id": datalabel_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_data_label(
        cls, datalabel_id: str, dry_run: bool = False, client: Any = None
    ) -> DataLabel:
        """
        Get Data Label

        **Permission Required:** `kelvin.permission.data_label.read`.

        ``getDataLabel``: ``GET`` ``/api/v4/datalabels/{datalabel_id}/get``

        Parameters
        ----------
        datalabel_id : :obj:`str`, optional
            Data Label id

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/datalabels/{datalabel_id}/get",
            {"datalabel_id": datalabel_id},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": DataLabel, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_data_label(
        self_or_cls,
        datalabel_id: str,
        data: Optional[Union[requests.DataLabelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> DataLabel:
        """
        Update Data Label

        **Note:**
        * If `metrics` are provided, it will replace the full list
        * If `label_name` is provided and does not exist, it will create a new label

        **Permission Required:** `kelvin.permission.data_label.update`.

        ``updateDataLabel``: ``POST`` ``/api/v4/datalabels/{datalabel_id}/update``

        Parameters
        ----------
        datalabel_id : :obj:`str`, optional
            DataLabel id
        data: requests.DataLabelCreate, optional
        **kwargs:
            Extra parameters for requests.DataLabelCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datalabels/{datalabel_id}/update",
            {"datalabel_id": datalabel_id},
            {},
            {},
            {},
            data,
            requests.DataLabelCreate,
            False,
            {
                "200": DataLabel,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class DataLabelListPaginated(PaginatorDataModel[DataLabel]):
    """
    DataLabelListPaginated object.

    Parameters
    ----------
    data: Optional[List[DataLabel]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[DataLabel]] = None
    pagination: Optional[pagination.Pagination] = None


class DataModel(DataModelBase):
    """
    DataModel object.

    Parameters
    ----------
    created: Optional[datetime]
    icd: Optional[ICDPayload]
    name: Optional[str]
    schema: Optional[Dict[str, Any]]
    source: Optional[str]
    type: Optional[str]
    updated: Optional[datetime]
    version: Optional[str]

    """

    created: Optional[datetime] = None
    icd: Optional[ICDPayload] = None
    name: Optional[str] = Field(None, max_length=64)
    schema: Optional[Dict[str, Any]] = None
    source: Optional[str] = None
    type: Optional[str] = Field(None, max_length=45)
    updated: Optional[datetime] = None
    version: Optional[str] = Field(None, max_length=45)

    @instance_classmethod
    @DataModelBase.translate()
    def create_data_model(
        self_or_cls,
        data: Optional[Union[requests.DataModelCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> DataModel:
        """
        Create Data Model
        Regex validators:
        - data model name: `^([a-z][a-z0-9_]+\.)+[a-z][a-z0-9_]+$`
        - data model class_name: `^[a-zA-Z][a-zA-Z0-9_]+$`

        **Permission Required:** `kelvin.permission.data_model.create`.

        ``createDataModel``: ``POST`` ``/api/v4/datamodels/create``

        Parameters
        ----------
        data: requests.DataModelCreate, optional
        **kwargs:
            Extra parameters for requests.DataModelCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/datamodels/create",
            {},
            {},
            {},
            {},
            data,
            requests.DataModelCreate,
            False,
            {"201": DataModel, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_data_model(
        cls,
        search: Optional[Sequence[str]] = None,
        all: Optional[bool] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[DataModel], DataModelListPaginated]:
        """
        List Data Model
        By default returns only the latest versions for each data model

        **Pagination Key:** `datamodel_name,datamodel_version`

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``listDataModel``: ``GET`` ``/api/v4/datamodels/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search data models by name
        all : :obj:`bool`
            List all versions of all data models. If false, it will only list the
            latest version. Default: False.
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/list",
            {},
            {
                "search": search,
                "all": all,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": DataModelListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"data_model_name": "name"})
    def get_data_model_latest_version(
        self_or_cls, data_model_name: str, dry_run: bool = False, client: Any = None
    ) -> DataModel:
        """
        Get Data Model Latest Version

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``getDataModelLatestVersion``: ``GET`` ``/api/v4/datamodels/{data_model_name}/versions/latest/get``

        Parameters
        ----------
        data_model_name : :obj:`str`, optional
            Data Model name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/{data_model_name}/versions/latest/get",
            {"data_model_name": data_model_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": DataModel, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_model_name": "name", "data_model_version": "version"})
    def get_data_model_dependencies(
        self_or_cls,
        data_model_name: str,
        data_model_version: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> DataModel:
        """
        Get Data Model Dependencies. This endpoint ill return all dependencies levels in a flattened array.

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``getDataModelDependencies``: ``GET`` ``/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/dependencies/get``

        Parameters
        ----------
        data_model_name : :obj:`str`, optional
            Data Model name
        data_model_version : :obj:`str`, optional
            Data Model version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/dependencies/get",
            {"data_model_name": data_model_name, "data_model_version": data_model_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": DataModel, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_model_name": "name", "data_model_version": "version"})
    def get_data_model(
        self_or_cls,
        data_model_name: str,
        data_model_version: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> DataModel:
        """
        Get Data Model

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``getDataModel``: ``GET`` ``/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/get``

        Parameters
        ----------
        data_model_name : :obj:`str`, optional
            Data Model name
        data_model_version : :obj:`str`, optional
            Data Model version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/get",
            {"data_model_name": data_model_name, "data_model_version": data_model_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": DataModel, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"data_model_name": "name", "data_model_version": "version"})
    def get_data_model_schema(
        self_or_cls,
        data_model_name: str,
        data_model_version: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> DataModelSchema:
        """
        Get Data Model Schema

        **Permission Required:** `kelvin.permission.data_model.read`.

        ``getDataModelSchema``: ``GET`` ``/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/schema/get``

        Parameters
        ----------
        data_model_name : :obj:`str`, optional
            Data Model name
        data_model_version : :obj:`str`, optional
            Data Model version

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/datamodels/{data_model_name}/versions/{data_model_version}/schema/get",
            {"data_model_name": data_model_name, "data_model_version": data_model_version},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": DataModelSchema,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result


class DataModelListPaginated(PaginatorDataModel[DataModel]):
    """
    DataModelListPaginated object.

    Parameters
    ----------
    data: Optional[List[DataModel]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[DataModel]] = None
    pagination: Optional[pagination.Pagination] = None


class InstanceSettings(DataModelBase):
    """
    InstanceSettings object.

    Parameters
    ----------
    acp: Optional[ACPSettings]

    """

    acp: Optional[ACPSettings] = None

    @classmethod
    def get_instance_settings(cls, dry_run: bool = False, client: Any = None) -> InstanceSettings:
        """
        Get Instance Settings

        **Permission Required:** `kelvin.permission.instance.read`.

        ``getInstanceSettings``: ``GET`` ``/api/v4/instance/settings/get``

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/instance/settings/get",
            {},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": InstanceSettings,
                "400": ErrorMessage,
                "401": ErrorMessage,
                "404": ErrorMessage,
                "500": ErrorMessage,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_instance_settings(
        self_or_cls,
        data: Optional[Union[requests.InstanceSettings, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> InstanceSettings:
        """
        Update Instance Settings

        **Permission Required:** `kelvin.permission.instance.update`.

        ``updateInstanceSettings``: ``POST`` ``/api/v4/instance/settings/update``

        Parameters
        ----------
        data: requests.InstanceSettings, optional
        **kwargs:
            Extra parameters for requests.InstanceSettings

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/instance/settings/update",
            {},
            {},
            {},
            {},
            data,
            requests.InstanceSettings,
            False,
            {"200": InstanceSettings, "400": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewGroup(DataModelBase):
    """
    ViewGroup object.

    Parameters
    ----------
    created: Optional[datetime]
    metadata: Optional[Dict[str, Any]]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]
    views: Optional[List[ViewItem]]

    """

    created: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None
    views: Optional[List[ViewItem]] = None

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group(
        self_or_cls,
        data: Optional[Union[requests.ViewGroupCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Create View Group

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroup``: ``POST`` ``/api/v4/views/groups/create``

        Parameters
        ----------
        data: requests.ViewGroupCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupCreate,
            False,
            {"201": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_group(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroup], ViewGroupListPaginated]:
        """
        List View Group

        **Pagination Key:** `view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroup``: ``GET`` ``/api/v4/views/groups/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Group by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/create``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/delete``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def delete_view_group(
        self_or_cls, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Group

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/delete",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def get_view_group(
        self_or_cls,
        view_group_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroup:
        """
        Get View Group

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroup``: ``GET`` ``/api/v4/views/groups/{view_group_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/get",
            {"view_group_name": view_group_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def create_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Create View Group Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/create``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        data: requests.ViewGroupMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/create",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataCreate,
            False,
            {
                "201": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def list_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroupMetadata], ViewGroupMetadataListPaginated]:
        """
        List View Group Metadata

        **Pagination Key:** `view_group_metadata_name,view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/list``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        search : :obj:`Sequence[str]`
            Search View Group Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/list",
            {"view_group_name": view_group_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def delete_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Group Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def get_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroupMetadata:
        """
        Get View Group Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def update_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        view_group_metadata_name: str,
        data: Optional[Union[requests.ViewGroupMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Update View Group Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name
        data: requests.ViewGroupMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataUpdate,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_group_name": "name"})
    def update_view_group(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Update View Group

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        data: requests.ViewGroupUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/update",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupUpdate,
            False,
            {
                "200": ViewGroup,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result


class ViewGroupListPaginated(PaginatorDataModel[ViewGroup]):
    """
    ViewGroupListPaginated object.

    Parameters
    ----------
    data: Optional[List[ViewGroup]]
    pagination: Optional[pagination.Pagination]

    """

    data: Optional[List[ViewGroup]] = None
    pagination: Optional[pagination.Pagination] = None


class WorkloadMetrics(DataModelBase):
    """
    WorkloadMetrics object.

    Parameters
    ----------
    allocation: Optional[WorkloadAllocation]
    cpu_utilization: Optional[List[WorkloadCPUUtilization]]
    memory_usage: Optional[List[WorkloadMemoryUsage]]
    network: Optional[WorkloadNetwork]

    """

    allocation: Optional[WorkloadAllocation] = None
    cpu_utilization: Optional[List[WorkloadCPUUtilization]] = None
    memory_usage: Optional[List[WorkloadMemoryUsage]] = None
    network: Optional[WorkloadNetwork] = None

    @classmethod
    def get_workload_metrics(
        cls, workload_name: str, dry_run: bool = False, client: Any = None
    ) -> WorkloadMetrics:
        """
        Get Workload Metrics

        **Permission Required:** `kelvin.permission.workload.read`.

        ``getWorkloadMetrics``: ``GET`` ``/api/v4/workloads/{workload_name}/metrics/get``

        Parameters
        ----------
        workload_name : :obj:`str`, optional
            Workload name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/workloads/{workload_name}/metrics/get",
            {"workload_name": workload_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": WorkloadMetrics, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result


class View(DataModelBase):
    """
    View object.

    Parameters
    ----------
    created: Optional[datetime]
    groups: Optional[List[ViewGroup]]
    metadata: Optional[Dict[str, Any]]
    metrics: Optional[List[ViewMetric]]
    name: Optional[str]
    title: Optional[str]
    updated: Optional[datetime]
    view_type_name: Optional[str]

    """

    created: Optional[datetime] = None
    groups: Optional[List[ViewGroup]] = None
    metadata: Optional[Dict[str, Any]] = None
    metrics: Optional[List[ViewMetric]] = None
    name: Optional[str] = Field(None, max_length=64)
    title: Optional[str] = Field(None, max_length=64)
    updated: Optional[datetime] = None
    view_type_name: Optional[str] = Field(None, max_length=64)

    @instance_classmethod
    @DataModelBase.translate()
    def create_view(
        self_or_cls,
        data: Optional[Union[requests.ViewCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> View:
        """
        Create View

        **Permission Required:** `kelvin.permission.view.create`.

        ``createView``: ``POST`` ``/api/v4/views/create``

        Parameters
        ----------
        data: requests.ViewCreate, optional
        **kwargs:
            Extra parameters for requests.ViewCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewCreate,
            False,
            {"201": View, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group(
        self_or_cls,
        data: Optional[Union[requests.ViewGroupCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Create View Group

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroup``: ``POST`` ``/api/v4/views/groups/create``

        Parameters
        ----------
        data: requests.ViewGroupCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupCreate,
            False,
            {"201": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_group(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroup], ViewGroupListPaginated]:
        """
        List View Group

        **Pagination Key:** `view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroup``: ``GET`` ``/api/v4/views/groups/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Group by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/list",
            {},
            {
                "search": search,
                "page_size": page_size,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/create``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_group_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewGroupMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Group Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadataBulk``: ``POST`` ``/api/v4/views/groups/metadata/delete``

        Parameters
        ----------
        data: requests.ViewGroupMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_group(
        cls, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Group

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/delete",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_group(
        self_or_cls,
        view_group_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroup:
        """
        Get View Group

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroup``: ``GET`` ``/api/v4/views/groups/{view_group_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/get",
            {"view_group_name": view_group_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroup, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_group_metadata(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Create View Group Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/create``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        data: requests.ViewGroupMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/create",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataCreate,
            False,
            {
                "201": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def list_view_group_metadata(
        cls,
        view_group_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewGroupMetadata], ViewGroupMetadataListPaginated]:
        """
        List View Group Metadata

        **Pagination Key:** `view_group_metadata_name,view_group_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/list``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        search : :obj:`Sequence[str]`
            Search View Group Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/list",
            {"view_group_name": view_group_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewGroupMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def delete_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Group Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/delete",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @classmethod
    def get_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewGroupMetadata:
        """
        Get View Group Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewGroupMetadata``: ``GET`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name

        """

        result = cls._make_request(
            client,
            "get",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/get",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @classmethod
    def update_view_group_metadata(
        cls,
        view_group_name: str,
        view_group_metadata_name: str,
        data: Optional[Union[requests.ViewGroupMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroupMetadata:
        """
        Update View Group Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroupMetadata``: ``POST`` ``/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View group name
        view_group_metadata_name : :obj:`str`, optional
            View Group Metadata name
        data: requests.ViewGroupMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupMetadataUpdate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/metadata/{view_group_metadata_name}/update",
            {
                "view_group_name": view_group_name,
                "view_group_metadata_name": view_group_metadata_name,
            },
            {},
            {},
            {},
            data,
            requests.ViewGroupMetadataUpdate,
            False,
            {
                "200": ViewGroupMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_group(
        self_or_cls,
        view_group_name: str,
        data: Optional[Union[requests.ViewGroupUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewGroup:
        """
        Update View Group

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewGroup``: ``POST`` ``/api/v4/views/groups/{view_group_name}/update``

        Parameters
        ----------
        view_group_name : :obj:`str`, optional
            View Group name
        data: requests.ViewGroupUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewGroupUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/groups/{view_group_name}/update",
            {"view_group_name": view_group_name},
            {},
            {},
            {},
            data,
            requests.ViewGroupUpdate,
            False,
            {
                "200": ViewGroup,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        view_type_name: Optional[Sequence[str]] = None,
        view_group_name: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewItem], ViewListPaginated]:
        """
        List View

        **Pagination Key:** `view_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listView``: ``GET`` ``/api/v4/views/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search views by name or title
        view_type_name : :obj:`Sequence[str]`
            Filter views by view type
        view_group_name : :obj:`Sequence[str]`
            Filter views by view group
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/list",
            {},
            {
                "search": search,
                "view_type_name": view_type_name,
                "view_group_name": view_group_name,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewMetadataBulk``: ``POST`` ``/api/v4/views/metadata/create``

        Parameters
        ----------
        data: requests.ViewMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewMetadataBulk``: ``POST`` ``/api/v4/views/metadata/delete``

        Parameters
        ----------
        data: requests.ViewMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type(
        self_or_cls,
        data: Optional[Union[requests.ViewTypeCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Create View Type

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewType``: ``POST`` ``/api/v4/views/types/create``

        Parameters
        ----------
        data: requests.ViewTypeCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeCreate,
            False,
            {"201": ViewType, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_type(
        self_or_cls,
        search: Optional[Sequence[str]] = None,
        metadata: Optional[Sequence[str]] = None,
        metadata_filter: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewType], ViewTypeListPaginated]:
        """
        List View Type

        **Pagination Key:** `view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewType``: ``GET`` ``/api/v4/views/types/list``

        Parameters
        ----------
        search : :obj:`Sequence[str]`
            Search View Type by name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response
        metadata_filter : :obj:`Sequence[str]`
            Dot separated string to filter by metadata values Same <metadata_name>
            will result in OR queries. Different <metadata_name> will result in
            AND queries. Example:
            <metadata_name>.<payload_key_to_search>=<payload_value_to_search>
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/list",
            {},
            {
                "search": search,
                "metadata": metadata,
                "metadata_filter": metadata_filter,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @classmethod
    def create_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Create View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/create``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkCreate

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/create",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkCreate,
            False,
            {
                "201": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @classmethod
    def delete_view_type_metadata_bulk(
        cls,
        data: Optional[Union[requests.ViewTypeMetadataBulkDelete, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> None:
        """
        Delete View Type Metadata Bulk

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadataBulk``: ``POST`` ``/api/v4/views/types/metadata/delete``

        Parameters
        ----------
        data: requests.ViewTypeMetadataBulkDelete, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataBulkDelete

        """

        result = cls._make_request(
            client,
            "post",
            "/api/v4/views/types/metadata/delete",
            {},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataBulkDelete,
            False,
            {
                "200": None,
                "207": ErrorMessages,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_view_type(
        self_or_cls, view_type_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View Type

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/delete",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_type(
        self_or_cls,
        view_type_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewType:
        """
        Get View Type

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewType``: ``GET`` ``/api/v4/views/types/{view_type_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/get",
            {"view_type_name": view_type_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewType, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def create_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Create View Type Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/create``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/create",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataCreate,
            False,
            {
                "201": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def list_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewTypeMetadata], ViewTypeMetadataListPaginated]:
        """
        List View Type Metadata

        **Pagination Key:** `view_type_metadata_name,view_type_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/list``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        search : :obj:`Sequence[str]`
            Search View Type Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/list",
            {"view_type_name": view_type_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewTypeMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate()
    def delete_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Type Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/delete",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def get_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewTypeMetadata:
        """
        Get View Type Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewTypeMetadata``: ``GET`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/get",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
            },
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_type_metadata(
        self_or_cls,
        view_type_name: str,
        view_type_metadata_name: str,
        data: Optional[Union[requests.ViewTypeMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewTypeMetadata:
        """
        Update View Type Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewTypeMetadata``: ``POST`` ``/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        view_type_metadata_name : :obj:`str`, optional
            View Type Metadata name
        data: requests.ViewTypeMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/metadata/{view_type_metadata_name}/update",
            {"view_type_name": view_type_name, "view_type_metadata_name": view_type_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeMetadataUpdate,
            False,
            {
                "200": ViewTypeMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate()
    def update_view_type(
        self_or_cls,
        view_type_name: str,
        data: Optional[Union[requests.ViewTypeUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewType:
        """
        Update View Type

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewType``: ``POST`` ``/api/v4/views/types/{view_type_name}/update``

        Parameters
        ----------
        view_type_name : :obj:`str`, optional
            View Type name
        data: requests.ViewTypeUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewTypeUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/types/{view_type_name}/update",
            {"view_type_name": view_type_name},
            {},
            {},
            {},
            data,
            requests.ViewTypeUpdate,
            False,
            {
                "200": ViewType,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def delete_view(self_or_cls, view_name: str, dry_run: bool = False, client: Any = None) -> None:
        """
        Delete View

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteView``: ``POST`` ``/api/v4/views/{view_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/delete",
            {"view_name": view_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def get_view(
        self_or_cls,
        view_name: str,
        metadata: Optional[Sequence[str]] = None,
        dry_run: bool = False,
        client: Any = None,
    ) -> View:
        """
        Get View

        **Permission Required:** `kelvin.permission.view.read`.

        ``getView``: ``GET`` ``/api/v4/views/{view_name}/get``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        metadata : :obj:`Sequence[str]`
            Inject metadata into the response

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/get",
            {"view_name": view_name},
            {"metadata": metadata},
            {},
            {},
            None,
            None,
            False,
            {"200": View, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def create_view_view_group_relationship(
        self_or_cls, view_name: str, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Create View View Group Relationship

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewViewGroupRelationship``: ``POST`` ``/api/v4/views/{view_name}/groups/{view_group_name}/create``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/groups/{view_group_name}/create",
            {"view_name": view_name, "view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"201": None, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def delete_view_view_group_relationship(
        self_or_cls, view_name: str, view_group_name: str, dry_run: bool = False, client: Any = None
    ) -> None:
        """
        Delete View View Group Relationship

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewViewGroupRelationship``: ``POST`` ``/api/v4/views/{view_name}/groups/{view_group_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_group_name : :obj:`str`, optional
            View Group name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/groups/{view_group_name}/delete",
            {"view_name": view_name, "view_group_name": view_group_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def create_view_metadata(
        self_or_cls,
        view_name: str,
        data: Optional[Union[requests.ViewMetadataCreate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Create View Metadata

        **Permission Required:** `kelvin.permission.view.create`.

        ``createViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/create``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        data: requests.ViewMetadataCreate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataCreate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/create",
            {"view_name": view_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataCreate,
            False,
            {"201": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "409": ErrorMessages},
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def list_view_metadata(
        self_or_cls,
        view_name: str,
        search: Optional[Sequence[str]] = None,
        page_size: Optional[int] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        fetch: bool = True,
        dry_run: bool = False,
        client: Any = None,
    ) -> Union[Sequence[ViewMetadata], ViewMetadataListPaginated]:
        """
        List View Metadata

        **Pagination Key:** `view_metadata_name,view_name`

        **Permission Required:** `kelvin.permission.view.read`.

        ``listViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/list``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        search : :obj:`Sequence[str]`
            Search View Metadata by name
        page_size : :obj:`int`
            Number of objects to be returned, between 1 and 200. Default: 20
        starting_after : :obj:`str`
            Lower bound cursor for use in pagination
        ending_before : :obj:`str`
            Upper bound cursor for use in pagination

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/list",
            {"view_name": view_name},
            {
                "search": search,
                "page_size": page_size,
                "starting_after": starting_after,
                "ending_before": ending_before,
            },
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadataListPaginated, "400": ErrorMessages, "401": ErrorMessages},
            False,
            dry_run,
        )
        return result.fetch() if fetch and not dry_run else result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def delete_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> None:
        """
        Delete View Metadata

        **Permission Required:** `kelvin.permission.view.delete`.

        ``deleteViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/delete",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": None, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def get_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        dry_run: bool = False,
        client: Any = None,
    ) -> ViewMetadata:
        """
        Get View Metadata

        **Permission Required:** `kelvin.permission.view.read`.

        ``getViewMetadata``: ``GET`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/get``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name

        """

        result = self_or_cls._make_request(
            client,
            "get",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/get",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            None,
            None,
            False,
            {"200": ViewMetadata, "400": ErrorMessages, "401": ErrorMessages, "404": ErrorMessages},
            False,
            dry_run,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def update_view_metadata(
        self_or_cls,
        view_name: str,
        view_metadata_name: str,
        data: Optional[Union[requests.ViewMetadataUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> ViewMetadata:
        """
        Update View Metadata

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateViewMetadata``: ``POST`` ``/api/v4/views/{view_name}/metadata/{view_metadata_name}/update``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        view_metadata_name : :obj:`str`, optional
            View Metadata name
        data: requests.ViewMetadataUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewMetadataUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/metadata/{view_metadata_name}/update",
            {"view_name": view_name, "view_metadata_name": view_metadata_name},
            {},
            {},
            {},
            data,
            requests.ViewMetadataUpdate,
            False,
            {
                "200": ViewMetadata,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result

    @instance_classmethod
    @DataModelBase.translate({"view_name": "name"})
    def update_view(
        self_or_cls,
        view_name: str,
        data: Optional[Union[requests.ViewUpdate, Mapping[str, Any]]] = None,
        dry_run: bool = False,
        client: Any = None,
        **kwargs: Any,
    ) -> View:
        """
        Update View

        **Permission Required:** `kelvin.permission.view.update`.

        ``updateView``: ``POST`` ``/api/v4/views/{view_name}/update``

        Parameters
        ----------
        view_name : :obj:`str`, optional
            View name
        data: requests.ViewUpdate, optional
        **kwargs:
            Extra parameters for requests.ViewUpdate

        """

        result = self_or_cls._make_request(
            client,
            "post",
            "/api/v4/views/{view_name}/update",
            {"view_name": view_name},
            {},
            {},
            {},
            data,
            requests.ViewUpdate,
            False,
            {
                "200": View,
                "400": ErrorMessages,
                "401": ErrorMessages,
                "404": ErrorMessages,
                "409": ErrorMessages,
            },
            False,
            dry_run,
            **kwargs,
        )
        return result
